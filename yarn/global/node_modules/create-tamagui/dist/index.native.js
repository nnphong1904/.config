#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
));

// ../../node_modules/color-name/index.js
var require_color_name = __commonJS({
  "../../node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
  }
});

// ../../node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "../../node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name(), reverseKeywords = {};
    for (let key of Object.keys(cssKeywords))
      reverseKeywords[cssKeywords[key]] = key;
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (let model of Object.keys(convert)) {
      if (!("channels" in convert[model]))
        throw new Error("missing channels property: " + model);
      if (!("labels" in convert[model]))
        throw new Error("missing channel labels property: " + model);
      if (convert[model].labels.length !== convert[model].channels)
        throw new Error("channel and label counts mismatch: " + model);
      let { channels, labels } = convert[model];
      delete convert[model].channels, delete convert[model].labels, Object.defineProperty(convert[model], "channels", { value: channels }), Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      let r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s;
      max === min ? h = 0 : r === max ? h = (g - b) / delta : g === max ? h = 2 + (b - r) / delta : b === max && (h = 4 + (r - g) / delta), h = Math.min(h * 60, 360), h < 0 && (h += 360);
      let l = (min + max) / 2;
      return max === min ? s = 0 : l <= 0.5 ? s = delta / (max + min) : s = delta / (2 - max - min), [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif, gdif, bdif, h, s, r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, v = Math.max(r, g, b), diff = v - Math.min(r, g, b), diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      return diff === 0 ? (h = 0, s = 0) : (s = diff / v, rdif = diffc(r), gdif = diffc(g), bdif = diffc(b), r === v ? h = bdif - gdif : g === v ? h = 1 / 3 + rdif - bdif : b === v && (h = 2 / 3 + gdif - rdif), h < 0 ? h += 1 : h > 1 && (h -= 1)), [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      let r = rgb[0], g = rgb[1], b = rgb[2], h = convert.rgb.hsl(rgb)[0], w = 1 / 255 * Math.min(r, Math.min(g, b));
      return b = 1 - 1 / 255 * Math.max(r, Math.max(g, b)), [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      let r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, k = Math.min(1 - r, 1 - g, 1 - b), c = (1 - r - k) / (1 - k) || 0, m = (1 - g - k) / (1 - k) || 0, y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      let reversed = reverseKeywords[rgb];
      if (reversed)
        return reversed;
      let currentClosestDistance = 1 / 0, currentClosestKeyword;
      for (let keyword of Object.keys(cssKeywords)) {
        let value = cssKeywords[keyword], distance = comparativeDistance(rgb, value);
        distance < currentClosestDistance && (currentClosestDistance = distance, currentClosestKeyword = keyword);
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92, g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92, b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      let x = r * 0.4124 + g * 0.3576 + b * 0.1805, y = r * 0.2126 + g * 0.7152 + b * 0.0722, z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      let xyz = convert.rgb.xyz(rgb), x = xyz[0], y = xyz[1], z = xyz[2];
      x /= 95.047, y /= 100, z /= 108.883, x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116, y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116, z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      let l = 116 * y - 16, a = 500 * (x - y), b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      let h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t2, t3, val;
      if (s === 0)
        return val = l * 255, [val, val, val];
      l < 0.5 ? t2 = l * (1 + s) : t2 = l + s - l * s;
      let t1 = 2 * l - t2, rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++)
        t3 = h + 1 / 3 * -(i - 1), t3 < 0 && t3++, t3 > 1 && t3--, 6 * t3 < 1 ? val = t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? val = t2 : 3 * t3 < 2 ? val = t1 + (t2 - t1) * (2 / 3 - t3) * 6 : val = t1, rgb[i] = val * 255;
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      let h = hsl[0], s = hsl[1] / 100, l = hsl[2] / 100, smin = s, lmin = Math.max(l, 0.01);
      l *= 2, s *= l <= 1 ? l : 2 - l, smin *= lmin <= 1 ? lmin : 2 - lmin;
      let v = (l + s) / 2, sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      let h = hsv[0] / 60, s = hsv[1] / 100, v = hsv[2] / 100, hi = Math.floor(h) % 6, f = h - Math.floor(h), p = 255 * v * (1 - s), q = 255 * v * (1 - s * f), t = 255 * v * (1 - s * (1 - f));
      switch (v *= 255, hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      let h = hsv[0], s = hsv[1] / 100, v = hsv[2] / 100, vmin = Math.max(v, 0.01), sl, l;
      l = (2 - s) * v;
      let lmin = (2 - s) * vmin;
      return sl = s * vmin, sl /= lmin <= 1 ? lmin : 2 - lmin, sl = sl || 0, l /= 2, [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      let h = hwb[0] / 360, wh = hwb[1] / 100, bl = hwb[2] / 100, ratio = wh + bl, f;
      ratio > 1 && (wh /= ratio, bl /= ratio);
      let i = Math.floor(6 * h), v = 1 - bl;
      f = 6 * h - i, i & 1 && (f = 1 - f);
      let n = wh + f * (v - wh), r, g, b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v, g = n, b = wh;
          break;
        case 1:
          r = n, g = v, b = wh;
          break;
        case 2:
          r = wh, g = v, b = n;
          break;
        case 3:
          r = wh, g = n, b = v;
          break;
        case 4:
          r = n, g = wh, b = v;
          break;
        case 5:
          r = v, g = wh, b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      let c = cmyk[0] / 100, m = cmyk[1] / 100, y = cmyk[2] / 100, k = cmyk[3] / 100, r = 1 - Math.min(1, c * (1 - k) + k), g = 1 - Math.min(1, m * (1 - k) + k), b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      let x = xyz[0] / 100, y = xyz[1] / 100, z = xyz[2] / 100, r, g, b;
      return r = x * 3.2406 + y * -1.5372 + z * -0.4986, g = x * -0.9689 + y * 1.8758 + z * 0.0415, b = x * 0.0557 + y * -0.204 + z * 1.057, r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92, g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92, b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92, r = Math.min(Math.max(0, r), 1), g = Math.min(Math.max(0, g), 1), b = Math.min(Math.max(0, b), 1), [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0], y = xyz[1], z = xyz[2];
      x /= 95.047, y /= 100, z /= 108.883, x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116, y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116, z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      let l = 116 * y - 16, a = 500 * (x - y), b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      let l = lab[0], a = lab[1], b = lab[2], x, y, z;
      y = (l + 16) / 116, x = a / 500 + y, z = y - b / 200;
      let y2 = y ** 3, x2 = x ** 3, z2 = z ** 3;
      return y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787, x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787, z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787, x *= 95.047, y *= 100, z *= 108.883, [x, y, z];
    };
    convert.lab.lch = function(lab) {
      let l = lab[0], a = lab[1], b = lab[2], h;
      h = Math.atan2(b, a) * 360 / 2 / Math.PI, h < 0 && (h += 360);
      let c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      let l = lch[0], c = lch[1], hr = lch[2] / 360 * 2 * Math.PI, a = c * Math.cos(hr), b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      let [r, g, b] = args, value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      if (value = Math.round(value / 50), value === 0)
        return 30;
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      return value === 2 && (ansi += 60), ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      let r = args[0], g = args[1], b = args[2];
      return r === g && g === b ? r < 8 ? 16 : r > 248 ? 231 : Math.round((r - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7)
        return args > 50 && (color += 3.5), color = color / 10.5 * 255, [color, color, color];
      let mult = (~~(args > 50) + 1) * 0.5, r = (color & 1) * mult * 255, g = (color >> 1 & 1) * mult * 255, b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        let c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem, r = Math.floor(args / 36) / 5 * 255, g = Math.floor((rem = args % 36) / 6) / 5 * 255, b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      let string = (((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255)).toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      let match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match2)
        return [0, 0, 0];
      let colorString = match2[0];
      match2[0].length === 3 && (colorString = colorString.split("").map((char) => char + char).join(""));
      let integer = parseInt(colorString, 16), r = integer >> 16 & 255, g = integer >> 8 & 255, b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      let r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, max = Math.max(Math.max(r, g), b), min = Math.min(Math.min(r, g), b), chroma = max - min, grayscale, hue;
      return chroma < 1 ? grayscale = min / (1 - chroma) : grayscale = 0, chroma <= 0 ? hue = 0 : max === r ? hue = (g - b) / chroma % 6 : max === g ? hue = 2 + (b - r) / chroma : hue = 4 + (r - g) / chroma, hue /= 6, hue %= 1, [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      let s = hsl[1] / 100, l = hsl[2] / 100, c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l), f = 0;
      return c < 1 && (f = (l - 0.5 * c) / (1 - c)), [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      let s = hsv[1] / 100, v = hsv[2] / 100, c = s * v, f = 0;
      return c < 1 && (f = (v - c) / (1 - c)), [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      let h = hcg[0] / 360, c = hcg[1] / 100, g = hcg[2] / 100;
      if (c === 0)
        return [g * 255, g * 255, g * 255];
      let pure = [0, 0, 0], hi = h % 1 * 6, v = hi % 1, w = 1 - v, mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1, pure[1] = v, pure[2] = 0;
          break;
        case 1:
          pure[0] = w, pure[1] = 1, pure[2] = 0;
          break;
        case 2:
          pure[0] = 0, pure[1] = 1, pure[2] = v;
          break;
        case 3:
          pure[0] = 0, pure[1] = w, pure[2] = 1;
          break;
        case 4:
          pure[0] = v, pure[1] = 0, pure[2] = 1;
          break;
        default:
          pure[0] = 1, pure[1] = 0, pure[2] = w;
      }
      return mg = (1 - c) * g, [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      let c = hcg[1] / 100, g = hcg[2] / 100, v = c + g * (1 - c), f = 0;
      return v > 0 && (f = c / v), [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      let c = hcg[1] / 100, l = hcg[2] / 100 * (1 - c) + 0.5 * c, s = 0;
      return l > 0 && l < 0.5 ? s = c / (2 * l) : l >= 0.5 && l < 1 && (s = c / (2 * (1 - l))), [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      let c = hcg[1] / 100, g = hcg[2] / 100, v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      let w = hwb[1] / 100, v = 1 - hwb[2] / 100, c = v - w, g = 0;
      return c < 1 && (g = (v - c) / (1 - c)), [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      let val = Math.round(gray[0] / 100 * 255) & 255, string = ((val << 16) + (val << 8) + val).toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      return [(rgb[0] + rgb[1] + rgb[2]) / 3 / 255 * 100];
    };
  }
});

// ../../node_modules/color-convert/route.js
var require_route = __commonJS({
  "../../node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      let graph = {}, models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++)
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      return graph;
    }
    function deriveBFS(fromModel) {
      let graph = buildGraph(), queue = [fromModel];
      for (graph[fromModel].distance = 0; queue.length; ) {
        let current = queue.pop(), adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          let adjacent = adjacents[i], node = graph[adjacent];
          node.distance === -1 && (node.distance = graph[current].distance + 1, node.parent = current, queue.unshift(adjacent));
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      let path6 = [graph[toModel].parent, toModel], fn = conversions[graph[toModel].parent][toModel], cur = graph[toModel].parent;
      for (; graph[cur].parent; )
        path6.unshift(graph[cur].parent), fn = link(conversions[graph[cur].parent][cur], fn), cur = graph[cur].parent;
      return fn.conversion = path6, fn;
    }
    module2.exports = function(fromModel) {
      let graph = deriveBFS(fromModel), conversion = {}, models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        let toModel = models[i];
        graph[toModel].parent !== null && (conversion[toModel] = wrapConversion(toModel, graph));
      }
      return conversion;
    };
  }
});

// ../../node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "../../node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions(), route = require_route(), convert = {}, models = Object.keys(conversions);
    function wrapRaw(fn) {
      let wrappedFn = function(...args) {
        let arg0 = args[0];
        return arg0 == null ? arg0 : (arg0.length > 1 && (args = arg0), fn(args));
      };
      return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
    }
    function wrapRounded(fn) {
      let wrappedFn = function(...args) {
        let arg0 = args[0];
        if (arg0 == null)
          return arg0;
        arg0.length > 1 && (args = arg0);
        let result = fn(args);
        if (typeof result == "object")
          for (let len = result.length, i = 0; i < len; i++)
            result[i] = Math.round(result[i]);
        return result;
      };
      return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {}, Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels }), Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      let routes = route(fromModel);
      Object.keys(routes).forEach((toModel) => {
        let fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn), convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// ../../node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "../../node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi162 = (fn, offset) => (...args) => `\x1B[${fn(...args) + offset}m`, wrapAnsi2562 = (fn, offset) => (...args) => {
      let code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    }, wrapAnsi16m2 = (fn, offset) => (...args) => {
      let rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    }, ansi2ansi = (n) => n, rgb2rgb = (r, g, b) => [r, g, b], setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          let value = get();
          return Object.defineProperty(object, property, {
            value,
            enumerable: !0,
            configurable: !0
          }), value;
        },
        enumerable: !0,
        configurable: !0
      });
    }, colorConvert, makeDynamicStyles = (wrap2, targetSpace, identity, isBackground) => {
      colorConvert === void 0 && (colorConvert = require_color_convert());
      let offset = isBackground ? 10 : 0, styles3 = {};
      for (let [sourceSpace, suite] of Object.entries(colorConvert)) {
        let name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        sourceSpace === targetSpace ? styles3[name] = wrap2(identity, offset) : typeof suite == "object" && (styles3[name] = wrap2(suite[targetSpace], offset));
      }
      return styles3;
    };
    function assembleStyles2() {
      let codes2 = /* @__PURE__ */ new Map(), styles3 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles3.color.gray = styles3.color.blackBright, styles3.bgColor.bgGray = styles3.bgColor.bgBlackBright, styles3.color.grey = styles3.color.blackBright, styles3.bgColor.bgGrey = styles3.bgColor.bgBlackBright;
      for (let [groupName, group] of Object.entries(styles3)) {
        for (let [styleName, style] of Object.entries(group))
          styles3[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          }, group[styleName] = styles3[styleName], codes2.set(style[0], style[1]);
        Object.defineProperty(styles3, groupName, {
          value: group,
          enumerable: !1
        });
      }
      return Object.defineProperty(styles3, "codes", {
        value: codes2,
        enumerable: !1
      }), styles3.color.close = "\x1B[39m", styles3.bgColor.close = "\x1B[49m", setLazyProperty(styles3.color, "ansi", () => makeDynamicStyles(wrapAnsi162, "ansi16", ansi2ansi, !1)), setLazyProperty(styles3.color, "ansi256", () => makeDynamicStyles(wrapAnsi2562, "ansi256", ansi2ansi, !1)), setLazyProperty(styles3.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m2, "rgb", rgb2rgb, !1)), setLazyProperty(styles3.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi162, "ansi16", ansi2ansi, !0)), setLazyProperty(styles3.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi2562, "ansi256", ansi2ansi, !0)), setLazyProperty(styles3.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m2, "rgb", rgb2rgb, !0)), styles3;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: !0,
      get: assembleStyles2
    });
  }
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv2 = process.argv) => {
      let prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--", position = argv2.indexOf(prefix + flag), terminatorPosition = argv2.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os2 = require("os"), tty2 = require("tty"), hasFlag2 = require_has_flag(), { env: env2 } = process, forceColor;
    hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never") ? forceColor = 0 : (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) && (forceColor = 1);
    "FORCE_COLOR" in env2 && (env2.FORCE_COLOR === "true" ? forceColor = 1 : env2.FORCE_COLOR === "false" ? forceColor = 0 : forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3));
    function translateLevel2(level) {
      return level === 0 ? !1 : {
        level,
        hasBasic: !0,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor2(haveStream, streamIsTTY) {
      if (forceColor === 0)
        return 0;
      if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor"))
        return 3;
      if (hasFlag2("color=256"))
        return 2;
      if (haveStream && !streamIsTTY && forceColor === void 0)
        return 0;
      let min = forceColor || 0;
      if (env2.TERM === "dumb")
        return min;
      if (process.platform === "win32") {
        let osRelease = os2.release().split(".");
        return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in env2)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship" ? 1 : min;
      if ("TEAMCITY_VERSION" in env2)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      if (env2.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in env2) {
        let version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(env2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM) || "COLORTERM" in env2 ? 1 : min;
    }
    function getSupportLevel(stream2) {
      let level = supportsColor2(stream2, stream2 && stream2.isTTY);
      return translateLevel2(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel2(supportsColor2(!0, tty2.isatty(1))),
      stderr: translateLevel2(supportsColor2(!0, tty2.isatty(2)))
    };
  }
});

// ../../node_modules/chalk/source/util.js
var require_util = __commonJS({
  "../../node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll2 = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1)
        return string;
      let substringLength = substring.length, endIndex = 0, returnValue = "";
      do
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer, endIndex = index + substringLength, index = string.indexOf(substring, endIndex);
      while (index !== -1);
      return returnValue += string.substr(endIndex), returnValue;
    }, stringEncaseCRLFWithFirstIndex2 = (string, prefix, postfix, index) => {
      let endIndex = 0, returnValue = "";
      do {
        let gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? `\r
` : `
`) + postfix, endIndex = index + 1, index = string.indexOf(`
`, endIndex);
      } while (index !== -1);
      return returnValue += string.substr(endIndex), returnValue;
    };
    module2.exports = {
      stringReplaceAll: stringReplaceAll2,
      stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex2
    };
  }
});

// ../../node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "../../node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, ESCAPES = /* @__PURE__ */ new Map([
      ["n", `
`],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c) {
      let u = c[0] === "u", bracket = c[1] === "{";
      return u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3 ? String.fromCharCode(parseInt(c.slice(1), 16)) : u && bracket ? String.fromCodePoint(parseInt(c.slice(2, -1), 16)) : ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      let results = [], chunks = arguments_.trim().split(/\s*,\s*/g), matches;
      for (let chunk of chunks) {
        let number = Number(chunk);
        if (!Number.isNaN(number))
          results.push(number);
        else if (matches = chunk.match(STRING_REGEX))
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape2(escape2) : character));
        else
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      let results = [], matches;
      for (; (matches = STYLE_REGEX.exec(style)) !== null; ) {
        let name = matches[1];
        if (matches[2]) {
          let args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else
          results.push([name]);
      }
      return results;
    }
    function buildStyle(chalk12, styles3) {
      let enabled = {};
      for (let layer of styles3)
        for (let style of layer.styles)
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
      let current = chalk12;
      for (let [styleName, styles4] of Object.entries(enabled))
        if (Array.isArray(styles4)) {
          if (!(styleName in current))
            throw new Error(`Unknown Chalk style: ${styleName}`);
          current = styles4.length > 0 ? current[styleName](...styles4) : current[styleName];
        }
      return current;
    }
    module2.exports = (chalk12, temporary) => {
      let styles3 = [], chunks = [], chunk = [];
      if (temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter)
          chunk.push(unescape2(escapeCharacter));
        else if (style) {
          let string = chunk.join("");
          chunk = [], chunks.push(styles3.length === 0 ? string : buildStyle(chalk12, styles3)(string)), styles3.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles3.length === 0)
            throw new Error("Found extraneous } in Chalk template literal");
          chunks.push(buildStyle(chalk12, styles3)(chunk.join(""))), chunk = [], styles3.pop();
        } else
          chunk.push(character);
      }), chunks.push(chunk.join("")), styles3.length > 0) {
        let errMessage = `Chalk template literal is missing ${styles3.length} closing bracket${styles3.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// ../../node_modules/chalk/source/index.js
var require_source = __commonJS({
  "../../node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles2 = require_ansi_styles(), { stdout: stdoutColor2, stderr: stderrColor2 } = require_supports_color(), {
      stringReplaceAll: stringReplaceAll2,
      stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex2
    } = require_util(), { isArray } = Array, levelMapping2 = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ], styles3 = /* @__PURE__ */ Object.create(null), applyOptions2 = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3))
        throw new Error("The `level` option should be an integer from 0 to 3");
      let colorLevel = stdoutColor2 ? stdoutColor2.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    }, ChalkClass = class {
      constructor(options) {
        return chalkFactory2(options);
      }
    }, chalkFactory2 = (options) => {
      let chalk13 = {};
      return applyOptions2(chalk13, options), chalk13.template = (...arguments_) => chalkTag(chalk13.template, ...arguments_), Object.setPrototypeOf(chalk13, Chalk.prototype), Object.setPrototypeOf(chalk13.template, chalk13), chalk13.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      }, chalk13.template.Instance = ChalkClass, chalk13.template;
    };
    function Chalk(options) {
      return chalkFactory2(options);
    }
    for (let [styleName, style] of Object.entries(ansiStyles2))
      styles3[styleName] = {
        get() {
          let builder = createBuilder2(this, createStyler2(style.open, style.close, this._styler), this._isEmpty);
          return Object.defineProperty(this, styleName, { value: builder }), builder;
        }
      };
    styles3.visible = {
      get() {
        let builder = createBuilder2(this, this._styler, !0);
        return Object.defineProperty(this, "visible", { value: builder }), builder;
      }
    };
    var usedModels2 = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (let model of usedModels2)
      styles3[model] = {
        get() {
          let { level } = this;
          return function(...arguments_) {
            let styler = createStyler2(ansiStyles2.color[levelMapping2[level]][model](...arguments_), ansiStyles2.color.close, this._styler);
            return createBuilder2(this, styler, this._isEmpty);
          };
        }
      };
    for (let model of usedModels2) {
      let bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles3[bgModel] = {
        get() {
          let { level } = this;
          return function(...arguments_) {
            let styler = createStyler2(ansiStyles2.bgColor[levelMapping2[level]][model](...arguments_), ansiStyles2.bgColor.close, this._styler);
            return createBuilder2(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto2 = Object.defineProperties(() => {
    }, {
      ...styles3,
      level: {
        enumerable: !0,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    }), createStyler2 = (open3, close, parent) => {
      let openAll, closeAll;
      return parent === void 0 ? (openAll = open3, closeAll = close) : (openAll = parent.openAll + open3, closeAll = close + parent.closeAll), {
        open: open3,
        close,
        openAll,
        closeAll,
        parent
      };
    }, createBuilder2 = (self, _styler, _isEmpty) => {
      let builder = (...arguments_) => isArray(arguments_[0]) && isArray(arguments_[0].raw) ? applyStyle2(builder, chalkTag(builder, ...arguments_)) : applyStyle2(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      return Object.setPrototypeOf(builder, proto2), builder._generator = self, builder._styler = _styler, builder._isEmpty = _isEmpty, builder;
    }, applyStyle2 = (self, string) => {
      if (self.level <= 0 || !string)
        return self._isEmpty ? "" : string;
      let styler = self._styler;
      if (styler === void 0)
        return string;
      let { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1)
        for (; styler !== void 0; )
          string = stringReplaceAll2(string, styler.close, styler.open), styler = styler.parent;
      let lfIndex = string.indexOf(`
`);
      return lfIndex !== -1 && (string = stringEncaseCRLFWithFirstIndex2(string, closeAll, openAll, lfIndex)), openAll + string + closeAll;
    }, template, chalkTag = (chalk13, ...strings) => {
      let [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw))
        return strings.join(" ");
      let arguments_ = strings.slice(1), parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++)
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      return template === void 0 && (template = require_templates()), template(chalk13, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles3);
    var chalk12 = Chalk();
    chalk12.supportsColor = stdoutColor2;
    chalk12.stderr = Chalk({ level: stderrColor2 ? stderrColor2.level : 0 });
    chalk12.stderr.supportsColor = stderrColor2;
    module2.exports = chalk12;
  }
});

// ../../node_modules/commander/index.js
var require_commander = __commonJS({
  "../../node_modules/commander/index.js"(exports2, module2) {
    var EventEmitter3 = require("events").EventEmitter, spawn2 = require("child_process").spawn, path6 = require("path"), dirname = path6.dirname, basename2 = path6.basename, fs7 = require("fs");
    require("util").inherits(Command, EventEmitter3);
    exports2 = module2.exports = new Command();
    exports2.Command = Command;
    exports2.Option = Option;
    function Option(flags, description) {
      this.flags = flags, this.required = flags.indexOf("<") >= 0, this.optional = flags.indexOf("[") >= 0, this.bool = flags.indexOf("-no-") === -1, flags = flags.split(/[ ,|]+/), flags.length > 1 && !/^[[<]/.test(flags[1]) && (this.short = flags.shift()), this.long = flags.shift(), this.description = description || "";
    }
    Option.prototype.name = function() {
      return this.long.replace("--", "").replace("no-", "");
    };
    Option.prototype.attributeName = function() {
      return camelcase(this.name());
    };
    Option.prototype.is = function(arg) {
      return this.short === arg || this.long === arg;
    };
    function Command(name) {
      this.commands = [], this.options = [], this._execs = {}, this._allowUnknownOption = !1, this._args = [], this._name = name || "";
    }
    Command.prototype.command = function(name, desc, opts) {
      typeof desc == "object" && desc !== null && (opts = desc, desc = null), opts = opts || {};
      var args = name.split(/ +/), cmd = new Command(args.shift());
      return desc && (cmd.description(desc), this.executables = !0, this._execs[cmd._name] = !0, opts.isDefault && (this.defaultExecutable = cmd._name)), cmd._noHelp = !!opts.noHelp, this.commands.push(cmd), cmd.parseExpectedArgs(args), cmd.parent = this, desc ? this : cmd;
    };
    Command.prototype.arguments = function(desc) {
      return this.parseExpectedArgs(desc.split(/ +/));
    };
    Command.prototype.addImplicitHelpCommand = function() {
      this.command("help [cmd]", "display help for [cmd]");
    };
    Command.prototype.parseExpectedArgs = function(args) {
      if (args.length) {
        var self = this;
        return args.forEach(function(arg) {
          var argDetails = {
            required: !1,
            name: "",
            variadic: !1
          };
          switch (arg[0]) {
            case "<":
              argDetails.required = !0, argDetails.name = arg.slice(1, -1);
              break;
            case "[":
              argDetails.name = arg.slice(1, -1);
              break;
          }
          argDetails.name.length > 3 && argDetails.name.slice(-3) === "..." && (argDetails.variadic = !0, argDetails.name = argDetails.name.slice(0, -3)), argDetails.name && self._args.push(argDetails);
        }), this;
      }
    };
    Command.prototype.action = function(fn) {
      var self = this, listener = function(args, unknown) {
        args = args || [], unknown = unknown || [];
        var parsed = self.parseOptions(unknown);
        outputHelpIfNecessary(self, parsed.unknown), parsed.unknown.length > 0 && self.unknownOption(parsed.unknown[0]), parsed.args.length && (args = parsed.args.concat(args)), self._args.forEach(function(arg, i) {
          arg.required && args[i] == null ? self.missingArgument(arg.name) : arg.variadic && (i !== self._args.length - 1 && self.variadicArgNotLast(arg.name), args[i] = args.splice(i));
        }), self._args.length ? args[self._args.length] = self : args.push(self), fn.apply(self, args);
      }, parent = this.parent || this, name = parent === this ? "*" : this._name;
      return parent.on("command:" + name, listener), this._alias && parent.on("command:" + this._alias, listener), this;
    };
    Command.prototype.option = function(flags, description, fn, defaultValue) {
      var self = this, option = new Option(flags, description), oname = option.name(), name = option.attributeName();
      if (typeof fn != "function")
        if (fn instanceof RegExp) {
          var regex = fn;
          fn = function(val, def) {
            var m = regex.exec(val);
            return m ? m[0] : def;
          };
        } else
          defaultValue = fn, fn = null;
      return (!option.bool || option.optional || option.required) && (option.bool || (defaultValue = !0), defaultValue !== void 0 && (self[name] = defaultValue, option.defaultValue = defaultValue)), this.options.push(option), this.on("option:" + oname, function(val) {
        val !== null && fn && (val = fn(val, self[name] === void 0 ? defaultValue : self[name])), typeof self[name] == "boolean" || typeof self[name] > "u" ? val == null ? self[name] = option.bool ? defaultValue || !0 : !1 : self[name] = val : val !== null && (self[name] = val);
      }), this;
    };
    Command.prototype.allowUnknownOption = function(arg) {
      return this._allowUnknownOption = arguments.length === 0 || arg, this;
    };
    Command.prototype.parse = function(argv2) {
      this.executables && this.addImplicitHelpCommand(), this.rawArgs = argv2, this._name = this._name || basename2(argv2[1], ".js"), this.executables && argv2.length < 3 && !this.defaultExecutable && argv2.push("--help");
      var parsed = this.parseOptions(this.normalize(argv2.slice(2))), args = this.args = parsed.args, result = this.parseArgs(this.args, parsed.unknown), name = result.args[0], aliasCommand = null;
      return name && (aliasCommand = this.commands.filter(function(command) {
        return command.alias() === name;
      })[0]), this._execs[name] && typeof this._execs[name] != "function" ? this.executeSubCommand(argv2, args, parsed.unknown) : aliasCommand ? (args[0] = aliasCommand._name, this.executeSubCommand(argv2, args, parsed.unknown)) : this.defaultExecutable ? (args.unshift(this.defaultExecutable), this.executeSubCommand(argv2, args, parsed.unknown)) : result;
    };
    Command.prototype.executeSubCommand = function(argv2, args, unknown) {
      args = args.concat(unknown), args.length || this.help(), args[0] === "help" && args.length === 1 && this.help(), args[0] === "help" && (args[0] = args[1], args[1] = "--help");
      var f = argv2[1], bin = basename2(f, path6.extname(f)) + "-" + args[0], baseDir, resolvedLink = fs7.realpathSync(f);
      baseDir = dirname(resolvedLink);
      var localBin = path6.join(baseDir, bin), isExplicitJS = !1;
      exists(localBin + ".js") ? (bin = localBin + ".js", isExplicitJS = !0) : exists(localBin + ".ts") ? (bin = localBin + ".ts", isExplicitJS = !0) : exists(localBin) && (bin = localBin), args = args.slice(1);
      var proc3;
      process.platform !== "win32" ? isExplicitJS ? (args.unshift(bin), args = (process.execArgv || []).concat(args), proc3 = spawn2(process.argv[0], args, { stdio: "inherit", customFds: [0, 1, 2] })) : proc3 = spawn2(bin, args, { stdio: "inherit", customFds: [0, 1, 2] }) : (args.unshift(bin), proc3 = spawn2(process.execPath, args, { stdio: "inherit" }));
      var signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
      signals.forEach(function(signal) {
        process.on(signal, function() {
          proc3.killed === !1 && proc3.exitCode === null && proc3.kill(signal);
        });
      }), proc3.on("close", process.exit.bind(process)), proc3.on("error", function(err) {
        err.code === "ENOENT" ? console.error("error: %s(1) does not exist, try --help", bin) : err.code === "EACCES" && console.error("error: %s(1) not executable. try chmod or run with root", bin), process.exit(1);
      }), this.runningCommand = proc3;
    };
    Command.prototype.normalize = function(args) {
      for (var ret = [], arg, lastOpt, index, i = 0, len = args.length; i < len; ++i)
        if (arg = args[i], i > 0 && (lastOpt = this.optionFor(args[i - 1])), arg === "--") {
          ret = ret.concat(args.slice(i));
          break;
        } else
          lastOpt && lastOpt.required ? ret.push(arg) : arg.length > 1 && arg[0] === "-" && arg[1] !== "-" ? arg.slice(1).split("").forEach(function(c) {
            ret.push("-" + c);
          }) : /^--/.test(arg) && ~(index = arg.indexOf("=")) ? ret.push(arg.slice(0, index), arg.slice(index + 1)) : ret.push(arg);
      return ret;
    };
    Command.prototype.parseArgs = function(args, unknown) {
      var name;
      return args.length ? (name = args[0], this.listeners("command:" + name).length ? this.emit("command:" + args.shift(), args, unknown) : this.emit("command:*", args)) : (outputHelpIfNecessary(this, unknown), unknown.length > 0 && this.unknownOption(unknown[0]), this.commands.length === 0 && this._args.filter(function(a) {
        return a.required;
      }).length === 0 && this.emit("command:*")), this;
    };
    Command.prototype.optionFor = function(arg) {
      for (var i = 0, len = this.options.length; i < len; ++i)
        if (this.options[i].is(arg))
          return this.options[i];
    };
    Command.prototype.parseOptions = function(argv2) {
      for (var args = [], len = argv2.length, literal, option, arg, unknownOptions = [], i = 0; i < len; ++i) {
        if (arg = argv2[i], literal) {
          args.push(arg);
          continue;
        }
        if (arg === "--") {
          literal = !0;
          continue;
        }
        if (option = this.optionFor(arg), option) {
          if (option.required) {
            if (arg = argv2[++i], arg == null)
              return this.optionMissingArgument(option);
            this.emit("option:" + option.name(), arg);
          } else
            option.optional ? (arg = argv2[i + 1], arg == null || arg[0] === "-" && arg !== "-" ? arg = null : ++i, this.emit("option:" + option.name(), arg)) : this.emit("option:" + option.name());
          continue;
        }
        if (arg.length > 1 && arg[0] === "-") {
          unknownOptions.push(arg), i + 1 < argv2.length && argv2[i + 1][0] !== "-" && unknownOptions.push(argv2[++i]);
          continue;
        }
        args.push(arg);
      }
      return { args, unknown: unknownOptions };
    };
    Command.prototype.opts = function() {
      for (var result = {}, len = this.options.length, i = 0; i < len; i++) {
        var key = this.options[i].attributeName();
        result[key] = key === this._versionOptionName ? this._version : this[key];
      }
      return result;
    };
    Command.prototype.missingArgument = function(name) {
      console.error("error: missing required argument `%s'", name), process.exit(1);
    };
    Command.prototype.optionMissingArgument = function(option, flag) {
      flag ? console.error("error: option `%s' argument missing, got `%s'", option.flags, flag) : console.error("error: option `%s' argument missing", option.flags), process.exit(1);
    };
    Command.prototype.unknownOption = function(flag) {
      this._allowUnknownOption || (console.error("error: unknown option `%s'", flag), process.exit(1));
    };
    Command.prototype.variadicArgNotLast = function(name) {
      console.error("error: variadic arguments must be last `%s'", name), process.exit(1);
    };
    Command.prototype.version = function(str, flags) {
      if (arguments.length === 0)
        return this._version;
      this._version = str, flags = flags || "-V, --version";
      var versionOption = new Option(flags, "output the version number");
      return this._versionOptionName = versionOption.long.substr(2) || "version", this.options.push(versionOption), this.on("option:" + this._versionOptionName, function() {
        process.stdout.write(str + `
`), process.exit(0);
      }), this;
    };
    Command.prototype.description = function(str, argsDescription) {
      return arguments.length === 0 ? this._description : (this._description = str, this._argsDescription = argsDescription, this);
    };
    Command.prototype.alias = function(alias) {
      var command = this;
      if (this.commands.length !== 0 && (command = this.commands[this.commands.length - 1]), arguments.length === 0)
        return command._alias;
      if (alias === command._name)
        throw new Error("Command alias can't be the same as its name");
      return command._alias = alias, this;
    };
    Command.prototype.usage = function(str) {
      var args = this._args.map(function(arg) {
        return humanReadableArgName(arg);
      }), usage = "[options]" + (this.commands.length ? " [command]" : "") + (this._args.length ? " " + args.join(" ") : "");
      return arguments.length === 0 ? this._usage || usage : (this._usage = str, this);
    };
    Command.prototype.name = function(str) {
      return arguments.length === 0 ? this._name : (this._name = str, this);
    };
    Command.prototype.prepareCommands = function() {
      return this.commands.filter(function(cmd) {
        return !cmd._noHelp;
      }).map(function(cmd) {
        var args = cmd._args.map(function(arg) {
          return humanReadableArgName(arg);
        }).join(" ");
        return [
          cmd._name + (cmd._alias ? "|" + cmd._alias : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : ""),
          cmd._description
        ];
      });
    };
    Command.prototype.largestCommandLength = function() {
      var commands = this.prepareCommands();
      return commands.reduce(function(max, command) {
        return Math.max(max, command[0].length);
      }, 0);
    };
    Command.prototype.largestOptionLength = function() {
      var options = [].slice.call(this.options);
      return options.push({
        flags: "-h, --help"
      }), options.reduce(function(max, option) {
        return Math.max(max, option.flags.length);
      }, 0);
    };
    Command.prototype.largestArgLength = function() {
      return this._args.reduce(function(max, arg) {
        return Math.max(max, arg.name.length);
      }, 0);
    };
    Command.prototype.padWidth = function() {
      var width = this.largestOptionLength();
      return this._argsDescription && this._args.length && this.largestArgLength() > width && (width = this.largestArgLength()), this.commands && this.commands.length && this.largestCommandLength() > width && (width = this.largestCommandLength()), width;
    };
    Command.prototype.optionHelp = function() {
      var width = this.padWidth();
      return this.options.map(function(option) {
        return pad(option.flags, width) + "  " + option.description + (option.bool && option.defaultValue !== void 0 ? " (default: " + JSON.stringify(option.defaultValue) + ")" : "");
      }).concat([pad("-h, --help", width) + "  output usage information"]).join(`
`);
    };
    Command.prototype.commandHelp = function() {
      if (!this.commands.length)
        return "";
      var commands = this.prepareCommands(), width = this.padWidth();
      return [
        "Commands:",
        commands.map(function(cmd) {
          var desc = cmd[1] ? "  " + cmd[1] : "";
          return (desc ? pad(cmd[0], width) : cmd[0]) + desc;
        }).join(`
`).replace(/^/gm, "  "),
        ""
      ].join(`
`);
    };
    Command.prototype.helpInformation = function() {
      var desc = [];
      if (this._description) {
        desc = [
          this._description,
          ""
        ];
        var argsDescription = this._argsDescription;
        if (argsDescription && this._args.length) {
          var width = this.padWidth();
          desc.push("Arguments:"), desc.push(""), this._args.forEach(function(arg) {
            desc.push("  " + pad(arg.name, width) + "  " + argsDescription[arg.name]);
          }), desc.push("");
        }
      }
      var cmdName = this._name;
      this._alias && (cmdName = cmdName + "|" + this._alias);
      var usage = [
        "Usage: " + cmdName + " " + this.usage(),
        ""
      ], cmds = [], commandHelp = this.commandHelp();
      commandHelp && (cmds = [commandHelp]);
      var options = [
        "Options:",
        "" + this.optionHelp().replace(/^/gm, "  "),
        ""
      ];
      return usage.concat(desc).concat(options).concat(cmds).join(`
`);
    };
    Command.prototype.outputHelp = function(cb) {
      cb || (cb = function(passthru) {
        return passthru;
      }), process.stdout.write(cb(this.helpInformation())), this.emit("--help");
    };
    Command.prototype.help = function(cb) {
      this.outputHelp(cb), process.exit();
    };
    function camelcase(flag) {
      return flag.split("-").reduce(function(str, word) {
        return str + word[0].toUpperCase() + word.slice(1);
      });
    }
    function pad(str, width) {
      var len = Math.max(0, width - str.length);
      return str + Array(len + 1).join(" ");
    }
    function outputHelpIfNecessary(cmd, options) {
      options = options || [];
      for (var i = 0; i < options.length; i++)
        (options[i] === "--help" || options[i] === "-h") && (cmd.outputHelp(), process.exit(0));
    }
    function humanReadableArgName(arg) {
      var nameOutput = arg.name + (arg.variadic === !0 ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    function exists(file) {
      try {
        if (fs7.statSync(file).isFile())
          return !0;
      } catch {
        return !1;
      }
    }
  }
});

// ../../node_modules/isexe/windows.js
var require_windows = __commonJS({
  "../../node_modules/isexe/windows.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync2;
    var fs7 = require("fs");
    function checkPathExt(path6, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext || (pathext = pathext.split(";"), pathext.indexOf("") !== -1))
        return !0;
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path6.substr(-p.length).toLowerCase() === p)
          return !0;
      }
      return !1;
    }
    function checkStat(stat3, path6, options) {
      return !stat3.isSymbolicLink() && !stat3.isFile() ? !1 : checkPathExt(path6, options);
    }
    function isexe(path6, options, cb) {
      fs7.stat(path6, function(er, stat3) {
        cb(er, er ? !1 : checkStat(stat3, path6, options));
      });
    }
    function sync2(path6, options) {
      return checkStat(fs7.statSync(path6), path6, options);
    }
  }
});

// ../../node_modules/isexe/mode.js
var require_mode = __commonJS({
  "../../node_modules/isexe/mode.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync2;
    var fs7 = require("fs");
    function isexe(path6, options, cb) {
      fs7.stat(path6, function(er, stat3) {
        cb(er, er ? !1 : checkStat(stat3, options));
      });
    }
    function sync2(path6, options) {
      return checkStat(fs7.statSync(path6), options);
    }
    function checkStat(stat3, options) {
      return stat3.isFile() && checkMode(stat3, options);
    }
    function checkMode(stat3, options) {
      var mod = stat3.mode, uid = stat3.uid, gid = stat3.gid, myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid(), myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid(), u = parseInt("100", 8), g = parseInt("010", 8), o = parseInt("001", 8), ug = u | g, ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// ../../node_modules/isexe/index.js
var require_isexe = __commonJS({
  "../../node_modules/isexe/index.js"(exports2, module2) {
    var fs7 = require("fs"), core;
    process.platform === "win32" || global.TESTING_WINDOWS ? core = require_windows() : core = require_mode();
    module2.exports = isexe;
    isexe.sync = sync2;
    function isexe(path6, options, cb) {
      if (typeof options == "function" && (cb = options, options = {}), !cb) {
        if (typeof Promise != "function")
          throw new TypeError("callback not provided");
        return new Promise(function(resolve7, reject) {
          isexe(path6, options || {}, function(er, is) {
            er ? reject(er) : resolve7(is);
          });
        });
      }
      core(path6, options || {}, function(er, is) {
        er && (er.code === "EACCES" || options && options.ignoreErrors) && (er = null, is = !1), cb(er, is);
      });
    }
    function sync2(path6, options) {
      try {
        return core.sync(path6, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES")
          return !1;
        throw er;
      }
    }
  }
});

// ../../node_modules/execa/node_modules/which/which.js
var require_which = __commonJS({
  "../../node_modules/execa/node_modules/which/which.js"(exports2, module2) {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", path6 = require("path"), COLON = isWindows ? ";" : ":", isexe = require_isexe(), getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" }), getPathInfo = (cmd, opt) => {
      let colon = opt.colon || COLON, pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ], pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", pathExt = isWindows ? pathExtExe.split(colon) : [""];
      return isWindows && cmd.indexOf(".") !== -1 && pathExt[0] !== "" && pathExt.unshift(""), {
        pathEnv,
        pathExt,
        pathExtExe
      };
    }, which2 = (cmd, opt, cb) => {
      typeof opt == "function" && (cb = opt, opt = {}), opt || (opt = {});
      let { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [], step = (i) => new Promise((resolve7, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve7(found) : reject(getNotFoundError(cmd));
        let ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path6.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve7(subStep(p, i, 0));
      }), subStep = (p, i, ii) => new Promise((resolve7, reject) => {
        if (ii === pathExt.length)
          return resolve7(step(i + 1));
        let ext2 = pathExt[ii];
        isexe(p + ext2, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is)
            if (opt.all)
              found.push(p + ext2);
            else
              return resolve7(p + ext2);
          return resolve7(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    }, whichSync = (cmd, opt) => {
      opt = opt || {};
      let { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        let ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path6.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          let cur = p + pathExt[j];
          try {
            if (isexe.sync(cur, { pathExt: pathExtExe }))
              if (opt.all)
                found.push(cur);
              else
                return cur;
          } catch {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// ../../node_modules/execa/node_modules/path-key/index.js
var require_path_key = __commonJS({
  "../../node_modules/execa/node_modules/path-key/index.js"(exports2, module2) {
    "use strict";
    var pathKey = (options = {}) => {
      let environment = options.env || process.env;
      return (options.platform || process.platform) !== "win32" ? "PATH" : Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey;
    module2.exports.default = pathKey;
  }
});

// ../../node_modules/execa/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "../../node_modules/execa/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), which2 = require_which(), getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      let env2 = parsed.options.env || process.env, cwd2 = process.cwd(), hasCustomCwd = parsed.options.cwd != null, shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd)
        try {
          process.chdir(parsed.options.cwd);
        } catch {
        }
      let resolved;
      try {
        resolved = which2.sync(parsed.command, {
          path: env2[getPathKey({ env: env2 })],
          pathExt: withoutPathExt ? path6.delimiter : void 0
        });
      } catch {
      } finally {
        shouldSwitchCwd && process.chdir(cwd2);
      }
      return resolved && (resolved = path6.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved)), resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, !0);
    }
    module2.exports = resolveCommand;
  }
});

// ../../node_modules/execa/node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "../../node_modules/execa/node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      return arg = arg.replace(metaCharsRegExp, "^$1"), arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      return arg = `${arg}`, arg = arg.replace(/(\\*)"/g, '$1$1\\"'), arg = arg.replace(/(\\*)$/, "$1$1"), arg = `"${arg}"`, arg = arg.replace(metaCharsRegExp, "^$1"), doubleEscapeMetaChars && (arg = arg.replace(metaCharsRegExp, "^$1")), arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// ../../node_modules/execa/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "../../node_modules/execa/node_modules/shebang-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /^#!(.*)/;
  }
});

// ../../node_modules/execa/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "../../node_modules/execa/node_modules/shebang-command/index.js"(exports2, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = (string = "") => {
      let match2 = string.match(shebangRegex);
      if (!match2)
        return null;
      let [path6, argument] = match2[0].replace(/#! ?/, "").split(" "), binary = path6.split("/").pop();
      return binary === "env" ? argument : argument ? `${binary} ${argument}` : binary;
    };
  }
});

// ../../node_modules/execa/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "../../node_modules/execa/node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
    "use strict";
    var fs7 = require("fs"), shebangCommand = require_shebang_command();
    function readShebang(command) {
      let buffer = Buffer.alloc(150), fd;
      try {
        fd = fs7.openSync(command, "r"), fs7.readSync(fd, buffer, 0, 150, 0), fs7.closeSync(fd);
      } catch {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});

// ../../node_modules/execa/node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/execa/node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), resolveCommand = require_resolveCommand(), escape2 = require_escape(), readShebang = require_readShebang(), isWin = process.platform === "win32", isExecutableRegExp = /\.(?:com|exe)$/i, isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      let shebang = parsed.file && readShebang(parsed.file);
      return shebang ? (parsed.args.unshift(parsed.file), parsed.command = shebang, resolveCommand(parsed)) : parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin)
        return parsed;
      let commandFile = detectShebang(parsed), needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        let needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path6.normalize(parsed.command), parsed.command = escape2.command(parsed.command), parsed.args = parsed.args.map((arg) => escape2.argument(arg, needsDoubleEscapeMetaChars));
        let shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`], parsed.command = process.env.comspec || "cmd.exe", parsed.options.windowsVerbatimArguments = !0;
      }
      return parsed;
    }
    function parse6(command, args, options) {
      args && !Array.isArray(args) && (options = args, args = null), args = args ? args.slice(0) : [], options = Object.assign({}, options);
      let parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse6;
  }
});

// ../../node_modules/execa/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "../../node_modules/execa/node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin)
        return;
      let originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          let err = verifyENOENT(arg1, parsed, "spawn");
          if (err)
            return originalEmit.call(cp, "error", err);
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawn") : null;
    }
    function verifyENOENTSync(status, parsed) {
      return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawnSync") : null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// ../../node_modules/execa/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "../../node_modules/execa/node_modules/cross-spawn/index.js"(exports2, module2) {
    "use strict";
    var cp = require("child_process"), parse6 = require_parse(), enoent = require_enoent();
    function spawn2(command, args, options) {
      let parsed = parse6(command, args, options), spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      return enoent.hookChildProcess(spawned, parsed), spawned;
    }
    function spawnSync(command, args, options) {
      let parsed = parse6(command, args, options), result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      return result.error = result.error || enoent.verifyENOENTSync(result.status, parsed), result;
    }
    module2.exports = spawn2;
    module2.exports.spawn = spawn2;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse6;
    module2.exports._enoent = enoent;
  }
});

// ../../node_modules/strip-final-newline/index.js
var require_strip_final_newline = __commonJS({
  "../../node_modules/strip-final-newline/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (input) => {
      let LF = typeof input == "string" ? `
` : 10, CR = typeof input == "string" ? "\r" : 13;
      return input[input.length - 1] === LF && (input = input.slice(0, input.length - 1)), input[input.length - 1] === CR && (input = input.slice(0, input.length - 1)), input;
    };
  }
});

// ../../node_modules/npm-run-path/node_modules/path-key/index.js
var require_path_key2 = __commonJS({
  "../../node_modules/npm-run-path/node_modules/path-key/index.js"(exports2, module2) {
    "use strict";
    var pathKey = (options = {}) => {
      let environment = options.env || process.env;
      return (options.platform || process.platform) !== "win32" ? "PATH" : Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey;
    module2.exports.default = pathKey;
  }
});

// ../../node_modules/npm-run-path/index.js
var require_npm_run_path = __commonJS({
  "../../node_modules/npm-run-path/index.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), pathKey = require_path_key2(), npmRunPath = (options) => {
      options = {
        cwd: process.cwd(),
        path: process.env[pathKey()],
        execPath: process.execPath,
        ...options
      };
      let previous, cwdPath = path6.resolve(options.cwd), result = [];
      for (; previous !== cwdPath; )
        result.push(path6.join(cwdPath, "node_modules/.bin")), previous = cwdPath, cwdPath = path6.resolve(cwdPath, "..");
      let execPathDir = path6.resolve(options.cwd, options.execPath, "..");
      return result.push(execPathDir), result.concat(options.path).join(path6.delimiter);
    };
    module2.exports = npmRunPath;
    module2.exports.default = npmRunPath;
    module2.exports.env = (options) => {
      options = {
        env: process.env,
        ...options
      };
      let env2 = { ...options.env }, path7 = pathKey({ env: env2 });
      return options.path = env2[path7], env2[path7] = module2.exports(options), env2;
    };
  }
});

// ../../node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS({
  "../../node_modules/mimic-fn/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = (to, from) => {
      for (let prop of Reflect.ownKeys(from))
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
      return to;
    };
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  }
});

// ../../node_modules/onetime/index.js
var require_onetime = __commonJS({
  "../../node_modules/onetime/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = require_mimic_fn(), calledFunctions = /* @__PURE__ */ new WeakMap(), onetime = (function_, options = {}) => {
      if (typeof function_ != "function")
        throw new TypeError("Expected a function");
      let returnValue, callCount = 0, functionName = function_.displayName || function_.name || "<anonymous>", onetime2 = function(...arguments_) {
        if (calledFunctions.set(onetime2, ++callCount), callCount === 1)
          returnValue = function_.apply(this, arguments_), function_ = null;
        else if (options.throw === !0)
          throw new Error(`Function \`${functionName}\` can only be called once`);
        return returnValue;
      };
      return mimicFn(onetime2, function_), calledFunctions.set(onetime2, callCount), onetime2;
    };
    module2.exports = onetime;
    module2.exports.default = onetime;
    module2.exports.callCount = (function_) => {
      if (!calledFunctions.has(function_))
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      return calledFunctions.get(function_);
    };
  }
});

// ../../node_modules/execa/node_modules/human-signals/build/src/core.js
var require_core = __commonJS({
  "../../node_modules/execa/node_modules/human-signals/build/src/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.SIGNALS = void 0;
    var SIGNALS = [
      {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
      },
      {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
      },
      {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
      },
      {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
      },
      {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
      },
      {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
      },
      {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
      },
      {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
      },
      {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
      },
      {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
      },
      {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: !0
      },
      {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
      },
      {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
      },
      {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
      },
      {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
      },
      {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
      },
      {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
      },
      {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
      },
      {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: !0
      },
      {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: !0
      },
      {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
      },
      {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
      },
      {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
      },
      {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
      },
      {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
      },
      {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
      },
      {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
      },
      {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
      },
      {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
      },
      {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
      },
      {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
      },
      {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
      },
      {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
      },
      {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
      }
    ];
    exports2.SIGNALS = SIGNALS;
  }
});

// ../../node_modules/execa/node_modules/human-signals/build/src/realtime.js
var require_realtime = __commonJS({
  "../../node_modules/execa/node_modules/human-signals/build/src/realtime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
    var getRealtimeSignals = function() {
      let length = SIGRTMAX - SIGRTMIN + 1;
      return Array.from({ length }, getRealtimeSignal);
    };
    exports2.getRealtimeSignals = getRealtimeSignals;
    var getRealtimeSignal = function(value, index) {
      return {
        name: `SIGRT${index + 1}`,
        number: SIGRTMIN + index,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
      };
    }, SIGRTMIN = 34, SIGRTMAX = 64;
    exports2.SIGRTMAX = SIGRTMAX;
  }
});

// ../../node_modules/execa/node_modules/human-signals/build/src/signals.js
var require_signals = __commonJS({
  "../../node_modules/execa/node_modules/human-signals/build/src/signals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getSignals = void 0;
    var _os = require("os"), _core = require_core(), _realtime = require_realtime(), getSignals = function() {
      let realtimeSignals = (0, _realtime.getRealtimeSignals)();
      return [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
    };
    exports2.getSignals = getSignals;
    var normalizeSignal = function({
      name,
      number: defaultNumber,
      description,
      action,
      forced = !1,
      standard
    }) {
      let {
        signals: { [name]: constantSignal }
      } = _os.constants, supported = constantSignal !== void 0;
      return { name, number: supported ? constantSignal : defaultNumber, description, supported, action, forced, standard };
    };
  }
});

// ../../node_modules/execa/node_modules/human-signals/build/src/main.js
var require_main = __commonJS({
  "../../node_modules/execa/node_modules/human-signals/build/src/main.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.signalsByNumber = exports2.signalsByName = void 0;
    var _os = require("os"), _signals = require_signals(), _realtime = require_realtime(), getSignalsByName = function() {
      return (0, _signals.getSignals)().reduce(getSignalByName, {});
    }, getSignalByName = function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {
      return {
        ...signalByNameMemo,
        [name]: { name, number, description, supported, action, forced, standard }
      };
    }, signalsByName = getSignalsByName();
    exports2.signalsByName = signalsByName;
    var getSignalsByNumber = function() {
      let signals = (0, _signals.getSignals)(), length = _realtime.SIGRTMAX + 1, signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));
      return Object.assign({}, ...signalsA);
    }, getSignalByNumber = function(number, signals) {
      let signal = findSignalByNumber(number, signals);
      if (signal === void 0)
        return {};
      let { name, description, supported, action, forced, standard } = signal;
      return {
        [number]: {
          name,
          number,
          description,
          supported,
          action,
          forced,
          standard
        }
      };
    }, findSignalByNumber = function(number, signals) {
      let signal = signals.find(({ name }) => _os.constants.signals[name] === number);
      return signal !== void 0 ? signal : signals.find((signalA) => signalA.number === number);
    }, signalsByNumber = getSignalsByNumber();
    exports2.signalsByNumber = signalsByNumber;
  }
});

// ../../node_modules/execa/lib/error.js
var require_error = __commonJS({
  "../../node_modules/execa/lib/error.js"(exports2, module2) {
    "use strict";
    var { signalsByName } = require_main(), getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => timedOut ? `timed out after ${timeout} milliseconds` : isCanceled ? "was canceled" : errorCode !== void 0 ? `failed with ${errorCode}` : signal !== void 0 ? `was killed with ${signal} (${signalDescription})` : exitCode !== void 0 ? `failed with exit code ${exitCode}` : "failed", makeError = ({
      stdout,
      stderr,
      all,
      error,
      signal,
      exitCode,
      command,
      escapedCommand,
      timedOut,
      isCanceled,
      killed,
      parsed: { options: { timeout } }
    }) => {
      exitCode = exitCode === null ? void 0 : exitCode, signal = signal === null ? void 0 : signal;
      let signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description, errorCode = error && error.code, execaMessage = `Command ${getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled })}: ${command}`, isError = Object.prototype.toString.call(error) === "[object Error]", shortMessage = isError ? `${execaMessage}
${error.message}` : execaMessage, message = [shortMessage, stderr, stdout].filter(Boolean).join(`
`);
      return isError ? (error.originalMessage = error.message, error.message = message) : error = new Error(message), error.shortMessage = shortMessage, error.command = command, error.escapedCommand = escapedCommand, error.exitCode = exitCode, error.signal = signal, error.signalDescription = signalDescription, error.stdout = stdout, error.stderr = stderr, all !== void 0 && (error.all = all), "bufferedData" in error && delete error.bufferedData, error.failed = !0, error.timedOut = !!timedOut, error.isCanceled = isCanceled, error.killed = killed && !timedOut, error;
    };
    module2.exports = makeError;
  }
});

// ../../node_modules/execa/lib/stdio.js
var require_stdio = __commonJS({
  "../../node_modules/execa/lib/stdio.js"(exports2, module2) {
    "use strict";
    var aliases = ["stdin", "stdout", "stderr"], hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0), normalizeStdio = (options) => {
      if (!options)
        return;
      let { stdio } = options;
      if (stdio === void 0)
        return aliases.map((alias) => options[alias]);
      if (hasAlias(options))
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
      if (typeof stdio == "string")
        return stdio;
      if (!Array.isArray(stdio))
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      let length = Math.max(stdio.length, aliases.length);
      return Array.from({ length }, (value, index) => stdio[index]);
    };
    module2.exports = normalizeStdio;
    module2.exports.node = (options) => {
      let stdio = normalizeStdio(options);
      return stdio === "ipc" ? "ipc" : stdio === void 0 || typeof stdio == "string" ? [stdio, stdio, stdio, "ipc"] : stdio.includes("ipc") ? stdio : [...stdio, "ipc"];
    };
  }
});

// ../../node_modules/signal-exit/signals.js
var require_signals2 = __commonJS({
  "../../node_modules/signal-exit/signals.js"(exports2, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    process.platform !== "win32" && module2.exports.push(
      "SIGVTALRM",
      "SIGXCPU",
      "SIGXFSZ",
      "SIGUSR2",
      "SIGTRAP",
      "SIGSYS",
      "SIGQUIT",
      "SIGIOT"
      // should detect profiler and enable/disable accordingly.
      // see #21
      // 'SIGPROF'
    );
    process.platform === "linux" && module2.exports.push(
      "SIGIO",
      "SIGPOLL",
      "SIGPWR",
      "SIGSTKFLT",
      "SIGUNUSED"
    );
  }
});

// ../../node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "../../node_modules/signal-exit/index.js"(exports2, module2) {
    var process4 = global.process, processOk = function(process5) {
      return process5 && typeof process5 == "object" && typeof process5.removeListener == "function" && typeof process5.emit == "function" && typeof process5.reallyExit == "function" && typeof process5.listeners == "function" && typeof process5.kill == "function" && typeof process5.pid == "number" && typeof process5.on == "function";
    };
    processOk(process4) ? (assert2 = require("assert"), signals = require_signals2(), isWin = /^win/i.test(process4.platform), EE = require("events"), typeof EE != "function" && (EE = EE.EventEmitter), process4.__signal_exit_emitter__ ? emitter = process4.__signal_exit_emitter__ : (emitter = process4.__signal_exit_emitter__ = new EE(), emitter.count = 0, emitter.emitted = {}), emitter.infinite || (emitter.setMaxListeners(1 / 0), emitter.infinite = !0), module2.exports = function(cb, opts) {
      if (!processOk(global.process))
        return function() {
        };
      assert2.equal(typeof cb, "function", "a callback must be provided for exit handler"), loaded === !1 && load();
      var ev = "exit";
      opts && opts.alwaysLast && (ev = "afterexit");
      var remove2 = function() {
        emitter.removeListener(ev, cb), emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0 && unload();
      };
      return emitter.on(ev, cb), remove2;
    }, unload = function() {
      !loaded || !processOk(global.process) || (loaded = !1, signals.forEach(function(sig) {
        try {
          process4.removeListener(sig, sigListeners[sig]);
        } catch {
        }
      }), process4.emit = originalProcessEmit, process4.reallyExit = originalProcessReallyExit, emitter.count -= 1);
    }, module2.exports.unload = unload, emit = function(event, code, signal) {
      emitter.emitted[event] || (emitter.emitted[event] = !0, emitter.emit(event, code, signal));
    }, sigListeners = {}, signals.forEach(function(sig) {
      sigListeners[sig] = function() {
        if (processOk(global.process)) {
          var listeners = process4.listeners(sig);
          listeners.length === emitter.count && (unload(), emit("exit", null, sig), emit("afterexit", null, sig), isWin && sig === "SIGHUP" && (sig = "SIGINT"), process4.kill(process4.pid, sig));
        }
      };
    }), module2.exports.signals = function() {
      return signals;
    }, loaded = !1, load = function() {
      loaded || !processOk(global.process) || (loaded = !0, emitter.count += 1, signals = signals.filter(function(sig) {
        try {
          return process4.on(sig, sigListeners[sig]), !0;
        } catch {
          return !1;
        }
      }), process4.emit = processEmit, process4.reallyExit = processReallyExit);
    }, module2.exports.load = load, originalProcessReallyExit = process4.reallyExit, processReallyExit = function(code) {
      processOk(global.process) && (process4.exitCode = code || /* istanbul ignore next */
      0, emit("exit", process4.exitCode, null), emit("afterexit", process4.exitCode, null), originalProcessReallyExit.call(process4, process4.exitCode));
    }, originalProcessEmit = process4.emit, processEmit = function(ev, arg) {
      if (ev === "exit" && processOk(global.process)) {
        arg !== void 0 && (process4.exitCode = arg);
        var ret = originalProcessEmit.apply(this, arguments);
        return emit("exit", process4.exitCode, null), emit("afterexit", process4.exitCode, null), ret;
      } else
        return originalProcessEmit.apply(this, arguments);
    }) : module2.exports = function() {
      return function() {
      };
    };
    var assert2, signals, isWin, EE, emitter, unload, emit, sigListeners, loaded, load, originalProcessReallyExit, processReallyExit, originalProcessEmit, processEmit;
  }
});

// ../../node_modules/execa/lib/kill.js
var require_kill = __commonJS({
  "../../node_modules/execa/lib/kill.js"(exports2, module2) {
    "use strict";
    var os2 = require("os"), onExit = require_signal_exit(), DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5, spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
      let killResult = kill(signal);
      return setKillTimeout(kill, signal, options, killResult), killResult;
    }, setKillTimeout = (kill, signal, options, killResult) => {
      if (!shouldForceKill(signal, options, killResult))
        return;
      let timeout = getForceKillAfterTimeout(options), t = setTimeout(() => {
        kill("SIGKILL");
      }, timeout);
      t.unref && t.unref();
    }, shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => isSigterm(signal) && forceKillAfterTimeout !== !1 && killResult, isSigterm = (signal) => signal === os2.constants.signals.SIGTERM || typeof signal == "string" && signal.toUpperCase() === "SIGTERM", getForceKillAfterTimeout = ({ forceKillAfterTimeout = !0 }) => {
      if (forceKillAfterTimeout === !0)
        return DEFAULT_FORCE_KILL_TIMEOUT;
      if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0)
        throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
      return forceKillAfterTimeout;
    }, spawnedCancel = (spawned, context) => {
      spawned.kill() && (context.isCanceled = !0);
    }, timeoutKill = (spawned, signal, reject) => {
      spawned.kill(signal), reject(Object.assign(new Error("Timed out"), { timedOut: !0, signal }));
    }, setupTimeout = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
      if (timeout === 0 || timeout === void 0)
        return spawnedPromise;
      let timeoutId, timeoutPromise = new Promise((resolve7, reject) => {
        timeoutId = setTimeout(() => {
          timeoutKill(spawned, killSignal, reject);
        }, timeout);
      }), safeSpawnedPromise = spawnedPromise.finally(() => {
        clearTimeout(timeoutId);
      });
      return Promise.race([timeoutPromise, safeSpawnedPromise]);
    }, validateTimeout = ({ timeout }) => {
      if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0))
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
    }, setExitHandler = async (spawned, { cleanup, detached }, timedPromise) => {
      if (!cleanup || detached)
        return timedPromise;
      let removeExitHandler = onExit(() => {
        spawned.kill();
      });
      return timedPromise.finally(() => {
        removeExitHandler();
      });
    };
    module2.exports = {
      spawnedKill,
      spawnedCancel,
      setupTimeout,
      validateTimeout,
      setExitHandler
    };
  }
});

// ../../node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "../../node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream3 = (stream2) => stream2 !== null && typeof stream2 == "object" && typeof stream2.pipe == "function";
    isStream3.writable = (stream2) => isStream3(stream2) && stream2.writable !== !1 && typeof stream2._write == "function" && typeof stream2._writableState == "object";
    isStream3.readable = (stream2) => isStream3(stream2) && stream2.readable !== !1 && typeof stream2._read == "function" && typeof stream2._readableState == "object";
    isStream3.duplex = (stream2) => isStream3.writable(stream2) && isStream3.readable(stream2);
    isStream3.transform = (stream2) => isStream3.duplex(stream2) && typeof stream2._transform == "function";
    module2.exports = isStream3;
  }
});

// ../../node_modules/execa/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "../../node_modules/execa/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = require("stream");
    module2.exports = (options) => {
      options = { ...options };
      let { array } = options, { encoding } = options, isBuffer = encoding === "buffer", objectMode = !1;
      array ? objectMode = !(encoding || isBuffer) : encoding = encoding || "utf8", isBuffer && (encoding = null);
      let stream2 = new PassThroughStream({ objectMode });
      encoding && stream2.setEncoding(encoding);
      let length = 0, chunks = [];
      return stream2.on("data", (chunk) => {
        chunks.push(chunk), objectMode ? length = chunks.length : length += chunk.length;
      }), stream2.getBufferedValue = () => array ? chunks : isBuffer ? Buffer.concat(chunks, length) : chunks.join(""), stream2.getBufferedLength = () => length, stream2;
    };
  }
});

// ../../node_modules/execa/node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "../../node_modules/execa/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer"), stream2 = require("stream"), { promisify: promisify2 } = require("util"), bufferStream = require_buffer_stream(), streamPipelinePromisified = promisify2(stream2.pipeline), MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded"), this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options) {
      if (!inputStream)
        throw new Error("Expected a stream");
      options = {
        maxBuffer: 1 / 0,
        ...options
      };
      let { maxBuffer } = options, stream3 = bufferStream(options);
      return await new Promise((resolve7, reject) => {
        let rejectPromise = (error) => {
          error && stream3.getBufferedLength() <= BufferConstants.MAX_LENGTH && (error.bufferedData = stream3.getBufferedValue()), reject(error);
        };
        (async () => {
          try {
            await streamPipelinePromisified(inputStream, stream3), resolve7();
          } catch (error) {
            rejectPromise(error);
          }
        })(), stream3.on("data", () => {
          stream3.getBufferedLength() > maxBuffer && rejectPromise(new MaxBufferError());
        });
      }), stream3.getBufferedValue();
    }
    module2.exports = getStream;
    module2.exports.buffer = (stream3, options) => getStream(stream3, { ...options, encoding: "buffer" });
    module2.exports.array = (stream3, options) => getStream(stream3, { ...options, array: !0 });
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// ../../node_modules/merge-stream/index.js
var require_merge_stream = __commonJS({
  "../../node_modules/merge-stream/index.js"(exports2, module2) {
    "use strict";
    var { PassThrough } = require("stream");
    module2.exports = function() {
      var sources = [], output = new PassThrough({ objectMode: !0 });
      return output.setMaxListeners(0), output.add = add, output.isEmpty = isEmpty, output.on("unpipe", remove2), Array.prototype.slice.call(arguments).forEach(add), output;
      function add(source) {
        return Array.isArray(source) ? (source.forEach(add), this) : (sources.push(source), source.once("end", remove2.bind(null, source)), source.once("error", output.emit.bind(output, "error")), source.pipe(output, { end: !1 }), this);
      }
      function isEmpty() {
        return sources.length == 0;
      }
      function remove2(source) {
        sources = sources.filter(function(it) {
          return it !== source;
        }), !sources.length && output.readable && output.end();
      }
    };
  }
});

// ../../node_modules/execa/lib/stream.js
var require_stream = __commonJS({
  "../../node_modules/execa/lib/stream.js"(exports2, module2) {
    "use strict";
    var isStream3 = require_is_stream(), getStream = require_get_stream(), mergeStream = require_merge_stream(), handleInput = (spawned, input) => {
      input === void 0 || spawned.stdin === void 0 || (isStream3(input) ? input.pipe(spawned.stdin) : spawned.stdin.end(input));
    }, makeAllStream = (spawned, { all }) => {
      if (!all || !spawned.stdout && !spawned.stderr)
        return;
      let mixed = mergeStream();
      return spawned.stdout && mixed.add(spawned.stdout), spawned.stderr && mixed.add(spawned.stderr), mixed;
    }, getBufferedData = async (stream2, streamPromise) => {
      if (stream2) {
        stream2.destroy();
        try {
          return await streamPromise;
        } catch (error) {
          return error.bufferedData;
        }
      }
    }, getStreamPromise = (stream2, { encoding, buffer, maxBuffer }) => {
      if (!(!stream2 || !buffer))
        return encoding ? getStream(stream2, { encoding, maxBuffer }) : getStream.buffer(stream2, { maxBuffer });
    }, getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {
      let stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer }), stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer }), allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
      try {
        return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
      } catch (error) {
        return Promise.all([
          { error, signal: error.signal, timedOut: error.timedOut },
          getBufferedData(stdout, stdoutPromise),
          getBufferedData(stderr, stderrPromise),
          getBufferedData(all, allPromise)
        ]);
      }
    }, validateInputSync = ({ input }) => {
      if (isStream3(input))
        throw new TypeError("The `input` option cannot be a stream in sync mode");
    };
    module2.exports = {
      handleInput,
      makeAllStream,
      getSpawnedResult,
      validateInputSync
    };
  }
});

// ../../node_modules/execa/lib/promise.js
var require_promise = __commonJS({
  "../../node_modules/execa/lib/promise.js"(exports2, module2) {
    "use strict";
    var nativePromisePrototype = (async () => {
    })().constructor.prototype, descriptors = ["then", "catch", "finally"].map((property) => [
      property,
      Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
    ]), mergePromise = (spawned, promise) => {
      for (let [property, descriptor] of descriptors) {
        let value = typeof promise == "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
        Reflect.defineProperty(spawned, property, { ...descriptor, value });
      }
      return spawned;
    }, getSpawnedPromise = (spawned) => new Promise((resolve7, reject) => {
      spawned.on("exit", (exitCode, signal) => {
        resolve7({ exitCode, signal });
      }), spawned.on("error", (error) => {
        reject(error);
      }), spawned.stdin && spawned.stdin.on("error", (error) => {
        reject(error);
      });
    });
    module2.exports = {
      mergePromise,
      getSpawnedPromise
    };
  }
});

// ../../node_modules/execa/lib/command.js
var require_command = __commonJS({
  "../../node_modules/execa/lib/command.js"(exports2, module2) {
    "use strict";
    var normalizeArgs = (file, args = []) => Array.isArray(args) ? [file, ...args] : [file], NO_ESCAPE_REGEXP = /^[\w.-]+$/, DOUBLE_QUOTES_REGEXP = /"/g, escapeArg = (arg) => typeof arg != "string" || NO_ESCAPE_REGEXP.test(arg) ? arg : `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`, joinCommand = (file, args) => normalizeArgs(file, args).join(" "), getEscapedCommand = (file, args) => normalizeArgs(file, args).map((arg) => escapeArg(arg)).join(" "), SPACES_REGEXP = / +/g, parseCommand = (command) => {
      let tokens = [];
      for (let token of command.trim().split(SPACES_REGEXP)) {
        let previousToken = tokens[tokens.length - 1];
        previousToken && previousToken.endsWith("\\") ? tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}` : tokens.push(token);
      }
      return tokens;
    };
    module2.exports = {
      joinCommand,
      getEscapedCommand,
      parseCommand
    };
  }
});

// ../../node_modules/execa/index.js
var require_execa = __commonJS({
  "../../node_modules/execa/index.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), childProcess = require("child_process"), crossSpawn = require_cross_spawn(), stripFinalNewline = require_strip_final_newline(), npmRunPath = require_npm_run_path(), onetime = require_onetime(), makeError = require_error(), normalizeStdio = require_stdio(), { spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler } = require_kill(), { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = require_stream(), { mergePromise, getSpawnedPromise } = require_promise(), { joinCommand, parseCommand, getEscapedCommand } = require_command(), DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100, getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
      let env2 = extendEnv ? { ...process.env, ...envOption } : envOption;
      return preferLocal ? npmRunPath.env({ env: env2, cwd: localDir, execPath }) : env2;
    }, handleArguments = (file, args, options = {}) => {
      let parsed = crossSpawn._parse(file, args, options);
      return file = parsed.command, args = parsed.args, options = parsed.options, options = {
        maxBuffer: DEFAULT_MAX_BUFFER,
        buffer: !0,
        stripFinalNewline: !0,
        extendEnv: !0,
        preferLocal: !1,
        localDir: options.cwd || process.cwd(),
        execPath: process.execPath,
        encoding: "utf8",
        reject: !0,
        cleanup: !0,
        all: !1,
        windowsHide: !0,
        ...options
      }, options.env = getEnv(options), options.stdio = normalizeStdio(options), process.platform === "win32" && path6.basename(file, ".exe") === "cmd" && args.unshift("/q"), { file, args, options, parsed };
    }, handleOutput = (options, value, error) => typeof value != "string" && !Buffer.isBuffer(value) ? error === void 0 ? void 0 : "" : options.stripFinalNewline ? stripFinalNewline(value) : value, execa2 = (file, args, options) => {
      let parsed = handleArguments(file, args, options), command = joinCommand(file, args), escapedCommand = getEscapedCommand(file, args);
      validateTimeout(parsed.options);
      let spawned;
      try {
        spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        let dummySpawned = new childProcess.ChildProcess(), errorPromise = Promise.reject(makeError({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: !1,
          isCanceled: !1,
          killed: !1
        }));
        return mergePromise(dummySpawned, errorPromise);
      }
      let spawnedPromise = getSpawnedPromise(spawned), timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise), processDone = setExitHandler(spawned, parsed.options, timedPromise), context = { isCanceled: !1 };
      spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned)), spawned.cancel = spawnedCancel.bind(null, spawned, context);
      let handlePromiseOnce = onetime(async () => {
        let [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone), stdout = handleOutput(parsed.options, stdoutResult), stderr = handleOutput(parsed.options, stderrResult), all = handleOutput(parsed.options, allResult);
        if (error || exitCode !== 0 || signal !== null) {
          let returnedError = makeError({
            error,
            exitCode,
            signal,
            stdout,
            stderr,
            all,
            command,
            escapedCommand,
            parsed,
            timedOut,
            isCanceled: context.isCanceled,
            killed: spawned.killed
          });
          if (!parsed.options.reject)
            return returnedError;
          throw returnedError;
        }
        return {
          command,
          escapedCommand,
          exitCode: 0,
          stdout,
          stderr,
          all,
          failed: !1,
          timedOut: !1,
          isCanceled: !1,
          killed: !1
        };
      });
      return handleInput(spawned, parsed.options.input), spawned.all = makeAllStream(spawned, parsed.options), mergePromise(spawned, handlePromiseOnce);
    };
    module2.exports = execa2;
    module2.exports.sync = (file, args, options) => {
      let parsed = handleArguments(file, args, options), command = joinCommand(file, args), escapedCommand = getEscapedCommand(file, args);
      validateInputSync(parsed.options);
      let result;
      try {
        result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        throw makeError({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: !1,
          isCanceled: !1,
          killed: !1
        });
      }
      let stdout = handleOutput(parsed.options, result.stdout, result.error), stderr = handleOutput(parsed.options, result.stderr, result.error);
      if (result.error || result.status !== 0 || result.signal !== null) {
        let error = makeError({
          stdout,
          stderr,
          error: result.error,
          signal: result.signal,
          exitCode: result.status,
          command,
          escapedCommand,
          parsed,
          timedOut: result.error && result.error.code === "ETIMEDOUT",
          isCanceled: !1,
          killed: result.signal !== null
        });
        if (!parsed.options.reject)
          return error;
        throw error;
      }
      return {
        command,
        escapedCommand,
        exitCode: 0,
        stdout,
        stderr,
        failed: !1,
        timedOut: !1,
        isCanceled: !1,
        killed: !1
      };
    };
    module2.exports.command = (command, options) => {
      let [file, ...args] = parseCommand(command);
      return execa2(file, args, options);
    };
    module2.exports.commandSync = (command, options) => {
      let [file, ...args] = parseCommand(command);
      return execa2.sync(file, args, options);
    };
    module2.exports.node = (scriptPath, args, options = {}) => {
      args && !Array.isArray(args) && typeof args == "object" && (options = args, args = []);
      let stdio = normalizeStdio.node(options), defaultExecArgv = process.execArgv.filter((arg) => !arg.startsWith("--inspect")), {
        nodePath: nodePath2 = process.execPath,
        nodeOptions = defaultExecArgv
      } = options;
      return execa2(
        nodePath2,
        [
          ...nodeOptions,
          scriptPath,
          ...Array.isArray(args) ? args : []
        ],
        {
          ...options,
          stdin: void 0,
          stdout: void 0,
          stderr: void 0,
          stdio,
          shell: !1
        }
      );
    };
  }
});

// ../../node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../../node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] == "function")
          fn.apply(this, args);
        else
          return new Promise((resolve7, reject) => {
            fn.call(
              this,
              ...args,
              (err, res) => err != null ? reject(err) : resolve7(res)
            );
          });
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        let cb = args[args.length - 1];
        if (typeof cb != "function")
          return fn.apply(this, args);
        fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// ../../node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants = require("constants"), origCwd = process.cwd, cwd2 = null, platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      return cwd2 || (cwd2 = origCwd.call(process)), cwd2;
    };
    try {
      process.cwd();
    } catch {
    }
    typeof process.chdir == "function" && (chdir = process.chdir, process.chdir = function(d) {
      cwd2 = null, chdir.call(process, d);
    }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, chdir));
    var chdir;
    module2.exports = patch;
    function patch(fs7) {
      constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && patchLchmod(fs7), fs7.lutimes || patchLutimes(fs7), fs7.chown = chownFix(fs7.chown), fs7.fchown = chownFix(fs7.fchown), fs7.lchown = chownFix(fs7.lchown), fs7.chmod = chmodFix(fs7.chmod), fs7.fchmod = chmodFix(fs7.fchmod), fs7.lchmod = chmodFix(fs7.lchmod), fs7.chownSync = chownFixSync(fs7.chownSync), fs7.fchownSync = chownFixSync(fs7.fchownSync), fs7.lchownSync = chownFixSync(fs7.lchownSync), fs7.chmodSync = chmodFixSync(fs7.chmodSync), fs7.fchmodSync = chmodFixSync(fs7.fchmodSync), fs7.lchmodSync = chmodFixSync(fs7.lchmodSync), fs7.stat = statFix(fs7.stat), fs7.fstat = statFix(fs7.fstat), fs7.lstat = statFix(fs7.lstat), fs7.statSync = statFixSync(fs7.statSync), fs7.fstatSync = statFixSync(fs7.fstatSync), fs7.lstatSync = statFixSync(fs7.lstatSync), fs7.chmod && !fs7.lchmod && (fs7.lchmod = function(path6, mode, cb) {
        cb && process.nextTick(cb);
      }, fs7.lchmodSync = function() {
      }), fs7.chown && !fs7.lchown && (fs7.lchown = function(path6, uid, gid, cb) {
        cb && process.nextTick(cb);
      }, fs7.lchownSync = function() {
      }), platform === "win32" && (fs7.rename = typeof fs7.rename != "function" ? fs7.rename : function(fs$rename) {
        function rename3(from, to, cb) {
          var start = Date.now(), backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs7.stat(to, function(stater, st) {
                  stater && stater.code === "ENOENT" ? fs$rename(from, to, CB) : cb(er);
                });
              }, backoff), backoff < 100 && (backoff += 10);
              return;
            }
            cb && cb(er);
          });
        }
        return Object.setPrototypeOf && Object.setPrototypeOf(rename3, fs$rename), rename3;
      }(fs7.rename)), fs7.read = typeof fs7.read != "function" ? fs7.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ == "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10)
                return eagCounter++, fs$read.call(fs7, fd, buffer, offset, length, position, callback);
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs7, fd, buffer, offset, length, position, callback);
        }
        return Object.setPrototypeOf && Object.setPrototypeOf(read, fs$read), read;
      }(fs7.read), fs7.readSync = typeof fs7.readSync != "function" ? fs7.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          for (var eagCounter = 0; ; )
            try {
              return fs$readSync.call(fs7, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
        };
      }(fs7.readSync);
      function patchLchmod(fs8) {
        fs8.lchmod = function(path6, mode, callback) {
          fs8.open(
            path6,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                callback && callback(err);
                return;
              }
              fs8.fchmod(fd, mode, function(err2) {
                fs8.close(fd, function(err22) {
                  callback && callback(err2 || err22);
                });
              });
            }
          );
        }, fs8.lchmodSync = function(path6, mode) {
          var fd = fs8.openSync(path6, constants.O_WRONLY | constants.O_SYMLINK, mode), threw = !0, ret;
          try {
            ret = fs8.fchmodSync(fd, mode), threw = !1;
          } finally {
            if (threw)
              try {
                fs8.closeSync(fd);
              } catch {
              }
            else
              fs8.closeSync(fd);
          }
          return ret;
        };
      }
      function patchLutimes(fs8) {
        constants.hasOwnProperty("O_SYMLINK") && fs8.futimes ? (fs8.lutimes = function(path6, at, mt, cb) {
          fs8.open(path6, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              cb && cb(er);
              return;
            }
            fs8.futimes(fd, at, mt, function(er2) {
              fs8.close(fd, function(er22) {
                cb && cb(er2 || er22);
              });
            });
          });
        }, fs8.lutimesSync = function(path6, at, mt) {
          var fd = fs8.openSync(path6, constants.O_SYMLINK), ret, threw = !0;
          try {
            ret = fs8.futimesSync(fd, at, mt), threw = !1;
          } finally {
            if (threw)
              try {
                fs8.closeSync(fd);
              } catch {
              }
            else
              fs8.closeSync(fd);
          }
          return ret;
        }) : fs8.futimes && (fs8.lutimes = function(_a2, _b, _c, cb) {
          cb && process.nextTick(cb);
        }, fs8.lutimesSync = function() {
        });
      }
      function chmodFix(orig) {
        return orig && function(target, mode, cb) {
          return orig.call(fs7, target, mode, function(er) {
            chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        return orig && function(target, mode) {
          try {
            return orig.call(fs7, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        return orig && function(target, uid, gid, cb) {
          return orig.call(fs7, target, uid, gid, function(er) {
            chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        return orig && function(target, uid, gid) {
          try {
            return orig.call(fs7, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        return orig && function(target, options, cb) {
          typeof options == "function" && (cb = options, options = null);
          function callback(er, stats) {
            stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), cb && cb.apply(this, arguments);
          }
          return options ? orig.call(fs7, target, options, callback) : orig.call(fs7, target, callback);
        };
      }
      function statFixSync(orig) {
        return orig && function(target, options) {
          var stats = options ? orig.call(fs7, target, options) : orig.call(fs7, target);
          return stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), stats;
        };
      }
      function chownErOk(er) {
        if (!er || er.code === "ENOSYS")
          return !0;
        var nonroot = !process.getuid || process.getuid() !== 0;
        return !!(nonroot && (er.code === "EINVAL" || er.code === "EPERM"));
      }
    }
  }
});

// ../../node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream3 = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs7) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path6, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path6, options);
        Stream3.call(this);
        var self = this;
        this.path = path6, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, options = options || {};
        for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
          if (typeof this.start != "number")
            throw TypeError("start must be a Number");
          if (this.end === void 0)
            this.end = 1 / 0;
          else if (typeof this.end != "number")
            throw TypeError("end must be a Number");
          if (this.start > this.end)
            throw new Error("start must be <= end");
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs7.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err), self.readable = !1;
            return;
          }
          self.fd = fd, self.emit("open", fd), self._read();
        });
      }
      function WriteStream(path6, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path6, options);
        Stream3.call(this), this.path = path6, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options = options || {};
        for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start != "number")
            throw TypeError("start must be a Number");
          if (this.start < 0)
            throw new Error("start must be >= zero");
          this.pos = this.start;
        }
        this.busy = !1, this._queue = [], this.fd === null && (this._open = fs7.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
      }
    }
  }
});

// ../../node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj != "object")
        return obj;
      if (obj instanceof Object)
        var copy2 = { __proto__: getPrototypeOf(obj) };
      else
        var copy2 = /* @__PURE__ */ Object.create(null);
      return Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
      }), copy2;
    }
  }
});

// ../../node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs7 = require("fs"), polyfills = require_polyfills(), legacy = require_legacy_streams(), clone = require_clone(), util = require("util"), gracefulQueue, previousSymbol;
    typeof Symbol == "function" && typeof Symbol.for == "function" ? (gracefulQueue = Symbol.for("graceful-fs.queue"), previousSymbol = Symbol.for("graceful-fs.previous")) : (gracefulQueue = "___graceful-fs.queue", previousSymbol = "___graceful-fs.previous");
    function noop2() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop2;
    util.debuglog ? debug = util.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (debug = function() {
      var m = util.format.apply(util, arguments);
      m = "GFS4: " + m.split(/\n/).join(`
GFS4: `), console.error(m);
    });
    fs7[gracefulQueue] || (queue = global[gracefulQueue] || [], publishQueue(fs7, queue), fs7.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs7, fd, function(err) {
          err || resetQueue(), typeof cb == "function" && cb.apply(this, arguments);
        });
      }
      return Object.defineProperty(close, previousSymbol, {
        value: fs$close
      }), close;
    }(fs7.close), fs7.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs7, arguments), resetQueue();
      }
      return Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      }), closeSync;
    }(fs7.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
      debug(fs7[gracefulQueue]), require("assert").equal(fs7[gracefulQueue].length, 0);
    }));
    var queue;
    global[gracefulQueue] || publishQueue(global, fs7[gracefulQueue]);
    module2.exports = patch(clone(fs7));
    process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs7.__patched && (module2.exports = patch(fs7), fs7.__patched = !0);
    function patch(fs8) {
      polyfills(fs8), fs8.gracefulify = patch, fs8.createReadStream = createReadStream, fs8.createWriteStream = createWriteStream;
      var fs$readFile = fs8.readFile;
      fs8.readFile = readFile;
      function readFile(path6, options, cb) {
        return typeof options == "function" && (cb = options, options = null), go$readFile(path6, options, cb);
        function go$readFile(path7, options2, cb2, startTime) {
          return fs$readFile(path7, options2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$readFile, [path7, options2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$writeFile = fs8.writeFile;
      fs8.writeFile = writeFile;
      function writeFile(path6, data, options, cb) {
        return typeof options == "function" && (cb = options, options = null), go$writeFile(path6, data, options, cb);
        function go$writeFile(path7, data2, options2, cb2, startTime) {
          return fs$writeFile(path7, data2, options2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$writeFile, [path7, data2, options2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$appendFile = fs8.appendFile;
      fs$appendFile && (fs8.appendFile = appendFile);
      function appendFile(path6, data, options, cb) {
        return typeof options == "function" && (cb = options, options = null), go$appendFile(path6, data, options, cb);
        function go$appendFile(path7, data2, options2, cb2, startTime) {
          return fs$appendFile(path7, data2, options2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$appendFile, [path7, data2, options2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$copyFile = fs8.copyFile;
      fs$copyFile && (fs8.copyFile = copyFile);
      function copyFile(src, dest, flags, cb) {
        return typeof flags == "function" && (cb = flags, flags = 0), go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$readdir = fs8.readdir;
      fs8.readdir = readdir4;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir4(path6, options, cb) {
        typeof options == "function" && (cb = options, options = null);
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path7, options2, cb2, startTime) {
          return fs$readdir(path7, fs$readdirCallback(
            path7,
            options2,
            cb2,
            startTime
          ));
        } : function(path7, options2, cb2, startTime) {
          return fs$readdir(path7, options2, fs$readdirCallback(
            path7,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path6, options, cb);
        function fs$readdirCallback(path7, options2, cb2, startTime) {
          return function(err, files) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
              go$readdir,
              [path7, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]) : (files && files.sort && files.sort(), typeof cb2 == "function" && cb2.call(this, err, files));
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs8);
        ReadStream = legStreams.ReadStream, WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs8.ReadStream;
      fs$ReadStream && (ReadStream.prototype = Object.create(fs$ReadStream.prototype), ReadStream.prototype.open = ReadStream$open);
      var fs$WriteStream = fs8.WriteStream;
      fs$WriteStream && (WriteStream.prototype = Object.create(fs$WriteStream.prototype), WriteStream.prototype.open = WriteStream$open), Object.defineProperty(fs8, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(fs8, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: !0,
        configurable: !0
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs8, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: !0,
        configurable: !0
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs8, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: !0,
        configurable: !0
      });
      function ReadStream(path6, options) {
        return this instanceof ReadStream ? (fs$ReadStream.apply(this, arguments), this) : ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open3(that.path, that.flags, that.mode, function(err, fd) {
          err ? (that.autoClose && that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd), that.read());
        });
      }
      function WriteStream(path6, options) {
        return this instanceof WriteStream ? (fs$WriteStream.apply(this, arguments), this) : WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open3(that.path, that.flags, that.mode, function(err, fd) {
          err ? (that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd));
        });
      }
      function createReadStream(path6, options) {
        return new fs8.ReadStream(path6, options);
      }
      function createWriteStream(path6, options) {
        return new fs8.WriteStream(path6, options);
      }
      var fs$open = fs8.open;
      fs8.open = open3;
      function open3(path6, flags, mode, cb) {
        return typeof mode == "function" && (cb = mode, mode = null), go$open(path6, flags, mode, cb);
        function go$open(path7, flags2, mode2, cb2, startTime) {
          return fs$open(path7, flags2, mode2, function(err, fd) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$open, [path7, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      return fs8;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]), fs7[gracefulQueue].push(elem), retry();
    }
    var retryTimer;
    function resetQueue() {
      for (var now = Date.now(), i = 0; i < fs7[gracefulQueue].length; ++i)
        fs7[gracefulQueue][i].length > 2 && (fs7[gracefulQueue][i][3] = now, fs7[gracefulQueue][i][4] = now);
      retry();
    }
    function retry() {
      if (clearTimeout(retryTimer), retryTimer = void 0, fs7[gracefulQueue].length !== 0) {
        var elem = fs7[gracefulQueue].shift(), fn = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
        if (startTime === void 0)
          debug("RETRY", fn.name, args), fn.apply(null, args);
        else if (Date.now() - startTime >= 6e4) {
          debug("TIMEOUT", fn.name, args);
          var cb = args.pop();
          typeof cb == "function" && cb.call(null, err);
        } else {
          var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1), desiredDelay = Math.min(sinceStart * 1.2, 100);
          sinceAttempt >= desiredDelay ? (debug("RETRY", fn.name, args), fn.apply(null, args.concat([startTime]))) : fs7[gracefulQueue].push(elem);
        }
        retryTimer === void 0 && (retryTimer = setTimeout(retry, 0));
      }
    }
  }
});

// ../../node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "../../node_modules/fs-extra/lib/fs/index.js"(exports2) {
    "use strict";
    var u = require_universalify().fromCallback, fs7 = require_graceful_fs(), api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => typeof fs7[key] == "function");
    Object.assign(exports2, fs7);
    api.forEach((method) => {
      exports2[method] = u(fs7[method]);
    });
    exports2.exists = function(filename, callback) {
      return typeof callback == "function" ? fs7.exists(filename, callback) : new Promise((resolve7) => fs7.exists(filename, resolve7));
    };
    exports2.read = function(fd, buffer, offset, length, position, callback) {
      return typeof callback == "function" ? fs7.read(fd, buffer, offset, length, position, callback) : new Promise((resolve7, reject) => {
        fs7.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve7({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports2.write = function(fd, buffer, ...args) {
      return typeof args[args.length - 1] == "function" ? fs7.write(fd, buffer, ...args) : new Promise((resolve7, reject) => {
        fs7.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve7({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports2.readv = function(fd, buffers, ...args) {
      return typeof args[args.length - 1] == "function" ? fs7.readv(fd, buffers, ...args) : new Promise((resolve7, reject) => {
        fs7.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err)
            return reject(err);
          resolve7({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports2.writev = function(fd, buffers, ...args) {
      return typeof args[args.length - 1] == "function" ? fs7.writev(fd, buffers, ...args) : new Promise((resolve7, reject) => {
        fs7.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve7({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    typeof fs7.realpath.native == "function" ? exports2.realpath.native = u(fs7.realpath.native) : process.emitWarning(
      "fs.realpath.native is not a function. Is fs being monkey-patched?",
      "Warning",
      "fs-extra-WARN0003"
    );
  }
});

// ../../node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "../../node_modules/fs-extra/lib/mkdirs/utils.js"(exports2, module2) {
    "use strict";
    var path6 = require("path");
    module2.exports.checkPath = function(pth) {
      if (process.platform === "win32" && /[<>:"|?*]/.test(pth.replace(path6.parse(pth).root, ""))) {
        let error = new Error(`Path contains invalid characters: ${pth}`);
        throw error.code = "EINVAL", error;
      }
    };
  }
});

// ../../node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "../../node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports2, module2) {
    "use strict";
    var fs7 = require_fs(), { checkPath } = require_utils(), getMode = (options) => {
      let defaults3 = { mode: 511 };
      return typeof options == "number" ? options : { ...defaults3, ...options }.mode;
    };
    module2.exports.makeDir = async (dir, options) => (checkPath(dir), fs7.mkdir(dir, {
      mode: getMode(options),
      recursive: !0
    }));
    module2.exports.makeDirSync = (dir, options) => (checkPath(dir), fs7.mkdirSync(dir, {
      mode: getMode(options),
      recursive: !0
    }));
  }
});

// ../../node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "../../node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, { makeDir: _makeDir, makeDirSync } = require_make_dir(), makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// ../../node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "../../node_modules/fs-extra/lib/path-exists/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, fs7 = require_fs();
    function pathExists3(path6) {
      return fs7.access(path6).then(() => !0).catch(() => !1);
    }
    module2.exports = {
      pathExists: u(pathExists3),
      pathExistsSync: fs7.existsSync
    };
  }
});

// ../../node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "../../node_modules/fs-extra/lib/util/utimes.js"(exports2, module2) {
    "use strict";
    var fs7 = require_graceful_fs();
    function utimesMillis(path6, atime, mtime, callback) {
      fs7.open(path6, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs7.futimes(fd, atime, mtime, (futimesErr) => {
          fs7.close(fd, (closeErr) => {
            callback && callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path6, atime, mtime) {
      let fd = fs7.openSync(path6, "r+");
      return fs7.futimesSync(fd, atime, mtime), fs7.closeSync(fd);
    }
    module2.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// ../../node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "../../node_modules/fs-extra/lib/util/stat.js"(exports2, module2) {
    "use strict";
    var fs7 = require_fs(), path6 = require("path"), util = require("util");
    function getStats(src, dest, opts) {
      let statFunc = opts.dereference ? (file) => fs7.stat(file, { bigint: !0 }) : (file) => fs7.lstat(file, { bigint: !0 });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat, statFunc = opts.dereference ? (file) => fs7.statSync(file, { bigint: !0 }) : (file) => fs7.lstatSync(file, { bigint: !0 }), srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, opts, cb) {
      util.callbackify(getStats)(src, dest, opts, (err, stats) => {
        if (err)
          return cb(err);
        let { srcStat, destStat } = stats;
        if (destStat) {
          if (areIdentical(srcStat, destStat)) {
            let srcBaseName = path6.basename(src), destBaseName = path6.basename(dest);
            return funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase() ? cb(null, { srcStat, destStat, isChangingCase: !0 }) : cb(new Error("Source and destination must not be the same."));
          }
          if (srcStat.isDirectory() && !destStat.isDirectory())
            return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
          if (!srcStat.isDirectory() && destStat.isDirectory())
            return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
        }
        return srcStat.isDirectory() && isSrcSubdir(src, dest) ? cb(new Error(errMsg(src, dest, funcName))) : cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName, opts) {
      let { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          let srcBaseName = path6.basename(src), destBaseName = path6.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase())
            return { srcStat, destStat, isChangingCase: !0 };
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory())
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        if (!srcStat.isDirectory() && destStat.isDirectory())
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest))
        throw new Error(errMsg(src, dest, funcName));
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      let srcParent = path6.resolve(path6.dirname(src)), destParent = path6.resolve(path6.dirname(dest));
      if (destParent === srcParent || destParent === path6.parse(destParent).root)
        return cb();
      fs7.stat(destParent, { bigint: !0 }, (err, destStat) => err ? err.code === "ENOENT" ? cb() : cb(err) : areIdentical(srcStat, destStat) ? cb(new Error(errMsg(src, dest, funcName))) : checkParentPaths(src, srcStat, destParent, funcName, cb));
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      let srcParent = path6.resolve(path6.dirname(src)), destParent = path6.resolve(path6.dirname(dest));
      if (destParent === srcParent || destParent === path6.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = fs7.statSync(destParent, { bigint: !0 });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat))
        throw new Error(errMsg(src, dest, funcName));
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      let srcArr = path6.resolve(src).split(path6.sep).filter((i) => i), destArr = path6.resolve(dest).split(path6.sep).filter((i) => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, !0);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir,
      areIdentical
    };
  }
});

// ../../node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "../../node_modules/fs-extra/lib/copy/copy.js"(exports2, module2) {
    "use strict";
    var fs7 = require_graceful_fs(), path6 = require("path"), mkdirs = require_mkdirs().mkdirs, pathExists3 = require_path_exists().pathExists, utimesMillis = require_utimes().utimesMillis, stat3 = require_stat();
    function copy2(src, dest, opts, cb) {
      typeof opts == "function" && !cb ? (cb = opts, opts = {}) : typeof opts == "function" && (opts = { filter: opts }), cb = cb || function() {
      }, opts = opts || {}, opts.clobber = "clobber" in opts ? !!opts.clobber : !0, opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber, opts.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
        `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
        "Warning",
        "fs-extra-WARN0001"
      ), stat3.checkPaths(src, dest, "copy", opts, (err, stats) => {
        if (err)
          return cb(err);
        let { srcStat, destStat } = stats;
        stat3.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          runFilter(src, dest, opts, (err3, include) => {
            if (err3)
              return cb(err3);
            if (!include)
              return cb();
            checkParentDir(destStat, src, dest, opts, cb);
          });
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      let destParent = path6.dirname(dest);
      pathExists3(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return getStats(destStat, src, dest, opts, cb);
        mkdirs(destParent, (err2) => err2 ? cb(err2) : getStats(destStat, src, dest, opts, cb));
      });
    }
    function runFilter(src, dest, opts, cb) {
      if (!opts.filter)
        return cb(null, !0);
      Promise.resolve(opts.filter(src, dest)).then((include) => cb(null, include), (error) => cb(error));
    }
    function getStats(destStat, src, dest, opts, cb) {
      (opts.dereference ? fs7.stat : fs7.lstat)(src, (err, srcStat) => err ? cb(err) : srcStat.isDirectory() ? onDir(srcStat, destStat, src, dest, opts, cb) : srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice() ? onFile(srcStat, destStat, src, dest, opts, cb) : srcStat.isSymbolicLink() ? onLink(destStat, src, dest, opts, cb) : srcStat.isSocket() ? cb(new Error(`Cannot copy a socket file: ${src}`)) : srcStat.isFIFO() ? cb(new Error(`Cannot copy a FIFO pipe: ${src}`)) : cb(new Error(`Unknown file: ${src}`)));
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      return destStat ? mayCopyFile(srcStat, src, dest, opts, cb) : copyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite)
        fs7.unlink(dest, (err) => err ? cb(err) : copyFile(srcStat, src, dest, opts, cb));
      else
        return opts.errorOnExist ? cb(new Error(`'${dest}' already exists`)) : cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
      fs7.copyFile(src, dest, (err) => err ? cb(err) : opts.preserveTimestamps ? handleTimestampsAndMode(srcStat.mode, src, dest, cb) : setDestMode(dest, srcStat.mode, cb));
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      return fileIsNotWritable(srcMode) ? makeFileWritable(dest, srcMode, (err) => err ? cb(err) : setDestTimestampsAndMode(srcMode, src, dest, cb)) : setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => err ? cb(err) : setDestMode(dest, srcMode, cb));
    }
    function setDestMode(dest, srcMode, cb) {
      return fs7.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
      fs7.stat(src, (err, updatedSrcStat) => err ? cb(err) : utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb));
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      return destStat ? copyDir(src, dest, opts, cb) : mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
      fs7.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => err2 ? cb(err2) : setDestMode(dest, srcMode, cb));
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs7.readdir(src, (err, items) => err ? cb(err) : copyDirItems(items, src, dest, opts, cb));
    }
    function copyDirItems(items, src, dest, opts, cb) {
      let item = items.pop();
      return item ? copyDirItem(items, item, src, dest, opts, cb) : cb();
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      let srcItem = path6.join(src, item), destItem = path6.join(dest, item);
      runFilter(srcItem, destItem, opts, (err, include) => {
        if (err)
          return cb(err);
        if (!include)
          return copyDirItems(items, src, dest, opts, cb);
        stat3.checkPaths(srcItem, destItem, "copy", opts, (err2, stats) => {
          if (err2)
            return cb(err2);
          let { destStat } = stats;
          getStats(destStat, srcItem, destItem, opts, (err3) => err3 ? cb(err3) : copyDirItems(items, src, dest, opts, cb));
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs7.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference && (resolvedSrc = path6.resolve(process.cwd(), resolvedSrc)), destStat)
          fs7.readlink(dest, (err2, resolvedDest) => err2 ? err2.code === "EINVAL" || err2.code === "UNKNOWN" ? fs7.symlink(resolvedSrc, dest, cb) : cb(err2) : (opts.dereference && (resolvedDest = path6.resolve(process.cwd(), resolvedDest)), stat3.isSrcSubdir(resolvedSrc, resolvedDest) ? cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)) : stat3.isSrcSubdir(resolvedDest, resolvedSrc) ? cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)) : copyLink(resolvedSrc, dest, cb)));
        else
          return fs7.symlink(resolvedSrc, dest, cb);
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs7.unlink(dest, (err) => err ? cb(err) : fs7.symlink(resolvedSrc, dest, cb));
    }
    module2.exports = copy2;
  }
});

// ../../node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "../../node_modules/fs-extra/lib/copy/copy-sync.js"(exports2, module2) {
    "use strict";
    var fs7 = require_graceful_fs(), path6 = require("path"), mkdirsSync = require_mkdirs().mkdirsSync, utimesMillisSync = require_utimes().utimesMillisSync, stat3 = require_stat();
    function copySync(src, dest, opts) {
      typeof opts == "function" && (opts = { filter: opts }), opts = opts || {}, opts.clobber = "clobber" in opts ? !!opts.clobber : !0, opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber, opts.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
        `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
        "Warning",
        "fs-extra-WARN0002"
      );
      let { srcStat, destStat } = stat3.checkPathsSync(src, dest, "copy", opts);
      if (stat3.checkParentPathsSync(src, srcStat, dest, "copy"), opts.filter && !opts.filter(src, dest))
        return;
      let destParent = path6.dirname(dest);
      return fs7.existsSync(destParent) || mkdirsSync(destParent), getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      let srcStat = (opts.dereference ? fs7.statSync : fs7.lstatSync)(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      throw srcStat.isSocket() ? new Error(`Cannot copy a socket file: ${src}`) : srcStat.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${src}`) : new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      return destStat ? mayCopyFile(srcStat, src, dest, opts) : copyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite)
        return fs7.unlinkSync(dest), copyFile(srcStat, src, dest, opts);
      if (opts.errorOnExist)
        throw new Error(`'${dest}' already exists`);
    }
    function copyFile(srcStat, src, dest, opts) {
      return fs7.copyFileSync(src, dest), opts.preserveTimestamps && handleTimestamps(srcStat.mode, src, dest), setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      return fileIsNotWritable(srcMode) && makeFileWritable(dest, srcMode), setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs7.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      let updatedSrcStat = fs7.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      return destStat ? copyDir(src, dest, opts) : mkDirAndCopy(srcStat.mode, src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      return fs7.mkdirSync(dest), copyDir(src, dest, opts), setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs7.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      let srcItem = path6.join(src, item), destItem = path6.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem))
        return;
      let { destStat } = stat3.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs7.readlinkSync(src);
      if (opts.dereference && (resolvedSrc = path6.resolve(process.cwd(), resolvedSrc)), destStat) {
        let resolvedDest;
        try {
          resolvedDest = fs7.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs7.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference && (resolvedDest = path6.resolve(process.cwd(), resolvedDest)), stat3.isSrcSubdir(resolvedSrc, resolvedDest))
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        if (stat3.isSrcSubdir(resolvedDest, resolvedSrc))
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        return copyLink(resolvedSrc, dest);
      } else
        return fs7.symlinkSync(resolvedSrc, dest);
    }
    function copyLink(resolvedSrc, dest) {
      return fs7.unlinkSync(dest), fs7.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// ../../node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "../../node_modules/fs-extra/lib/copy/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      copy: u(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// ../../node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "../../node_modules/fs-extra/lib/remove/index.js"(exports2, module2) {
    "use strict";
    var fs7 = require_graceful_fs(), u = require_universalify().fromCallback;
    function remove2(path6, callback) {
      fs7.rm(path6, { recursive: !0, force: !0 }, callback);
    }
    function removeSync(path6) {
      fs7.rmSync(path6, { recursive: !0, force: !0 });
    }
    module2.exports = {
      remove: u(remove2),
      removeSync
    };
  }
});

// ../../node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "../../node_modules/fs-extra/lib/empty/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, fs7 = require_fs(), path6 = require("path"), mkdir2 = require_mkdirs(), remove2 = require_remove(), emptyDir = u(async function(dir) {
      let items;
      try {
        items = await fs7.readdir(dir);
      } catch {
        return mkdir2.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove2.remove(path6.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs7.readdirSync(dir);
      } catch {
        return mkdir2.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path6.join(dir, item), remove2.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/file.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback, path6 = require("path"), fs7 = require_graceful_fs(), mkdir2 = require_mkdirs();
    function createFile(file, callback) {
      function makeFile() {
        fs7.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs7.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        let dir = path6.dirname(file);
        fs7.stat(dir, (err2, stats2) => {
          if (err2)
            return err2.code === "ENOENT" ? mkdir2.mkdirs(dir, (err3) => {
              if (err3)
                return callback(err3);
              makeFile();
            }) : callback(err2);
          stats2.isDirectory() ? makeFile() : fs7.readdir(dir, (err3) => {
            if (err3)
              return callback(err3);
          });
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs7.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      let dir = path6.dirname(file);
      try {
        fs7.statSync(dir).isDirectory() || fs7.readdirSync(dir);
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir2.mkdirsSync(dir);
        else
          throw err;
      }
      fs7.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/link.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback, path6 = require("path"), fs7 = require_graceful_fs(), mkdir2 = require_mkdirs(), pathExists3 = require_path_exists().pathExists, { areIdentical } = require_stat();
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs7.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      fs7.lstat(dstpath, (_, dstStat) => {
        fs7.lstat(srcpath, (err, srcStat) => {
          if (err)
            return err.message = err.message.replace("lstat", "ensureLink"), callback(err);
          if (dstStat && areIdentical(srcStat, dstStat))
            return callback(null);
          let dir = path6.dirname(dstpath);
          pathExists3(dir, (err2, dirExists) => {
            if (err2)
              return callback(err2);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir2.mkdirs(dir, (err3) => {
              if (err3)
                return callback(err3);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs7.lstatSync(dstpath);
      } catch {
      }
      try {
        let srcStat = fs7.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat))
          return;
      } catch (err) {
        throw err.message = err.message.replace("lstat", "ensureLink"), err;
      }
      let dir = path6.dirname(dstpath);
      return fs7.existsSync(dir) || mkdir2.mkdirsSync(dir), fs7.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), fs7 = require_graceful_fs(), pathExists3 = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path6.isAbsolute(srcpath))
        return fs7.lstat(srcpath, (err) => err ? (err.message = err.message.replace("lstat", "ensureSymlink"), callback(err)) : callback(null, {
          toCwd: srcpath,
          toDst: srcpath
        }));
      {
        let dstdir = path6.dirname(dstpath), relativeToDst = path6.join(dstdir, srcpath);
        return pathExists3(relativeToDst, (err, exists) => err ? callback(err) : exists ? callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        }) : fs7.lstat(srcpath, (err2) => err2 ? (err2.message = err2.message.replace("lstat", "ensureSymlink"), callback(err2)) : callback(null, {
          toCwd: srcpath,
          toDst: path6.relative(dstdir, srcpath)
        })));
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path6.isAbsolute(srcpath)) {
        if (exists = fs7.existsSync(srcpath), !exists)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        let dstdir = path6.dirname(dstpath), relativeToDst = path6.join(dstdir, srcpath);
        if (exists = fs7.existsSync(relativeToDst), exists)
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        if (exists = fs7.existsSync(srcpath), !exists)
          throw new Error("relative srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: path6.relative(dstdir, srcpath)
        };
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module2) {
    "use strict";
    var fs7 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      if (callback = typeof type == "function" ? type : callback, type = typeof type == "function" ? !1 : type, type)
        return callback(null, type);
      fs7.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file", callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs7.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback, path6 = require("path"), fs7 = require_fs(), _mkdirs = require_mkdirs(), mkdirs = _mkdirs.mkdirs, mkdirsSync = _mkdirs.mkdirsSync, _symlinkPaths = require_symlink_paths(), symlinkPaths = _symlinkPaths.symlinkPaths, symlinkPathsSync = _symlinkPaths.symlinkPathsSync, _symlinkType = require_symlink_type(), symlinkType = _symlinkType.symlinkType, symlinkTypeSync = _symlinkType.symlinkTypeSync, pathExists3 = require_path_exists().pathExists, { areIdentical } = require_stat();
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type == "function" ? type : callback, type = typeof type == "function" ? !1 : type, fs7.lstat(dstpath, (err, stats) => {
        !err && stats.isSymbolicLink() ? Promise.all([
          fs7.stat(srcpath),
          fs7.stat(dstpath)
        ]).then(([srcStat, dstStat]) => {
          if (areIdentical(srcStat, dstStat))
            return callback(null);
          _createSymlink(srcpath, dstpath, type, callback);
        }) : _createSymlink(srcpath, dstpath, type, callback);
      });
    }
    function _createSymlink(srcpath, dstpath, type, callback) {
      symlinkPaths(srcpath, dstpath, (err, relative) => {
        if (err)
          return callback(err);
        srcpath = relative.toDst, symlinkType(relative.toCwd, type, (err2, type2) => {
          if (err2)
            return callback(err2);
          let dir = path6.dirname(dstpath);
          pathExists3(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return fs7.symlink(srcpath, dstpath, type2, callback);
            mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              fs7.symlink(srcpath, dstpath, type2, callback);
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs7.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        let srcStat = fs7.statSync(srcpath), dstStat = fs7.statSync(dstpath);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      let relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst, type = symlinkTypeSync(relative.toCwd, type);
      let dir = path6.dirname(dstpath);
      return fs7.existsSync(dir) || mkdirsSync(dir), fs7.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// ../../node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "../../node_modules/fs-extra/lib/ensure/index.js"(exports2, module2) {
    "use strict";
    var { createFile, createFileSync } = require_file(), { createLink, createLinkSync } = require_link(), { createSymlink, createSymlinkSync } = require_symlink();
    module2.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// ../../node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/jsonfile/utils.js"(exports2, module2) {
    function stringify(obj, { EOL = `
`, finalEOL = !0, replacer = null, spaces } = {}) {
      let EOF3 = finalEOL ? EOL : "";
      return JSON.stringify(obj, replacer, spaces).replace(/\n/g, EOL) + EOF3;
    }
    function stripBom(content) {
      return Buffer.isBuffer(content) && (content = content.toString("utf8")), content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify, stripBom };
  }
});

// ../../node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "../../node_modules/jsonfile/index.js"(exports2, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch {
      _fs = require("fs");
    }
    var universalify = require_universalify(), { stringify, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      typeof options == "string" && (options = { encoding: options });
      let fs7 = options.fs || _fs, shouldThrow = "throws" in options ? options.throws : !0, data = await universalify.fromCallback(fs7.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow)
          throw err.message = `${file}: ${err.message}`, err;
        return null;
      }
      return obj;
    }
    var readFile = universalify.fromPromise(_readFile);
    function readFileSync3(file, options = {}) {
      typeof options == "string" && (options = { encoding: options });
      let fs7 = options.fs || _fs, shouldThrow = "throws" in options ? options.throws : !0;
      try {
        let content = fs7.readFileSync(file, options);
        return content = stripBom(content), JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow)
          throw err.message = `${file}: ${err.message}`, err;
        return null;
      }
    }
    async function _writeFile(file, obj, options = {}) {
      let fs7 = options.fs || _fs, str = stringify(obj, options);
      await universalify.fromCallback(fs7.writeFile)(file, str, options);
    }
    var writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync2(file, obj, options = {}) {
      let fs7 = options.fs || _fs, str = stringify(obj, options);
      return fs7.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile,
      readFileSync: readFileSync3,
      writeFile,
      writeFileSync: writeFileSync2
    };
    module2.exports = jsonfile;
  }
});

// ../../node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "../../node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../../node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "../../node_modules/fs-extra/lib/output-file/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback, fs7 = require_graceful_fs(), path6 = require("path"), mkdir2 = require_mkdirs(), pathExists3 = require_path_exists().pathExists;
    function outputFile(file, data, encoding, callback) {
      typeof encoding == "function" && (callback = encoding, encoding = "utf8");
      let dir = path6.dirname(file);
      pathExists3(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs7.writeFile(file, data, encoding, callback);
        mkdir2.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs7.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      let dir = path6.dirname(file);
      if (fs7.existsSync(dir))
        return fs7.writeFileSync(file, ...args);
      mkdir2.mkdirsSync(dir), fs7.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// ../../node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "../../node_modules/fs-extra/lib/json/output-json.js"(exports2, module2) {
    "use strict";
    var { stringify } = require_utils2(), { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      let str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module2.exports = outputJson;
  }
});

// ../../node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "../../node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module2) {
    "use strict";
    var { stringify } = require_utils2(), { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      let str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});

// ../../node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "../../node_modules/fs-extra/lib/json/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise, jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// ../../node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "../../node_modules/fs-extra/lib/move/move.js"(exports2, module2) {
    "use strict";
    var fs7 = require_graceful_fs(), path6 = require("path"), copy2 = require_copy2().copy, remove2 = require_remove().remove, mkdirp = require_mkdirs().mkdirp, pathExists3 = require_path_exists().pathExists, stat3 = require_stat();
    function move(src, dest, opts, cb) {
      typeof opts == "function" && (cb = opts, opts = {}), opts = opts || {};
      let overwrite = opts.overwrite || opts.clobber || !1;
      stat3.checkPaths(src, dest, "move", opts, (err, stats) => {
        if (err)
          return cb(err);
        let { srcStat, isChangingCase = !1 } = stats;
        stat3.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          if (isParentRoot(dest))
            return doRename(src, dest, overwrite, isChangingCase, cb);
          mkdirp(path6.dirname(dest), (err3) => err3 ? cb(err3) : doRename(src, dest, overwrite, isChangingCase, cb));
        });
      });
    }
    function isParentRoot(dest) {
      let parent = path6.dirname(dest);
      return path6.parse(parent).root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase, cb) {
      if (isChangingCase)
        return rename3(src, dest, overwrite, cb);
      if (overwrite)
        return remove2(dest, (err) => err ? cb(err) : rename3(src, dest, overwrite, cb));
      pathExists3(dest, (err, destExists) => err ? cb(err) : destExists ? cb(new Error("dest already exists.")) : rename3(src, dest, overwrite, cb));
    }
    function rename3(src, dest, overwrite, cb) {
      fs7.rename(src, dest, (err) => err ? err.code !== "EXDEV" ? cb(err) : moveAcrossDevice(src, dest, overwrite, cb) : cb());
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      copy2(src, dest, {
        overwrite,
        errorOnExist: !0,
        preserveTimestamps: !0
      }, (err) => err ? cb(err) : remove2(src, cb));
    }
    module2.exports = move;
  }
});

// ../../node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "../../node_modules/fs-extra/lib/move/move-sync.js"(exports2, module2) {
    "use strict";
    var fs7 = require_graceful_fs(), path6 = require("path"), copySync = require_copy2().copySync, removeSync = require_remove().removeSync, mkdirpSync = require_mkdirs().mkdirpSync, stat3 = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      let overwrite = opts.overwrite || opts.clobber || !1, { srcStat, isChangingCase = !1 } = stat3.checkPathsSync(src, dest, "move", opts);
      return stat3.checkParentPathsSync(src, srcStat, dest, "move"), isParentRoot(dest) || mkdirpSync(path6.dirname(dest)), doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      let parent = path6.dirname(dest);
      return path6.parse(parent).root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase)
        return rename3(src, dest, overwrite);
      if (overwrite)
        return removeSync(dest), rename3(src, dest, overwrite);
      if (fs7.existsSync(dest))
        throw new Error("dest already exists.");
      return rename3(src, dest, overwrite);
    }
    function rename3(src, dest, overwrite) {
      try {
        fs7.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      return copySync(src, dest, {
        overwrite,
        errorOnExist: !0,
        preserveTimestamps: !0
      }), removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// ../../node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "../../node_modules/fs-extra/lib/move/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      move: u(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// ../../node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/fs-extra/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // Export promiseified graceful-fs:
      ...require_fs(),
      // Export extra methods:
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// ../../node_modules/opener/lib/opener.js
var require_opener = __commonJS({
  "../../node_modules/opener/lib/opener.js"(exports2, module2) {
    "use strict";
    var childProcess = require("child_process"), os2 = require("os");
    module2.exports = function(args, options, callback) {
      var platform = process.platform;
      platform === "linux" && os2.release().indexOf("Microsoft") !== -1 && (platform = "win32");
      var command;
      switch (platform) {
        case "win32": {
          command = "cmd.exe";
          break;
        }
        case "darwin": {
          command = "open";
          break;
        }
        default: {
          command = "xdg-open";
          break;
        }
      }
      return typeof args == "string" && (args = [args]), typeof options == "function" && (callback = options, options = {}), options && typeof options == "object" && options.command && (platform === "win32" ? args = [options.command].concat(args) : command = options.command), platform === "win32" && (args = args.map(function(value) {
        return value.replace(/[&^]/g, "^$&");
      }), args = ["/c", "start", '""'].concat(args)), childProcess.execFile(command, args, options, callback);
    };
  }
});

// ../../node_modules/kleur/index.js
var require_kleur = __commonJS({
  "../../node_modules/kleur/index.js"(exports2, module2) {
    "use strict";
    var { FORCE_COLOR, NODE_DISABLE_COLORS, TERM } = process.env, $2 = {
      enabled: !NODE_DISABLE_COLORS && TERM !== "dumb" && FORCE_COLOR !== "0",
      // modifiers
      reset: init(0, 0),
      bold: init(1, 22),
      dim: init(2, 22),
      italic: init(3, 23),
      underline: init(4, 24),
      inverse: init(7, 27),
      hidden: init(8, 28),
      strikethrough: init(9, 29),
      // colors
      black: init(30, 39),
      red: init(31, 39),
      green: init(32, 39),
      yellow: init(33, 39),
      blue: init(34, 39),
      magenta: init(35, 39),
      cyan: init(36, 39),
      white: init(37, 39),
      gray: init(90, 39),
      grey: init(90, 39),
      // background colors
      bgBlack: init(40, 49),
      bgRed: init(41, 49),
      bgGreen: init(42, 49),
      bgYellow: init(43, 49),
      bgBlue: init(44, 49),
      bgMagenta: init(45, 49),
      bgCyan: init(46, 49),
      bgWhite: init(47, 49)
    };
    function run2(arr, str) {
      let i = 0, tmp, beg = "", end = "";
      for (; i < arr.length; i++)
        tmp = arr[i], beg += tmp.open, end += tmp.close, str.includes(tmp.close) && (str = str.replace(tmp.rgx, tmp.close + tmp.open));
      return beg + str + end;
    }
    function chain(has, keys) {
      let ctx = { has, keys };
      return ctx.reset = $2.reset.bind(ctx), ctx.bold = $2.bold.bind(ctx), ctx.dim = $2.dim.bind(ctx), ctx.italic = $2.italic.bind(ctx), ctx.underline = $2.underline.bind(ctx), ctx.inverse = $2.inverse.bind(ctx), ctx.hidden = $2.hidden.bind(ctx), ctx.strikethrough = $2.strikethrough.bind(ctx), ctx.black = $2.black.bind(ctx), ctx.red = $2.red.bind(ctx), ctx.green = $2.green.bind(ctx), ctx.yellow = $2.yellow.bind(ctx), ctx.blue = $2.blue.bind(ctx), ctx.magenta = $2.magenta.bind(ctx), ctx.cyan = $2.cyan.bind(ctx), ctx.white = $2.white.bind(ctx), ctx.gray = $2.gray.bind(ctx), ctx.grey = $2.grey.bind(ctx), ctx.bgBlack = $2.bgBlack.bind(ctx), ctx.bgRed = $2.bgRed.bind(ctx), ctx.bgGreen = $2.bgGreen.bind(ctx), ctx.bgYellow = $2.bgYellow.bind(ctx), ctx.bgBlue = $2.bgBlue.bind(ctx), ctx.bgMagenta = $2.bgMagenta.bind(ctx), ctx.bgCyan = $2.bgCyan.bind(ctx), ctx.bgWhite = $2.bgWhite.bind(ctx), ctx;
    }
    function init(open3, close) {
      let blk = {
        open: `\x1B[${open3}m`,
        close: `\x1B[${close}m`,
        rgx: new RegExp(`\\x1b\\[${close}m`, "g")
      };
      return function(txt) {
        return this !== void 0 && this.has !== void 0 ? (this.has.includes(open3) || (this.has.push(open3), this.keys.push(blk)), txt === void 0 ? this : $2.enabled ? run2(this.keys, txt + "") : txt + "") : txt === void 0 ? chain([open3], [blk]) : $2.enabled ? run2([blk], txt + "") : txt + "";
      };
    }
    module2.exports = $2;
  }
});

// ../../node_modules/prompts/dist/util/action.js
var require_action = __commonJS({
  "../../node_modules/prompts/dist/util/action.js"(exports2, module2) {
    "use strict";
    module2.exports = (key) => {
      if (key.ctrl) {
        if (key.name === "a")
          return "first";
        if (key.name === "c" || key.name === "d")
          return "abort";
        if (key.name === "e")
          return "last";
        if (key.name === "g")
          return "reset";
      }
      return key.name === "return" || key.name === "enter" ? "submit" : key.name === "backspace" ? "delete" : key.name === "delete" ? "deleteForward" : key.name === "abort" || key.name === "escape" ? "abort" : key.name === "tab" ? "next" : key.name === "pagedown" ? "nextPage" : key.name === "pageup" ? "prevPage" : key.name === "up" ? "up" : key.name === "down" ? "down" : key.name === "right" ? "right" : key.name === "left" ? "left" : !1;
    };
  }
});

// ../../node_modules/prompts/dist/util/strip.js
var require_strip = __commonJS({
  "../../node_modules/prompts/dist/util/strip.js"(exports2, module2) {
    "use strict";
    module2.exports = (str) => {
      let pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|"), RGX = new RegExp(pattern, "g");
      return typeof str == "string" ? str.replace(RGX, "") : str;
    };
  }
});

// ../../node_modules/sisteransi/src/index.js
var require_src = __commonJS({
  "../../node_modules/sisteransi/src/index.js"(exports2, module2) {
    "use strict";
    var ESC = "\x1B", CSI = `${ESC}[`, beep = "\x07", cursor = {
      to(x, y) {
        return y ? `${CSI}${y + 1};${x + 1}H` : `${CSI}${x + 1}G`;
      },
      move(x, y) {
        let ret = "";
        return x < 0 ? ret += `${CSI}${-x}D` : x > 0 && (ret += `${CSI}${x}C`), y < 0 ? ret += `${CSI}${-y}A` : y > 0 && (ret += `${CSI}${y}B`), ret;
      },
      up: (count = 1) => `${CSI}${count}A`,
      down: (count = 1) => `${CSI}${count}B`,
      forward: (count = 1) => `${CSI}${count}C`,
      backward: (count = 1) => `${CSI}${count}D`,
      nextLine: (count = 1) => `${CSI}E`.repeat(count),
      prevLine: (count = 1) => `${CSI}F`.repeat(count),
      left: `${CSI}G`,
      hide: `${CSI}?25l`,
      show: `${CSI}?25h`,
      save: `${ESC}7`,
      restore: `${ESC}8`
    }, scroll = {
      up: (count = 1) => `${CSI}S`.repeat(count),
      down: (count = 1) => `${CSI}T`.repeat(count)
    }, erase = {
      screen: `${CSI}2J`,
      up: (count = 1) => `${CSI}1J`.repeat(count),
      down: (count = 1) => `${CSI}J`.repeat(count),
      line: `${CSI}2K`,
      lineEnd: `${CSI}K`,
      lineStart: `${CSI}1K`,
      lines(count) {
        let clear = "";
        for (let i = 0; i < count; i++)
          clear += this.line + (i < count - 1 ? cursor.up() : "");
        return count && (clear += cursor.left), clear;
      }
    };
    module2.exports = { cursor, scroll, erase, beep };
  }
});

// ../../node_modules/prompts/dist/util/clear.js
var require_clear = __commonJS({
  "../../node_modules/prompts/dist/util/clear.js"(exports2, module2) {
    "use strict";
    var strip = require_strip(), _require = require_src(), erase = _require.erase, cursor = _require.cursor, width = (str) => [...strip(str)].length;
    module2.exports = function(prompt, perLine = process.stdout.columns) {
      if (!perLine)
        return erase.line + cursor.to(0);
      let rows = 0, lines = prompt.split(/\r?\n/);
      var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
      try {
        for (var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
          let line = _step.value;
          rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
        }
      } catch (err) {
        _didIteratorError = !0, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError)
            throw _iteratorError;
        }
      }
      return (erase.line + cursor.prevLine()).repeat(rows - 1) + erase.line + cursor.to(0);
    };
  }
});

// ../../node_modules/prompts/dist/util/figures.js
var require_figures = __commonJS({
  "../../node_modules/prompts/dist/util/figures.js"(exports2, module2) {
    "use strict";
    var main5 = {
      arrowUp: "\u2191",
      arrowDown: "\u2193",
      arrowLeft: "\u2190",
      arrowRight: "\u2192",
      radioOn: "\u25C9",
      radioOff: "\u25EF",
      tick: "\u2714",
      cross: "\u2716",
      ellipsis: "\u2026",
      pointerSmall: "\u203A",
      line: "\u2500",
      pointer: "\u276F"
    }, win = {
      arrowUp: main5.arrowUp,
      arrowDown: main5.arrowDown,
      arrowLeft: main5.arrowLeft,
      arrowRight: main5.arrowRight,
      radioOn: "(*)",
      radioOff: "( )",
      tick: "\u221A",
      cross: "\xD7",
      ellipsis: "...",
      pointerSmall: "\xBB",
      line: "\u2500",
      pointer: ">"
    }, figures = process.platform === "win32" ? win : main5;
    module2.exports = figures;
  }
});

// ../../node_modules/prompts/dist/util/style.js
var require_style = __commonJS({
  "../../node_modules/prompts/dist/util/style.js"(exports2, module2) {
    "use strict";
    var c = require_kleur(), figures = require_figures(), styles3 = Object.freeze({
      password: {
        scale: 1,
        render: (input) => "*".repeat(input.length)
      },
      emoji: {
        scale: 2,
        render: (input) => "\u{1F603}".repeat(input.length)
      },
      invisible: {
        scale: 0,
        render: (input) => ""
      },
      default: {
        scale: 1,
        render: (input) => `${input}`
      }
    }), render = (type) => styles3[type] || styles3.default, symbols = Object.freeze({
      aborted: c.red(figures.cross),
      done: c.green(figures.tick),
      default: c.cyan("?")
    }), symbol = (done, aborted) => aborted ? symbols.aborted : done ? symbols.done : symbols.default, delimiter = (completing) => c.gray(completing ? figures.ellipsis : figures.pointerSmall), item = (expandable, expanded) => c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
    module2.exports = {
      styles: styles3,
      render,
      symbols,
      symbol,
      delimiter,
      item
    };
  }
});

// ../../node_modules/prompts/dist/util/index.js
var require_util2 = __commonJS({
  "../../node_modules/prompts/dist/util/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      action: require_action(),
      clear: require_clear(),
      style: require_style(),
      strip: require_strip(),
      figures: require_figures()
    };
  }
});

// ../../node_modules/prompts/dist/elements/prompt.js
var require_prompt = __commonJS({
  "../../node_modules/prompts/dist/elements/prompt.js"(exports2, module2) {
    "use strict";
    var readline = require("readline"), _require = require_util2(), action = _require.action, EventEmitter3 = require("events"), _require2 = require_src(), beep = _require2.beep, cursor = _require2.cursor, color = require_kleur(), Prompt = class extends EventEmitter3 {
      constructor(opts = {}) {
        super(), this.firstRender = !0, this.in = opts.in || process.stdin, this.out = opts.out || process.stdout, this.onRender = (opts.onRender || (() => {
        })).bind(this);
        let rl = readline.createInterface(this.in);
        readline.emitKeypressEvents(this.in, rl), this.in.isTTY && this.in.setRawMode(!0);
        let keypress = (str, key) => {
          let a = action(key);
          a === !1 ? this._ && this._(str, key) : typeof this[a] == "function" ? this[a](key) : this.bell();
        };
        this.close = () => {
          this.out.write(cursor.show), this.in.removeListener("keypress", keypress), this.in.isTTY && this.in.setRawMode(!1), rl.close(), this.emit(this.aborted ? "abort" : "submit", this.value), this.closed = !0;
        }, this.in.on("keypress", keypress);
      }
      fire() {
        this.emit("state", {
          value: this.value,
          aborted: !!this.aborted
        });
      }
      bell() {
        this.out.write(beep);
      }
      render() {
        this.onRender(color), this.firstRender && (this.firstRender = !1);
      }
    };
    module2.exports = Prompt;
  }
});

// ../../node_modules/prompts/dist/elements/text.js
var require_text = __commonJS({
  "../../node_modules/prompts/dist/elements/text.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg), value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      info.done ? resolve7(value) : Promise.resolve(value).then(_next, _throw);
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur(), Prompt = require_prompt(), _require = require_src(), cursor = _require.cursor, _require2 = require_util2(), style = _require2.style, clear = _require2.clear, strip = _require2.strip, figures = _require2.figures, TextPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.transform = style.render(opts.style), this.scale = this.transform.scale, this.msg = opts.message, this.initial = opts.initial || "", this.validator = opts.validate || (() => !0), this.value = "", this.errorMsg = opts.error || "Please Enter A Valid Value", this.cursor = +!!this.initial, this.clear = clear(""), this.render();
      }
      set value(v) {
        !v && this.initial ? (this.placeholder = !0, this.rendered = color.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.rendered = this.transform.render(v)), this._value = v, this.fire();
      }
      get value() {
        return this._value;
      }
      reset() {
        this.value = "", this.cursor = +!!this.initial, this.fire(), this.render();
      }
      abort() {
        this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      validate() {
        var _this = this;
        return _asyncToGenerator(function* () {
          let valid = yield _this.validator(_this.value);
          typeof valid == "string" && (_this.errorMsg = valid, valid = !1), _this.error = !valid;
        })();
      }
      submit() {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          if (_this2.value = _this2.value || _this2.initial, yield _this2.validate(), _this2.error) {
            _this2.red = !0, _this2.fire(), _this2.render();
            return;
          }
          _this2.done = !0, _this2.aborted = !1, _this2.fire(), _this2.render(), _this2.out.write(`
`), _this2.close();
        })();
      }
      next() {
        if (!this.placeholder)
          return this.bell();
        this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
      }
      moveCursor(n) {
        this.placeholder || (this.cursor = this.cursor + n);
      }
      _(c, key) {
        let s1 = this.value.slice(0, this.cursor), s2 = this.value.slice(this.cursor);
        this.value = `${s1}${c}${s2}`, this.red = !1, this.cursor = this.placeholder ? 0 : s1.length + 1, this.render();
      }
      delete() {
        if (this.cursor === 0)
          return this.bell();
        let s1 = this.value.slice(0, this.cursor - 1), s2 = this.value.slice(this.cursor);
        this.value = `${s1}${s2}`, this.red = !1, this.moveCursor(-1), this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
          return this.bell();
        let s1 = this.value.slice(0, this.cursor), s2 = this.value.slice(this.cursor + 1);
        this.value = `${s1}${s2}`, this.red = !1, this.render();
      }
      first() {
        this.cursor = 0, this.render();
      }
      last() {
        this.cursor = this.value.length, this.render();
      }
      left() {
        if (this.cursor <= 0 || this.placeholder)
          return this.bell();
        this.moveCursor(-1), this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
          return this.bell();
        this.moveCursor(1), this.render();
      }
      render() {
        if (this.closed)
          return;
        super.render();
        let erase = (this.lines ? cursor.down(this.lines) : "") + this.clear;
        this.lines = 0;
        let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.red ? color.red(this.rendered) : this.rendered].join(" "), error = "";
        if (this.error) {
          let lines = this.errorMsg.split(`
`);
          error += lines.reduce((a, l, i) => a += `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ""), this.lines = lines.length;
        }
        let position = "";
        this.lines && (position += cursor.up(this.lines), position += cursor.left + cursor.to(strip(prompt).length)), position += cursor.move(this.placeholder ? -this.initial.length * this.scale : -this.rendered.length + this.cursor * this.scale), this.out.write(erase + prompt + error + position), this.clear = clear(prompt + error);
      }
    };
    module2.exports = TextPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/select.js
var require_select = __commonJS({
  "../../node_modules/prompts/dist/elements/select.js"(exports2, module2) {
    "use strict";
    var color = require_kleur(), Prompt = require_prompt(), _require = require_util2(), style = _require.style, clear = _require.clear, figures = _require.figures, _require2 = require_src(), erase = _require2.erase, cursor = _require2.cursor, SelectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.msg = opts.message, this.hint = opts.hint || "- Use arrow-keys. Return to submit.", this.warn = opts.warn || "- This option is disabled", this.cursor = opts.initial || 0, this.choices = opts.choices.map((ch, idx) => (typeof ch == "string" && (ch = {
          title: ch,
          value: idx
        }), {
          title: ch && (ch.title || ch.value || ch),
          value: ch && (ch.value || idx),
          selected: ch && ch.selected,
          disabled: ch && ch.disabled
        })), this.value = (this.choices[this.cursor] || {}).value, this.clear = clear(""), this.render();
      }
      moveCursor(n) {
        this.cursor = n, this.value = this.choices[n].value, this.fire();
      }
      reset() {
        this.moveCursor(0), this.fire(), this.render();
      }
      abort() {
        this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      submit() {
        this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
      }
      first() {
        this.moveCursor(0), this.render();
      }
      last() {
        this.moveCursor(this.choices.length - 1), this.render();
      }
      up() {
        if (this.cursor === 0)
          return this.bell();
        this.moveCursor(this.cursor - 1), this.render();
      }
      down() {
        if (this.cursor === this.choices.length - 1)
          return this.bell();
        this.moveCursor(this.cursor + 1), this.render();
      }
      next() {
        this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
      }
      _(c, key) {
        if (c === " ")
          return this.submit();
      }
      get selection() {
        return this.choices[this.cursor];
      }
      render() {
        this.closed || (this.firstRender ? this.out.write(cursor.hide) : this.out.write(erase.lines(this.choices.length + 1)), super.render(), this.out.write([style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(!1), this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)].join(" ")), this.done || this.out.write(`
` + this.choices.map((v, i) => {
          let title, prefix;
          return v.disabled ? (title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title), prefix = this.cursor === i ? color.bold().gray(figures.pointer) + " " : "  ") : (title = this.cursor === i ? color.cyan().underline(v.title) : v.title, prefix = this.cursor === i ? color.cyan(figures.pointer) + " " : "  "), `${prefix} ${title}`;
        }).join(`
`)));
      }
    };
    module2.exports = SelectPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/toggle.js
var require_toggle = __commonJS({
  "../../node_modules/prompts/dist/elements/toggle.js"(exports2, module2) {
    "use strict";
    var color = require_kleur(), Prompt = require_prompt(), _require = require_util2(), style = _require.style, clear = _require.clear, _require2 = require_src(), cursor = _require2.cursor, erase = _require2.erase, TogglePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.msg = opts.message, this.value = !!opts.initial, this.active = opts.active || "on", this.inactive = opts.inactive || "off", this.initialValue = this.value, this.render();
      }
      reset() {
        this.value = this.initialValue, this.fire(), this.render();
      }
      abort() {
        this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      submit() {
        this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      deactivate() {
        if (this.value === !1)
          return this.bell();
        this.value = !1, this.render();
      }
      activate() {
        if (this.value === !0)
          return this.bell();
        this.value = !0, this.render();
      }
      delete() {
        this.deactivate();
      }
      left() {
        this.deactivate();
      }
      right() {
        this.activate();
      }
      down() {
        this.deactivate();
      }
      up() {
        this.activate();
      }
      next() {
        this.value = !this.value, this.fire(), this.render();
      }
      _(c, key) {
        if (c === " ")
          this.value = !this.value;
        else if (c === "1")
          this.value = !0;
        else if (c === "0")
          this.value = !1;
        else
          return this.bell();
        this.render();
      }
      render() {
        this.closed || (this.firstRender && this.out.write(cursor.hide), super.render(), this.out.write(erase.lines(this.first ? 1 : this.msg.split(/\n/g).length) + cursor.to(0) + [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.value ? this.inactive : color.cyan().underline(this.inactive), color.gray("/"), this.value ? color.cyan().underline(this.active) : this.active].join(" ")));
      }
    };
    module2.exports = TogglePrompt;
  }
});

// ../../node_modules/prompts/dist/dateparts/datepart.js
var require_datepart = __commonJS({
  "../../node_modules/prompts/dist/dateparts/datepart.js"(exports2, module2) {
    "use strict";
    var DatePart = class _DatePart {
      constructor({
        token,
        date,
        parts,
        locales
      }) {
        this.token = token, this.date = date || /* @__PURE__ */ new Date(), this.parts = parts || [this], this.locales = locales || {};
      }
      up() {
      }
      down() {
      }
      next() {
        let currentIdx = this.parts.indexOf(this);
        return this.parts.find((part, idx) => idx > currentIdx && part instanceof _DatePart);
      }
      setTo(val) {
      }
      prev() {
        let parts = [].concat(this.parts).reverse(), currentIdx = parts.indexOf(this);
        return parts.find((part, idx) => idx > currentIdx && part instanceof _DatePart);
      }
      toString() {
        return String(this.date);
      }
    };
    module2.exports = DatePart;
  }
});

// ../../node_modules/prompts/dist/dateparts/meridiem.js
var require_meridiem = __commonJS({
  "../../node_modules/prompts/dist/dateparts/meridiem.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart(), Meridiem = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours((this.date.getHours() + 12) % 24);
      }
      down() {
        this.up();
      }
      toString() {
        let meridiem = this.date.getHours() > 12 ? "pm" : "am";
        return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
      }
    };
    module2.exports = Meridiem;
  }
});

// ../../node_modules/prompts/dist/dateparts/day.js
var require_day = __commonJS({
  "../../node_modules/prompts/dist/dateparts/day.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart(), pos = (n) => (n = n % 10, n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th"), Day = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setDate(this.date.getDate() + 1);
      }
      down() {
        this.date.setDate(this.date.getDate() - 1);
      }
      setTo(val) {
        this.date.setDate(parseInt(val.substr(-2)));
      }
      toString() {
        let date = this.date.getDate(), day = this.date.getDay();
        return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
      }
    };
    module2.exports = Day;
  }
});

// ../../node_modules/prompts/dist/dateparts/hours.js
var require_hours = __commonJS({
  "../../node_modules/prompts/dist/dateparts/hours.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart(), Hours = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours(this.date.getHours() + 1);
      }
      down() {
        this.date.setHours(this.date.getHours() - 1);
      }
      setTo(val) {
        this.date.setHours(parseInt(val.substr(-2)));
      }
      toString() {
        let hours = this.date.getHours();
        return /h/.test(this.token) && (hours = hours % 12 || 12), this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
      }
    };
    module2.exports = Hours;
  }
});

// ../../node_modules/prompts/dist/dateparts/milliseconds.js
var require_milliseconds = __commonJS({
  "../../node_modules/prompts/dist/dateparts/milliseconds.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart(), Milliseconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMilliseconds(this.date.getMilliseconds() + 1);
      }
      down() {
        this.date.setMilliseconds(this.date.getMilliseconds() - 1);
      }
      setTo(val) {
        this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
      }
      toString() {
        return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
      }
    };
    module2.exports = Milliseconds;
  }
});

// ../../node_modules/prompts/dist/dateparts/minutes.js
var require_minutes = __commonJS({
  "../../node_modules/prompts/dist/dateparts/minutes.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart(), Minutes = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMinutes(this.date.getMinutes() + 1);
      }
      down() {
        this.date.setMinutes(this.date.getMinutes() - 1);
      }
      setTo(val) {
        this.date.setMinutes(parseInt(val.substr(-2)));
      }
      toString() {
        let m = this.date.getMinutes();
        return this.token.length > 1 ? String(m).padStart(2, "0") : m;
      }
    };
    module2.exports = Minutes;
  }
});

// ../../node_modules/prompts/dist/dateparts/month.js
var require_month = __commonJS({
  "../../node_modules/prompts/dist/dateparts/month.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart(), Month = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMonth(this.date.getMonth() + 1);
      }
      down() {
        this.date.setMonth(this.date.getMonth() - 1);
      }
      setTo(val) {
        val = parseInt(val.substr(-2)) - 1, this.date.setMonth(val < 0 ? 0 : val);
      }
      toString() {
        let month = this.date.getMonth(), tl = this.token.length;
        return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
      }
    };
    module2.exports = Month;
  }
});

// ../../node_modules/prompts/dist/dateparts/seconds.js
var require_seconds = __commonJS({
  "../../node_modules/prompts/dist/dateparts/seconds.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart(), Seconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setSeconds(this.date.getSeconds() + 1);
      }
      down() {
        this.date.setSeconds(this.date.getSeconds() - 1);
      }
      setTo(val) {
        this.date.setSeconds(parseInt(val.substr(-2)));
      }
      toString() {
        let s = this.date.getSeconds();
        return this.token.length > 1 ? String(s).padStart(2, "0") : s;
      }
    };
    module2.exports = Seconds;
  }
});

// ../../node_modules/prompts/dist/dateparts/year.js
var require_year = __commonJS({
  "../../node_modules/prompts/dist/dateparts/year.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart(), Year = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setFullYear(this.date.getFullYear() + 1);
      }
      down() {
        this.date.setFullYear(this.date.getFullYear() - 1);
      }
      setTo(val) {
        this.date.setFullYear(val.substr(-4));
      }
      toString() {
        let year = String(this.date.getFullYear()).padStart(4, "0");
        return this.token.length === 2 ? year.substr(-2) : year;
      }
    };
    module2.exports = Year;
  }
});

// ../../node_modules/prompts/dist/dateparts/index.js
var require_dateparts = __commonJS({
  "../../node_modules/prompts/dist/dateparts/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      DatePart: require_datepart(),
      Meridiem: require_meridiem(),
      Day: require_day(),
      Hours: require_hours(),
      Milliseconds: require_milliseconds(),
      Minutes: require_minutes(),
      Month: require_month(),
      Seconds: require_seconds(),
      Year: require_year()
    };
  }
});

// ../../node_modules/prompts/dist/elements/date.js
var require_date = __commonJS({
  "../../node_modules/prompts/dist/elements/date.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg), value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      info.done ? resolve7(value) : Promise.resolve(value).then(_next, _throw);
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur(), Prompt = require_prompt(), _require = require_util2(), style = _require.style, clear = _require.clear, figures = _require.figures, strip = _require.strip, _require2 = require_src(), erase = _require2.erase, cursor = _require2.cursor, _require3 = require_dateparts(), DatePart = _require3.DatePart, Meridiem = _require3.Meridiem, Day = _require3.Day, Hours = _require3.Hours, Milliseconds = _require3.Milliseconds, Minutes = _require3.Minutes, Month = _require3.Month, Seconds = _require3.Seconds, Year = _require3.Year, regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g, regexGroups = {
      1: ({
        token
      }) => token.replace(/\\(.)/g, "$1"),
      2: (opts) => new Day(opts),
      // Day // TODO
      3: (opts) => new Month(opts),
      // Month
      4: (opts) => new Year(opts),
      // Year
      5: (opts) => new Meridiem(opts),
      // AM/PM // TODO (special)
      6: (opts) => new Hours(opts),
      // Hours
      7: (opts) => new Minutes(opts),
      // Minutes
      8: (opts) => new Seconds(opts),
      // Seconds
      9: (opts) => new Milliseconds(opts)
      // Fractional seconds
    }, dfltLocales = {
      months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
      monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
      weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
      weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
      /**
       * DatePrompt Base Element
       * @param {Object} opts Options
       * @param {String} opts.message Message
       * @param {Number} [opts.initial] Index of default value
       * @param {String} [opts.mask] The format mask
       * @param {object} [opts.locales] The date locales
       * @param {String} [opts.error] The error message shown on invalid value
       * @param {Function} [opts.validate] Function to validate the submitted value
       * @param {Stream} [opts.stdin] The Readable stream to listen to
       * @param {Stream} [opts.stdout] The Writable stream to write readline data to
       */
    }, DatePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.msg = opts.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(dfltLocales, opts.locales), this._date = opts.initial || /* @__PURE__ */ new Date(), this.errorMsg = opts.error || "Please Enter A Valid Value", this.validator = opts.validate || (() => !0), this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss", this.clear = clear(""), this.render();
      }
      get value() {
        return this.date;
      }
      get date() {
        return this._date;
      }
      set date(date) {
        date && this._date.setTime(date.getTime());
      }
      set mask(mask) {
        let result;
        for (this.parts = []; result = regex.exec(mask); ) {
          let match2 = result.shift(), idx = result.findIndex((gr) => gr != null);
          this.parts.push(idx in regexGroups ? regexGroups[idx]({
            token: result[idx] || match2,
            date: this.date,
            parts: this.parts,
            locales: this.locales
          }) : result[idx] || match2);
        }
        let parts = this.parts.reduce((arr, i) => (typeof i == "string" && typeof arr[arr.length - 1] == "string" ? arr[arr.length - 1] += i : arr.push(i), arr), []);
        this.parts.splice(0), this.parts.push(...parts), this.reset();
      }
      moveCursor(n) {
        this.typed = "", this.cursor = n, this.fire();
      }
      reset() {
        this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart)), this.fire(), this.render();
      }
      abort() {
        this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      validate() {
        var _this = this;
        return _asyncToGenerator(function* () {
          let valid = yield _this.validator(_this.value);
          typeof valid == "string" && (_this.errorMsg = valid, valid = !1), _this.error = !valid;
        })();
      }
      submit() {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          if (yield _this2.validate(), _this2.error) {
            _this2.color = "red", _this2.fire(), _this2.render();
            return;
          }
          _this2.done = !0, _this2.aborted = !1, _this2.fire(), _this2.render(), _this2.out.write(`
`), _this2.close();
        })();
      }
      up() {
        this.typed = "", this.parts[this.cursor].up(), this.render();
      }
      down() {
        this.typed = "", this.parts[this.cursor].down(), this.render();
      }
      left() {
        let prev = this.parts[this.cursor].prev();
        if (prev == null)
          return this.bell();
        this.moveCursor(this.parts.indexOf(prev)), this.render();
      }
      right() {
        let next = this.parts[this.cursor].next();
        if (next == null)
          return this.bell();
        this.moveCursor(this.parts.indexOf(next)), this.render();
      }
      next() {
        let next = this.parts[this.cursor].next();
        this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart)), this.render();
      }
      _(c) {
        /\d/.test(c) && (this.typed += c, this.parts[this.cursor].setTo(this.typed), this.render());
      }
      render() {
        if (this.closed)
          return;
        this.firstRender ? this.out.write(cursor.hide) : this.out.write(erase.lines(1)), super.render();
        let clear2 = erase.line + (this.lines ? erase.down(this.lines) : "") + cursor.to(0);
        this.lines = 0;
        let error = "";
        if (this.error) {
          let lines = this.errorMsg.split(`
`);
          error = lines.reduce((a, l, i) => a + `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ""), this.lines = lines.length;
        }
        let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(!1), this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")].join(" "), position = "";
        this.lines && (position += cursor.up(this.lines), position += cursor.left + cursor.to(strip(prompt).length)), this.out.write(clear2 + prompt + error + position);
      }
    };
    module2.exports = DatePrompt;
  }
});

// ../../node_modules/prompts/dist/elements/number.js
var require_number = __commonJS({
  "../../node_modules/prompts/dist/elements/number.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg), value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      info.done ? resolve7(value) : Promise.resolve(value).then(_next, _throw);
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur(), Prompt = require_prompt(), _require = require_src(), cursor = _require.cursor, erase = _require.erase, _require2 = require_util2(), style = _require2.style, clear = _require2.clear, figures = _require2.figures, strip = _require2.strip, isNumber = /[0-9]/, isDef = (any) => any !== void 0, round = (number, precision) => {
      let factor = Math.pow(10, precision);
      return Math.round(number * factor) / factor;
    }, NumberPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.transform = style.render(opts.style), this.msg = opts.message, this.initial = isDef(opts.initial) ? opts.initial : "", this.float = !!opts.float, this.round = opts.round || 2, this.inc = opts.increment || 1, this.min = isDef(opts.min) ? opts.min : -1 / 0, this.max = isDef(opts.max) ? opts.max : 1 / 0, this.errorMsg = opts.error || "Please Enter A Valid Value", this.validator = opts.validate || (() => !0), this.color = "cyan", this.value = "", this.typed = "", this.lastHit = 0, this.render();
      }
      set value(v) {
        !v && v !== 0 ? (this.placeholder = !0, this.rendered = color.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder = !1, this.rendered = this.transform.render(`${round(v, this.round)}`), this._value = round(v, this.round)), this.fire();
      }
      get value() {
        return this._value;
      }
      parse(x) {
        return this.float ? parseFloat(x) : parseInt(x);
      }
      valid(c) {
        return c === "-" || c === "." && this.float || isNumber.test(c);
      }
      reset() {
        this.typed = "", this.value = "", this.fire(), this.render();
      }
      abort() {
        let x = this.value;
        this.value = x !== "" ? x : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      validate() {
        var _this = this;
        return _asyncToGenerator(function* () {
          let valid = yield _this.validator(_this.value);
          typeof valid == "string" && (_this.errorMsg = valid, valid = !1), _this.error = !valid;
        })();
      }
      submit() {
        var _this2 = this;
        return _asyncToGenerator(function* () {
          if (yield _this2.validate(), _this2.error) {
            _this2.color = "red", _this2.fire(), _this2.render();
            return;
          }
          let x = _this2.value;
          _this2.value = x !== "" ? x : _this2.initial, _this2.done = !0, _this2.aborted = !1, _this2.error = !1, _this2.fire(), _this2.render(), _this2.out.write(`
`), _this2.close();
        })();
      }
      up() {
        if (this.typed = "", this.value >= this.max)
          return this.bell();
        this.value += this.inc, this.color = "cyan", this.fire(), this.render();
      }
      down() {
        if (this.typed = "", this.value <= this.min)
          return this.bell();
        this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
      }
      delete() {
        let val = this.value.toString();
        if (val.length === 0)
          return this.bell();
        this.value = this.parse(val = val.slice(0, -1)) || "", this.color = "cyan", this.fire(), this.render();
      }
      next() {
        this.value = this.initial, this.fire(), this.render();
      }
      _(c, key) {
        if (!this.valid(c))
          return this.bell();
        let now = Date.now();
        if (now - this.lastHit > 1e3 && (this.typed = ""), this.typed += c, this.lastHit = now, this.color = "cyan", c === ".")
          return this.fire();
        this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.value = this.min), this.fire(), this.render();
      }
      render() {
        if (this.closed)
          return;
        super.render();
        let clear2 = erase.line + (this.lines ? erase.down(this.lines) : "") + cursor.to(0);
        this.lines = 0;
        let error = "";
        if (this.error) {
          let lines = this.errorMsg.split(`
`);
          error += lines.reduce((a, l, i) => a + `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ""), this.lines = lines.length;
        }
        let underline = !this.done || !this.done && !this.placeholder, prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), underline ? color[this.color]().underline(this.rendered) : this.rendered].join(" "), position = "";
        this.lines && (position += cursor.up(this.lines), position += cursor.left + cursor.to(strip(prompt).length)), this.out.write(clear2 + prompt + error + position);
      }
    };
    module2.exports = NumberPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/multiselect.js
var require_multiselect = __commonJS({
  "../../node_modules/prompts/dist/elements/multiselect.js"(exports2, module2) {
    "use strict";
    var color = require_kleur(), _require = require_src(), cursor = _require.cursor, Prompt = require_prompt(), _require2 = require_util2(), clear = _require2.clear, figures = _require2.figures, style = _require2.style, MultiselectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.msg = opts.message, this.cursor = opts.cursor || 0, this.scrollIndex = opts.cursor || 0, this.hint = opts.hint || "", this.warn = opts.warn || "- This option is disabled -", this.minSelected = opts.min, this.showMinError = !1, this.maxChoices = opts.max, this.value = opts.choices.map((ch, idx) => (typeof ch == "string" && (ch = {
          title: ch,
          value: idx
        }), {
          title: ch && (ch.title || ch.value || ch),
          value: ch && (ch.value || idx),
          selected: ch && ch.selected,
          disabled: ch && ch.disabled
        })), this.clear = clear(""), opts.overrideRender || this.render();
      }
      reset() {
        this.value.map((v) => !v.selected), this.cursor = 0, this.fire(), this.render();
      }
      selected() {
        return this.value.filter((v) => v.selected);
      }
      abort() {
        this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      submit() {
        let selected = this.value.filter((e) => e.selected);
        this.minSelected && selected.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
      }
      first() {
        this.cursor = 0, this.render();
      }
      last() {
        this.cursor = this.value.length - 1, this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.value.length, this.render();
      }
      up() {
        this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
      }
      down() {
        this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
      }
      left() {
        this.value[this.cursor].selected = !1, this.render();
      }
      right() {
        if (this.value.filter((e) => e.selected).length >= this.maxChoices)
          return this.bell();
        this.value[this.cursor].selected = !0, this.render();
      }
      handleSpaceToggle() {
        let v = this.value[this.cursor];
        if (v.selected)
          v.selected = !1, this.render();
        else {
          if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices)
            return this.bell();
          v.selected = !0, this.render();
        }
      }
      _(c, key) {
        if (c === " ")
          this.handleSpaceToggle();
        else
          return this.bell();
      }
      renderInstructions() {
        return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    enter/return: Complete answer
    `;
      }
      renderOption(cursor2, v, i) {
        let title;
        return v.disabled ? title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title) : title = cursor2 === i ? color.cyan().underline(v.title) : v.title, (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
      }
      // shared with autocompleteMultiselect
      paginateOptions(options) {
        let c = this.cursor, styledOptions = options.map((v, i) => this.renderOption(c, v, i)), numOfOptionsToRender = 10, scopedOptions = styledOptions, hint = "";
        if (styledOptions.length === 0)
          return color.red("No matches for this query.");
        if (styledOptions.length > numOfOptionsToRender) {
          let startIndex = c - numOfOptionsToRender / 2, endIndex = c + numOfOptionsToRender / 2;
          startIndex < 0 ? (startIndex = 0, endIndex = numOfOptionsToRender) : endIndex > options.length && (endIndex = options.length, startIndex = endIndex - numOfOptionsToRender), scopedOptions = styledOptions.slice(startIndex, endIndex), hint = color.dim("(Move up and down to reveal more choices)");
        }
        return `
` + scopedOptions.join(`
`) + `
` + hint;
      }
      // shared with autocomleteMultiselect
      renderOptions(options) {
        return this.done ? "" : this.paginateOptions(options);
      }
      renderDoneOrInstructions() {
        if (this.done)
          return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
        let output = [color.gray(this.hint), this.renderInstructions()];
        return this.value[this.cursor].disabled && output.push(color.yellow(this.warn)), output.join(" ");
      }
      render() {
        if (this.closed)
          return;
        this.firstRender && this.out.write(cursor.hide), super.render();
        let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
        this.showMinError && (prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), prompt += this.renderOptions(this.value), this.out.write(this.clear + prompt), this.clear = clear(prompt);
      }
    };
    module2.exports = MultiselectPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/autocomplete.js
var require_autocomplete = __commonJS({
  "../../node_modules/prompts/dist/elements/autocomplete.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg), value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      info.done ? resolve7(value) : Promise.resolve(value).then(_next, _throw);
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var color = require_kleur(), Prompt = require_prompt(), _require = require_src(), cursor = _require.cursor, _require2 = require_util2(), style = _require2.style, clear = _require2.clear, figures = _require2.figures, strip = _require2.strip, getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]), getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]), getIndex = (arr, valOrTitle) => {
      let index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
      return index > -1 ? index : void 0;
    }, AutocompletePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.msg = opts.message, this.suggest = opts.suggest, this.choices = opts.choices, this.initial = typeof opts.initial == "number" ? opts.initial : getIndex(opts.choices, opts.initial), this.select = this.initial || opts.cursor || 0, this.fallback = opts.fallback || (opts.initial !== void 0 ? `${figures.pointerSmall} ${getTitle(this.choices, this.initial)}` : `${figures.pointerSmall} ${opts.noMatches || "no matches found"}`), this.suggestions = [[]], this.page = 0, this.input = "", this.limit = opts.limit || 10, this.cursor = 0, this.transform = style.render(opts.style), this.scale = this.transform.scale, this.render = this.render.bind(this), this.complete = this.complete.bind(this), this.clear = clear(""), this.complete(this.render), this.render();
      }
      moveSelect(i) {
        this.select = i, this.suggestions[this.page].length > 0 ? this.value = getVal(this.suggestions[this.page], i) : this.value = this.initial !== void 0 ? getVal(this.choices, this.initial) : null, this.fire();
      }
      complete(cb) {
        var _this = this;
        return _asyncToGenerator(function* () {
          let p = _this.completing = _this.suggest(_this.input, _this.choices), suggestions = yield p;
          if (_this.completing !== p)
            return;
          if (_this.suggestions = suggestions.map((s, i, arr) => ({
            title: getTitle(arr, i),
            value: getVal(arr, i)
          })).reduce((arr, sug) => (arr[arr.length - 1].length < _this.limit ? arr[arr.length - 1].push(sug) : arr.push([sug]), arr), [[]]), _this.isFallback = !1, _this.completing = !1, _this.suggestions[_this.page] || (_this.page = 0), !_this.suggestions.length && _this.fallback) {
            let index = getIndex(_this.choices, _this.fallback);
            _this.suggestions = [[]], index !== void 0 && _this.suggestions[0].push({
              title: getTitle(_this.choices, index),
              value: getVal(_this.choices, index)
            }), _this.isFallback = !0;
          }
          let l = Math.max(suggestions.length - 1, 0);
          _this.moveSelect(Math.min(l, _this.select)), cb && cb();
        })();
      }
      reset() {
        this.input = "", this.complete(() => {
          this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
        }), this.render();
      }
      abort() {
        this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      submit() {
        this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      _(c, key) {
        let s1 = this.input.slice(0, this.cursor), s2 = this.input.slice(this.cursor);
        this.input = `${s1}${c}${s2}`, this.cursor = s1.length + 1, this.complete(this.render), this.render();
      }
      delete() {
        if (this.cursor === 0)
          return this.bell();
        let s1 = this.input.slice(0, this.cursor - 1), s2 = this.input.slice(this.cursor);
        this.input = `${s1}${s2}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length)
          return this.bell();
        let s1 = this.input.slice(0, this.cursor), s2 = this.input.slice(this.cursor + 1);
        this.input = `${s1}${s2}`, this.complete(this.render), this.render();
      }
      first() {
        this.moveSelect(0), this.render();
      }
      last() {
        this.moveSelect(this.suggestions[this.page].length - 1), this.render();
      }
      up() {
        if (this.select <= 0)
          return this.bell();
        this.moveSelect(this.select - 1), this.render();
      }
      down() {
        if (this.select >= this.suggestions[this.page].length - 1)
          return this.bell();
        this.moveSelect(this.select + 1), this.render();
      }
      next() {
        this.select === this.suggestions[this.page].length - 1 ? (this.page = (this.page + 1) % this.suggestions.length, this.moveSelect(0)) : this.moveSelect(this.select + 1), this.render();
      }
      nextPage() {
        if (this.page >= this.suggestions.length - 1)
          return this.bell();
        this.page++, this.moveSelect(0), this.render();
      }
      prevPage() {
        if (this.page <= 0)
          return this.bell();
        this.page--, this.moveSelect(0), this.render();
      }
      left() {
        if (this.cursor <= 0)
          return this.bell();
        this.cursor = this.cursor - 1, this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length)
          return this.bell();
        this.cursor = this.cursor + 1, this.render();
      }
      render() {
        if (this.closed)
          return;
        super.render(), this.lineCount && this.out.write(cursor.down(this.lineCount));
        let prompt = color.bold(`${style.symbol(this.done, this.aborted)} ${this.msg} `) + `${style.delimiter(this.completing)} `, length = strip(prompt).length;
        if (this.done && this.suggestions[this.page][this.select] ? prompt += `${this.suggestions[this.page][this.select].title}` : (this.rendered = `${this.transform.render(this.input)}`, length += this.rendered.length, prompt += this.rendered), !this.done) {
          this.lineCount = this.suggestions[this.page].length;
          let suggestions = this.suggestions[this.page].reduce((acc, item, i) => acc + `
${i === this.select ? color.cyan(item.title) : item.title}`, "");
          if (suggestions && !this.isFallback)
            prompt += suggestions, this.suggestions.length > 1 && (this.lineCount++, prompt += color.blue(`
Page ${this.page + 1}/${this.suggestions.length}`));
          else {
            let fallbackIndex = getIndex(this.choices, this.fallback), fallbackTitle = fallbackIndex !== void 0 ? getTitle(this.choices, fallbackIndex) : this.fallback;
            prompt += `
${color.gray(fallbackTitle)}`, this.lineCount++;
          }
        }
        if (this.out.write(this.clear + prompt), this.clear = clear(prompt), this.lineCount && !this.done) {
          let pos = cursor.up(this.lineCount);
          pos += cursor.left + cursor.to(length), pos += cursor.move(-this.rendered.length + this.cursor * this.scale), this.out.write(pos);
        }
      }
    };
    module2.exports = AutocompletePrompt;
  }
});

// ../../node_modules/prompts/dist/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect = __commonJS({
  "../../node_modules/prompts/dist/elements/autocompleteMultiselect.js"(exports2, module2) {
    "use strict";
    var color = require_kleur(), _require = require_src(), cursor = _require.cursor, MultiselectPrompt = require_multiselect(), _require2 = require_util2(), clear = _require2.clear, style = _require2.style, figures = _require2.figures, AutocompleteMultiselectPrompt = class extends MultiselectPrompt {
      constructor(opts = {}) {
        opts.overrideRender = !0, super(opts), this.inputValue = "", this.clear = clear(""), this.filteredOptions = this.value, this.render();
      }
      last() {
        this.cursor = this.filteredOptions.length - 1, this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
      }
      up() {
        this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
      }
      down() {
        this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
      }
      left() {
        this.filteredOptions[this.cursor].selected = !1, this.render();
      }
      right() {
        if (this.value.filter((e) => e.selected).length >= this.maxChoices)
          return this.bell();
        this.filteredOptions[this.cursor].selected = !0, this.render();
      }
      delete() {
        this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
      }
      updateFilteredOptions() {
        let currentHighlight = this.filteredOptions[this.cursor];
        this.filteredOptions = this.value.filter((v) => this.inputValue ? !!(typeof v.title == "string" && v.title.toLowerCase().includes(this.inputValue.toLowerCase()) || typeof v.value == "string" && v.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
        let newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
        this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex, this.render();
      }
      handleSpaceToggle() {
        let v = this.filteredOptions[this.cursor];
        if (v.selected)
          v.selected = !1, this.render();
        else {
          if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices)
            return this.bell();
          v.selected = !0, this.render();
        }
      }
      handleInputChange(c) {
        this.inputValue = this.inputValue + c, this.updateFilteredOptions();
      }
      _(c, key) {
        c === " " ? this.handleSpaceToggle() : this.handleInputChange(c);
      }
      renderInstructions() {
        return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
    `;
      }
      renderCurrentInput() {
        return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
      }
      renderOption(cursor2, v, i) {
        let title;
        return v.disabled ? title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title) : title = cursor2 === i ? color.cyan().underline(v.title) : v.title, (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
      }
      renderDoneOrInstructions() {
        if (this.done)
          return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
        let output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
        return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && output.push(color.yellow(this.warn)), output.join(" ");
      }
      render() {
        if (this.closed)
          return;
        this.firstRender && this.out.write(cursor.hide), super.render();
        let prompt = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
        this.showMinError && (prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), prompt += this.renderOptions(this.filteredOptions), this.out.write(this.clear + prompt), this.clear = clear(prompt);
      }
    };
    module2.exports = AutocompleteMultiselectPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/confirm.js
var require_confirm = __commonJS({
  "../../node_modules/prompts/dist/elements/confirm.js"(exports2, module2) {
    "use strict";
    var color = require_kleur(), Prompt = require_prompt(), _require = require_util2(), style = _require.style, _require2 = require_src(), erase = _require2.erase, cursor = _require2.cursor, ConfirmPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.msg = opts.message, this.value = opts.initial, this.initialValue = !!opts.initial, this.yesMsg = opts.yes || "yes", this.yesOption = opts.yesOption || "(Y/n)", this.noMsg = opts.no || "no", this.noOption = opts.noOption || "(y/N)", this.render();
      }
      reset() {
        this.value = this.initialValue, this.fire(), this.render();
      }
      abort() {
        this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      submit() {
        this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      _(c, key) {
        return c.toLowerCase() === "y" ? (this.value = !0, this.submit()) : c.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.bell();
      }
      render() {
        this.closed || (this.firstRender && this.out.write(cursor.hide), super.render(), this.out.write(erase.line + cursor.to(0) + [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)].join(" ")));
      }
    };
    module2.exports = ConfirmPrompt;
  }
});

// ../../node_modules/prompts/dist/elements/index.js
var require_elements = __commonJS({
  "../../node_modules/prompts/dist/elements/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      TextPrompt: require_text(),
      SelectPrompt: require_select(),
      TogglePrompt: require_toggle(),
      DatePrompt: require_date(),
      NumberPrompt: require_number(),
      MultiselectPrompt: require_multiselect(),
      AutocompletePrompt: require_autocomplete(),
      AutocompleteMultiselectPrompt: require_autocompleteMultiselect(),
      ConfirmPrompt: require_confirm()
    };
  }
});

// ../../node_modules/prompts/dist/prompts.js
var require_prompts = __commonJS({
  "../../node_modules/prompts/dist/prompts.js"(exports2) {
    "use strict";
    var $2 = exports2, el = require_elements(), noop2 = (v) => v;
    function toPrompt(type, args, opts = {}) {
      return new Promise((res, rej) => {
        let p = new el[type](args), onAbort = opts.onAbort || noop2, onSubmit = opts.onSubmit || noop2;
        p.on("state", args.onState || noop2), p.on("submit", (x) => res(onSubmit(x))), p.on("abort", (x) => rej(onAbort(x)));
      });
    }
    $2.text = (args) => toPrompt("TextPrompt", args);
    $2.password = (args) => (args.style = "password", $2.text(args));
    $2.invisible = (args) => (args.style = "invisible", $2.text(args));
    $2.number = (args) => toPrompt("NumberPrompt", args);
    $2.date = (args) => toPrompt("DatePrompt", args);
    $2.confirm = (args) => toPrompt("ConfirmPrompt", args);
    $2.list = (args) => {
      let sep2 = args.separator || ",";
      return toPrompt("TextPrompt", args, {
        onSubmit: (str) => str.split(sep2).map((s) => s.trim())
      });
    };
    $2.toggle = (args) => toPrompt("TogglePrompt", args);
    $2.select = (args) => toPrompt("SelectPrompt", args);
    $2.multiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      let toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("MultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    $2.autocompleteMultiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      let toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("AutocompleteMultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    var byTitle = (input, choices) => Promise.resolve(choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase()));
    $2.autocomplete = (args) => (args.suggest = args.suggest || byTitle, args.choices = [].concat(args.choices || []), toPrompt("AutocompletePrompt", args));
  }
});

// ../../node_modules/prompts/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/prompts/dist/index.js"(exports2, module2) {
    "use strict";
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {}, ownKeys = Object.keys(source);
        typeof Object.getOwnPropertySymbols == "function" && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }))), ownKeys.forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      return key in obj ? Object.defineProperty(obj, key, { value, enumerable: !0, configurable: !0, writable: !0 }) : obj[key] = value, obj;
    }
    function asyncGeneratorStep(gen, resolve7, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg), value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      info.done ? resolve7(value) : Promise.resolve(value).then(_next, _throw);
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve7, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve7, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var prompts6 = require_prompts(), passOn = ["suggest", "format", "onState", "validate", "onRender"], noop2 = () => {
    };
    function prompt() {
      return _prompt.apply(this, arguments);
    }
    function _prompt() {
      return _prompt = _asyncToGenerator(function* (questions = [], {
        onSubmit = noop2,
        onCancel = noop2
      } = {}) {
        let answers = {}, override2 = prompt._override || {};
        questions = [].concat(questions);
        let answer, question, quit, name, type, getFormattedAnswer = /* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(function* (question2, answer2, skipValidation = !1) {
            if (!(!skipValidation && question2.validate && question2.validate(answer2) !== !0))
              return question2.format ? yield question2.format(answer2, answers) : answer2;
          });
          return function(_x, _x2) {
            return _ref.apply(this, arguments);
          };
        }();
        var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
        try {
          for (var _iterator = questions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
            question = _step.value;
            var _question = question;
            name = _question.name, type = _question.type;
            for (let key in question) {
              if (passOn.includes(key))
                continue;
              let value = question[key];
              question[key] = typeof value == "function" ? yield value(answer, _objectSpread({}, answers), question) : value;
            }
            if (typeof question.message != "string")
              throw new Error("prompt message is required");
            var _question2 = question;
            if (name = _question2.name, type = _question2.type, !!type) {
              if (prompts6[type] === void 0)
                throw new Error(`prompt type (${type}) is not defined`);
              if (override2[question.name] !== void 0 && (answer = yield getFormattedAnswer(question, override2[question.name]), answer !== void 0)) {
                answers[name] = answer;
                continue;
              }
              try {
                answer = prompt._injected ? getInjectedAnswer(prompt._injected) : yield prompts6[type](question), answers[name] = answer = yield getFormattedAnswer(question, answer, !0), quit = yield onSubmit(question, answer, answers);
              } catch {
                quit = !(yield onCancel(question, answers));
              }
              if (quit)
                return answers;
            }
          }
        } catch (err) {
          _didIteratorError = !0, _iteratorError = err;
        } finally {
          try {
            !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
          } finally {
            if (_didIteratorError)
              throw _iteratorError;
          }
        }
        return answers;
      }), _prompt.apply(this, arguments);
    }
    function getInjectedAnswer(injected) {
      let answer = injected.shift();
      if (answer instanceof Error)
        throw answer;
      return answer;
    }
    function inject(answers) {
      prompt._injected = (prompt._injected || []).concat(answers);
    }
    function override(answers) {
      prompt._override = Object.assign({}, answers);
    }
    module2.exports = Object.assign(prompt, {
      prompt,
      prompts: prompts6,
      inject,
      override
    });
  }
});

// ../../node_modules/prompts/lib/util/action.js
var require_action2 = __commonJS({
  "../../node_modules/prompts/lib/util/action.js"(exports2, module2) {
    "use strict";
    module2.exports = (key) => {
      if (key.ctrl) {
        if (key.name === "a")
          return "first";
        if (key.name === "c" || key.name === "d")
          return "abort";
        if (key.name === "e")
          return "last";
        if (key.name === "g")
          return "reset";
      }
      return key.name === "return" || key.name === "enter" ? "submit" : key.name === "backspace" ? "delete" : key.name === "delete" ? "deleteForward" : key.name === "abort" || key.name === "escape" ? "abort" : key.name === "tab" ? "next" : key.name === "pagedown" ? "nextPage" : key.name === "pageup" ? "prevPage" : key.name === "up" ? "up" : key.name === "down" ? "down" : key.name === "right" ? "right" : key.name === "left" ? "left" : !1;
    };
  }
});

// ../../node_modules/prompts/lib/util/strip.js
var require_strip2 = __commonJS({
  "../../node_modules/prompts/lib/util/strip.js"(exports2, module2) {
    "use strict";
    module2.exports = (str) => {
      let pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
      ].join("|"), RGX = new RegExp(pattern, "g");
      return typeof str == "string" ? str.replace(RGX, "") : str;
    };
  }
});

// ../../node_modules/prompts/lib/util/clear.js
var require_clear2 = __commonJS({
  "../../node_modules/prompts/lib/util/clear.js"(exports2, module2) {
    "use strict";
    var strip = require_strip2(), { erase, cursor } = require_src(), width = (str) => [...strip(str)].length;
    module2.exports = function(prompt, perLine = process.stdout.columns) {
      if (!perLine)
        return erase.line + cursor.to(0);
      let rows = 0, lines = prompt.split(/\r?\n/);
      for (let line of lines)
        rows += 1 + Math.floor(Math.max(width(line) - 1, 0) / perLine);
      return (erase.line + cursor.prevLine()).repeat(rows - 1) + erase.line + cursor.to(0);
    };
  }
});

// ../../node_modules/prompts/lib/util/figures.js
var require_figures2 = __commonJS({
  "../../node_modules/prompts/lib/util/figures.js"(exports2, module2) {
    "use strict";
    var main5 = {
      arrowUp: "\u2191",
      arrowDown: "\u2193",
      arrowLeft: "\u2190",
      arrowRight: "\u2192",
      radioOn: "\u25C9",
      radioOff: "\u25EF",
      tick: "\u2714",
      cross: "\u2716",
      ellipsis: "\u2026",
      pointerSmall: "\u203A",
      line: "\u2500",
      pointer: "\u276F"
    }, win = {
      arrowUp: main5.arrowUp,
      arrowDown: main5.arrowDown,
      arrowLeft: main5.arrowLeft,
      arrowRight: main5.arrowRight,
      radioOn: "(*)",
      radioOff: "( )",
      tick: "\u221A",
      cross: "\xD7",
      ellipsis: "...",
      pointerSmall: "\xBB",
      line: "\u2500",
      pointer: ">"
    }, figures = process.platform === "win32" ? win : main5;
    module2.exports = figures;
  }
});

// ../../node_modules/prompts/lib/util/style.js
var require_style2 = __commonJS({
  "../../node_modules/prompts/lib/util/style.js"(exports2, module2) {
    "use strict";
    var c = require_kleur(), figures = require_figures2(), styles3 = Object.freeze({
      password: { scale: 1, render: (input) => "*".repeat(input.length) },
      emoji: { scale: 2, render: (input) => "\u{1F603}".repeat(input.length) },
      invisible: { scale: 0, render: (input) => "" },
      default: { scale: 1, render: (input) => `${input}` }
    }), render = (type) => styles3[type] || styles3.default, symbols = Object.freeze({
      aborted: c.red(figures.cross),
      done: c.green(figures.tick),
      default: c.cyan("?")
    }), symbol = (done, aborted) => aborted ? symbols.aborted : done ? symbols.done : symbols.default, delimiter = (completing) => c.gray(completing ? figures.ellipsis : figures.pointerSmall), item = (expandable, expanded) => c.gray(expandable ? expanded ? figures.pointerSmall : "+" : figures.line);
    module2.exports = {
      styles: styles3,
      render,
      symbols,
      symbol,
      delimiter,
      item
    };
  }
});

// ../../node_modules/prompts/lib/util/index.js
var require_util3 = __commonJS({
  "../../node_modules/prompts/lib/util/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      action: require_action2(),
      clear: require_clear2(),
      style: require_style2(),
      strip: require_strip2(),
      figures: require_figures2()
    };
  }
});

// ../../node_modules/prompts/lib/elements/prompt.js
var require_prompt2 = __commonJS({
  "../../node_modules/prompts/lib/elements/prompt.js"(exports2, module2) {
    "use strict";
    var readline = require("readline"), { action } = require_util3(), EventEmitter3 = require("events"), { beep, cursor } = require_src(), color = require_kleur(), Prompt = class extends EventEmitter3 {
      constructor(opts = {}) {
        super(), this.firstRender = !0, this.in = opts.in || process.stdin, this.out = opts.out || process.stdout, this.onRender = (opts.onRender || (() => {
        })).bind(this);
        let rl = readline.createInterface(this.in);
        readline.emitKeypressEvents(this.in, rl), this.in.isTTY && this.in.setRawMode(!0);
        let keypress = (str, key) => {
          let a = action(key);
          a === !1 ? this._ && this._(str, key) : typeof this[a] == "function" ? this[a](key) : this.bell();
        };
        this.close = () => {
          this.out.write(cursor.show), this.in.removeListener("keypress", keypress), this.in.isTTY && this.in.setRawMode(!1), rl.close(), this.emit(this.aborted ? "abort" : "submit", this.value), this.closed = !0;
        }, this.in.on("keypress", keypress);
      }
      fire() {
        this.emit("state", {
          value: this.value,
          aborted: !!this.aborted
        });
      }
      bell() {
        this.out.write(beep);
      }
      render() {
        this.onRender(color), this.firstRender && (this.firstRender = !1);
      }
    };
    module2.exports = Prompt;
  }
});

// ../../node_modules/prompts/lib/elements/text.js
var require_text2 = __commonJS({
  "../../node_modules/prompts/lib/elements/text.js"(exports2, module2) {
    var color = require_kleur(), Prompt = require_prompt2(), { cursor } = require_src(), { style, clear, strip, figures } = require_util3(), TextPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.transform = style.render(opts.style), this.scale = this.transform.scale, this.msg = opts.message, this.initial = opts.initial || "", this.validator = opts.validate || (() => !0), this.value = "", this.errorMsg = opts.error || "Please Enter A Valid Value", this.cursor = +!!this.initial, this.clear = clear(""), this.render();
      }
      set value(v) {
        !v && this.initial ? (this.placeholder = !0, this.rendered = color.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.rendered = this.transform.render(v)), this._value = v, this.fire();
      }
      get value() {
        return this._value;
      }
      reset() {
        this.value = "", this.cursor = +!!this.initial, this.fire(), this.render();
      }
      abort() {
        this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      async validate() {
        let valid = await this.validator(this.value);
        typeof valid == "string" && (this.errorMsg = valid, valid = !1), this.error = !valid;
      }
      async submit() {
        if (this.value = this.value || this.initial, await this.validate(), this.error) {
          this.red = !0, this.fire(), this.render();
          return;
        }
        this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      next() {
        if (!this.placeholder)
          return this.bell();
        this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
      }
      moveCursor(n) {
        this.placeholder || (this.cursor = this.cursor + n);
      }
      _(c, key) {
        let s1 = this.value.slice(0, this.cursor), s2 = this.value.slice(this.cursor);
        this.value = `${s1}${c}${s2}`, this.red = !1, this.cursor = this.placeholder ? 0 : s1.length + 1, this.render();
      }
      delete() {
        if (this.cursor === 0)
          return this.bell();
        let s1 = this.value.slice(0, this.cursor - 1), s2 = this.value.slice(this.cursor);
        this.value = `${s1}${s2}`, this.red = !1, this.moveCursor(-1), this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
          return this.bell();
        let s1 = this.value.slice(0, this.cursor), s2 = this.value.slice(this.cursor + 1);
        this.value = `${s1}${s2}`, this.red = !1, this.render();
      }
      first() {
        this.cursor = 0, this.render();
      }
      last() {
        this.cursor = this.value.length, this.render();
      }
      left() {
        if (this.cursor <= 0 || this.placeholder)
          return this.bell();
        this.moveCursor(-1), this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length || this.placeholder)
          return this.bell();
        this.moveCursor(1), this.render();
      }
      render() {
        if (this.closed)
          return;
        super.render();
        let erase = (this.lines ? cursor.down(this.lines) : "") + this.clear;
        this.lines = 0;
        let prompt = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          this.red ? color.red(this.rendered) : this.rendered
        ].join(" "), error = "";
        if (this.error) {
          let lines = this.errorMsg.split(`
`);
          error += lines.reduce((a, l, i) => a += `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ""), this.lines = lines.length;
        }
        let position = "";
        this.lines && (position += cursor.up(this.lines), position += cursor.left + cursor.to(strip(prompt).length)), position += cursor.move(
          this.placeholder ? -this.initial.length * this.scale : -this.rendered.length + this.cursor * this.scale
        ), this.out.write(erase + prompt + error + position), this.clear = clear(prompt + error);
      }
    };
    module2.exports = TextPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/select.js
var require_select2 = __commonJS({
  "../../node_modules/prompts/lib/elements/select.js"(exports2, module2) {
    "use strict";
    var color = require_kleur(), Prompt = require_prompt2(), { style, clear, figures } = require_util3(), { erase, cursor } = require_src(), SelectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.msg = opts.message, this.hint = opts.hint || "- Use arrow-keys. Return to submit.", this.warn = opts.warn || "- This option is disabled", this.cursor = opts.initial || 0, this.choices = opts.choices.map((ch, idx) => (typeof ch == "string" && (ch = { title: ch, value: idx }), {
          title: ch && (ch.title || ch.value || ch),
          value: ch && (ch.value || idx),
          selected: ch && ch.selected,
          disabled: ch && ch.disabled
        })), this.value = (this.choices[this.cursor] || {}).value, this.clear = clear(""), this.render();
      }
      moveCursor(n) {
        this.cursor = n, this.value = this.choices[n].value, this.fire();
      }
      reset() {
        this.moveCursor(0), this.fire(), this.render();
      }
      abort() {
        this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      submit() {
        this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
      }
      first() {
        this.moveCursor(0), this.render();
      }
      last() {
        this.moveCursor(this.choices.length - 1), this.render();
      }
      up() {
        if (this.cursor === 0)
          return this.bell();
        this.moveCursor(this.cursor - 1), this.render();
      }
      down() {
        if (this.cursor === this.choices.length - 1)
          return this.bell();
        this.moveCursor(this.cursor + 1), this.render();
      }
      next() {
        this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
      }
      _(c, key) {
        if (c === " ")
          return this.submit();
      }
      get selection() {
        return this.choices[this.cursor];
      }
      render() {
        this.closed || (this.firstRender ? this.out.write(cursor.hide) : this.out.write(erase.lines(this.choices.length + 1)), super.render(), this.out.write([
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(!1),
          this.done ? this.selection.title : this.selection.disabled ? color.yellow(this.warn) : color.gray(this.hint)
        ].join(" ")), this.done || this.out.write(
          `
` + this.choices.map((v, i) => {
            let title, prefix;
            return v.disabled ? (title = this.cursor === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title), prefix = this.cursor === i ? color.bold().gray(figures.pointer) + " " : "  ") : (title = this.cursor === i ? color.cyan().underline(v.title) : v.title, prefix = this.cursor === i ? color.cyan(figures.pointer) + " " : "  "), `${prefix} ${title}`;
          }).join(`
`)
        ));
      }
    };
    module2.exports = SelectPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/toggle.js
var require_toggle2 = __commonJS({
  "../../node_modules/prompts/lib/elements/toggle.js"(exports2, module2) {
    var color = require_kleur(), Prompt = require_prompt2(), { style, clear } = require_util3(), { cursor, erase } = require_src(), TogglePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.msg = opts.message, this.value = !!opts.initial, this.active = opts.active || "on", this.inactive = opts.inactive || "off", this.initialValue = this.value, this.render();
      }
      reset() {
        this.value = this.initialValue, this.fire(), this.render();
      }
      abort() {
        this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      submit() {
        this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      deactivate() {
        if (this.value === !1)
          return this.bell();
        this.value = !1, this.render();
      }
      activate() {
        if (this.value === !0)
          return this.bell();
        this.value = !0, this.render();
      }
      delete() {
        this.deactivate();
      }
      left() {
        this.deactivate();
      }
      right() {
        this.activate();
      }
      down() {
        this.deactivate();
      }
      up() {
        this.activate();
      }
      next() {
        this.value = !this.value, this.fire(), this.render();
      }
      _(c, key) {
        if (c === " ")
          this.value = !this.value;
        else if (c === "1")
          this.value = !0;
        else if (c === "0")
          this.value = !1;
        else
          return this.bell();
        this.render();
      }
      render() {
        this.closed || (this.firstRender && this.out.write(cursor.hide), super.render(), this.out.write(
          erase.lines(this.first ? 1 : this.msg.split(/\n/g).length) + cursor.to(0) + [
            style.symbol(this.done, this.aborted),
            color.bold(this.msg),
            style.delimiter(this.done),
            this.value ? this.inactive : color.cyan().underline(this.inactive),
            color.gray("/"),
            this.value ? color.cyan().underline(this.active) : this.active
          ].join(" ")
        ));
      }
    };
    module2.exports = TogglePrompt;
  }
});

// ../../node_modules/prompts/lib/dateparts/datepart.js
var require_datepart2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/datepart.js"(exports2, module2) {
    "use strict";
    var DatePart = class _DatePart {
      constructor({ token, date, parts, locales }) {
        this.token = token, this.date = date || /* @__PURE__ */ new Date(), this.parts = parts || [this], this.locales = locales || {};
      }
      up() {
      }
      down() {
      }
      next() {
        let currentIdx = this.parts.indexOf(this);
        return this.parts.find((part, idx) => idx > currentIdx && part instanceof _DatePart);
      }
      setTo(val) {
      }
      prev() {
        let parts = [].concat(this.parts).reverse(), currentIdx = parts.indexOf(this);
        return parts.find((part, idx) => idx > currentIdx && part instanceof _DatePart);
      }
      toString() {
        return String(this.date);
      }
    };
    module2.exports = DatePart;
  }
});

// ../../node_modules/prompts/lib/dateparts/meridiem.js
var require_meridiem2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/meridiem.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2(), Meridiem = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours((this.date.getHours() + 12) % 24);
      }
      down() {
        this.up();
      }
      toString() {
        let meridiem = this.date.getHours() > 12 ? "pm" : "am";
        return /\A/.test(this.token) ? meridiem.toUpperCase() : meridiem;
      }
    };
    module2.exports = Meridiem;
  }
});

// ../../node_modules/prompts/lib/dateparts/day.js
var require_day2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/day.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2(), pos = (n) => (n = n % 10, n === 1 ? "st" : n === 2 ? "nd" : n === 3 ? "rd" : "th"), Day = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setDate(this.date.getDate() + 1);
      }
      down() {
        this.date.setDate(this.date.getDate() - 1);
      }
      setTo(val) {
        this.date.setDate(parseInt(val.substr(-2)));
      }
      toString() {
        let date = this.date.getDate(), day = this.date.getDay();
        return this.token === "DD" ? String(date).padStart(2, "0") : this.token === "Do" ? date + pos(date) : this.token === "d" ? day + 1 : this.token === "ddd" ? this.locales.weekdaysShort[day] : this.token === "dddd" ? this.locales.weekdays[day] : date;
      }
    };
    module2.exports = Day;
  }
});

// ../../node_modules/prompts/lib/dateparts/hours.js
var require_hours2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/hours.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2(), Hours = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setHours(this.date.getHours() + 1);
      }
      down() {
        this.date.setHours(this.date.getHours() - 1);
      }
      setTo(val) {
        this.date.setHours(parseInt(val.substr(-2)));
      }
      toString() {
        let hours = this.date.getHours();
        return /h/.test(this.token) && (hours = hours % 12 || 12), this.token.length > 1 ? String(hours).padStart(2, "0") : hours;
      }
    };
    module2.exports = Hours;
  }
});

// ../../node_modules/prompts/lib/dateparts/milliseconds.js
var require_milliseconds2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/milliseconds.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2(), Milliseconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMilliseconds(this.date.getMilliseconds() + 1);
      }
      down() {
        this.date.setMilliseconds(this.date.getMilliseconds() - 1);
      }
      setTo(val) {
        this.date.setMilliseconds(parseInt(val.substr(-this.token.length)));
      }
      toString() {
        return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
      }
    };
    module2.exports = Milliseconds;
  }
});

// ../../node_modules/prompts/lib/dateparts/minutes.js
var require_minutes2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/minutes.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2(), Minutes = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMinutes(this.date.getMinutes() + 1);
      }
      down() {
        this.date.setMinutes(this.date.getMinutes() - 1);
      }
      setTo(val) {
        this.date.setMinutes(parseInt(val.substr(-2)));
      }
      toString() {
        let m = this.date.getMinutes();
        return this.token.length > 1 ? String(m).padStart(2, "0") : m;
      }
    };
    module2.exports = Minutes;
  }
});

// ../../node_modules/prompts/lib/dateparts/month.js
var require_month2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/month.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2(), Month = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setMonth(this.date.getMonth() + 1);
      }
      down() {
        this.date.setMonth(this.date.getMonth() - 1);
      }
      setTo(val) {
        val = parseInt(val.substr(-2)) - 1, this.date.setMonth(val < 0 ? 0 : val);
      }
      toString() {
        let month = this.date.getMonth(), tl = this.token.length;
        return tl === 2 ? String(month + 1).padStart(2, "0") : tl === 3 ? this.locales.monthsShort[month] : tl === 4 ? this.locales.months[month] : String(month + 1);
      }
    };
    module2.exports = Month;
  }
});

// ../../node_modules/prompts/lib/dateparts/seconds.js
var require_seconds2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/seconds.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2(), Seconds = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setSeconds(this.date.getSeconds() + 1);
      }
      down() {
        this.date.setSeconds(this.date.getSeconds() - 1);
      }
      setTo(val) {
        this.date.setSeconds(parseInt(val.substr(-2)));
      }
      toString() {
        let s = this.date.getSeconds();
        return this.token.length > 1 ? String(s).padStart(2, "0") : s;
      }
    };
    module2.exports = Seconds;
  }
});

// ../../node_modules/prompts/lib/dateparts/year.js
var require_year2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/year.js"(exports2, module2) {
    "use strict";
    var DatePart = require_datepart2(), Year = class extends DatePart {
      constructor(opts = {}) {
        super(opts);
      }
      up() {
        this.date.setFullYear(this.date.getFullYear() + 1);
      }
      down() {
        this.date.setFullYear(this.date.getFullYear() - 1);
      }
      setTo(val) {
        this.date.setFullYear(val.substr(-4));
      }
      toString() {
        let year = String(this.date.getFullYear()).padStart(4, "0");
        return this.token.length === 2 ? year.substr(-2) : year;
      }
    };
    module2.exports = Year;
  }
});

// ../../node_modules/prompts/lib/dateparts/index.js
var require_dateparts2 = __commonJS({
  "../../node_modules/prompts/lib/dateparts/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      DatePart: require_datepart2(),
      Meridiem: require_meridiem2(),
      Day: require_day2(),
      Hours: require_hours2(),
      Milliseconds: require_milliseconds2(),
      Minutes: require_minutes2(),
      Month: require_month2(),
      Seconds: require_seconds2(),
      Year: require_year2()
    };
  }
});

// ../../node_modules/prompts/lib/elements/date.js
var require_date2 = __commonJS({
  "../../node_modules/prompts/lib/elements/date.js"(exports2, module2) {
    "use strict";
    var color = require_kleur(), Prompt = require_prompt2(), { style, clear, figures, strip } = require_util3(), { erase, cursor } = require_src(), { DatePart, Meridiem, Day, Hours, Milliseconds, Minutes, Month, Seconds, Year } = require_dateparts2(), regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g, regexGroups = {
      1: ({ token }) => token.replace(/\\(.)/g, "$1"),
      2: (opts) => new Day(opts),
      // Day // TODO
      3: (opts) => new Month(opts),
      // Month
      4: (opts) => new Year(opts),
      // Year
      5: (opts) => new Meridiem(opts),
      // AM/PM // TODO (special)
      6: (opts) => new Hours(opts),
      // Hours
      7: (opts) => new Minutes(opts),
      // Minutes
      8: (opts) => new Seconds(opts),
      // Seconds
      9: (opts) => new Milliseconds(opts)
      // Fractional seconds
    }, dfltLocales = {
      months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
      monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
      weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
      weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
    }, DatePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.msg = opts.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(dfltLocales, opts.locales), this._date = opts.initial || /* @__PURE__ */ new Date(), this.errorMsg = opts.error || "Please Enter A Valid Value", this.validator = opts.validate || (() => !0), this.mask = opts.mask || "YYYY-MM-DD HH:mm:ss", this.clear = clear(""), this.render();
      }
      get value() {
        return this.date;
      }
      get date() {
        return this._date;
      }
      set date(date) {
        date && this._date.setTime(date.getTime());
      }
      set mask(mask) {
        let result;
        for (this.parts = []; result = regex.exec(mask); ) {
          let match2 = result.shift(), idx = result.findIndex((gr) => gr != null);
          this.parts.push(idx in regexGroups ? regexGroups[idx]({ token: result[idx] || match2, date: this.date, parts: this.parts, locales: this.locales }) : result[idx] || match2);
        }
        let parts = this.parts.reduce((arr, i) => (typeof i == "string" && typeof arr[arr.length - 1] == "string" ? arr[arr.length - 1] += i : arr.push(i), arr), []);
        this.parts.splice(0), this.parts.push(...parts), this.reset();
      }
      moveCursor(n) {
        this.typed = "", this.cursor = n, this.fire();
      }
      reset() {
        this.moveCursor(this.parts.findIndex((p) => p instanceof DatePart)), this.fire(), this.render();
      }
      abort() {
        this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      async validate() {
        let valid = await this.validator(this.value);
        typeof valid == "string" && (this.errorMsg = valid, valid = !1), this.error = !valid;
      }
      async submit() {
        if (await this.validate(), this.error) {
          this.color = "red", this.fire(), this.render();
          return;
        }
        this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      up() {
        this.typed = "", this.parts[this.cursor].up(), this.render();
      }
      down() {
        this.typed = "", this.parts[this.cursor].down(), this.render();
      }
      left() {
        let prev = this.parts[this.cursor].prev();
        if (prev == null)
          return this.bell();
        this.moveCursor(this.parts.indexOf(prev)), this.render();
      }
      right() {
        let next = this.parts[this.cursor].next();
        if (next == null)
          return this.bell();
        this.moveCursor(this.parts.indexOf(next)), this.render();
      }
      next() {
        let next = this.parts[this.cursor].next();
        this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex((part) => part instanceof DatePart)), this.render();
      }
      _(c) {
        /\d/.test(c) && (this.typed += c, this.parts[this.cursor].setTo(this.typed), this.render());
      }
      render() {
        if (this.closed)
          return;
        this.firstRender ? this.out.write(cursor.hide) : this.out.write(erase.lines(1)), super.render();
        let clear2 = erase.line + (this.lines ? erase.down(this.lines) : "") + cursor.to(0);
        this.lines = 0;
        let error = "";
        if (this.error) {
          let lines = this.errorMsg.split(`
`);
          error = lines.reduce((a, l, i) => a + `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ""), this.lines = lines.length;
        }
        let prompt = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(!1),
          this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join("")
        ].join(" "), position = "";
        this.lines && (position += cursor.up(this.lines), position += cursor.left + cursor.to(strip(prompt).length)), this.out.write(clear2 + prompt + error + position);
      }
    };
    module2.exports = DatePrompt;
  }
});

// ../../node_modules/prompts/lib/elements/number.js
var require_number2 = __commonJS({
  "../../node_modules/prompts/lib/elements/number.js"(exports2, module2) {
    var color = require_kleur(), Prompt = require_prompt2(), { cursor, erase } = require_src(), { style, clear, figures, strip } = require_util3(), isNumber = /[0-9]/, isDef = (any) => any !== void 0, round = (number, precision) => {
      let factor = Math.pow(10, precision);
      return Math.round(number * factor) / factor;
    }, NumberPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.transform = style.render(opts.style), this.msg = opts.message, this.initial = isDef(opts.initial) ? opts.initial : "", this.float = !!opts.float, this.round = opts.round || 2, this.inc = opts.increment || 1, this.min = isDef(opts.min) ? opts.min : -1 / 0, this.max = isDef(opts.max) ? opts.max : 1 / 0, this.errorMsg = opts.error || "Please Enter A Valid Value", this.validator = opts.validate || (() => !0), this.color = "cyan", this.value = "", this.typed = "", this.lastHit = 0, this.render();
      }
      set value(v) {
        !v && v !== 0 ? (this.placeholder = !0, this.rendered = color.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder = !1, this.rendered = this.transform.render(`${round(v, this.round)}`), this._value = round(v, this.round)), this.fire();
      }
      get value() {
        return this._value;
      }
      parse(x) {
        return this.float ? parseFloat(x) : parseInt(x);
      }
      valid(c) {
        return c === "-" || c === "." && this.float || isNumber.test(c);
      }
      reset() {
        this.typed = "", this.value = "", this.fire(), this.render();
      }
      abort() {
        let x = this.value;
        this.value = x !== "" ? x : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      async validate() {
        let valid = await this.validator(this.value);
        typeof valid == "string" && (this.errorMsg = valid, valid = !1), this.error = !valid;
      }
      async submit() {
        if (await this.validate(), this.error) {
          this.color = "red", this.fire(), this.render();
          return;
        }
        let x = this.value;
        this.value = x !== "" ? x : this.initial, this.done = !0, this.aborted = !1, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      up() {
        if (this.typed = "", this.value >= this.max)
          return this.bell();
        this.value += this.inc, this.color = "cyan", this.fire(), this.render();
      }
      down() {
        if (this.typed = "", this.value <= this.min)
          return this.bell();
        this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
      }
      delete() {
        let val = this.value.toString();
        if (val.length === 0)
          return this.bell();
        this.value = this.parse(val = val.slice(0, -1)) || "", this.color = "cyan", this.fire(), this.render();
      }
      next() {
        this.value = this.initial, this.fire(), this.render();
      }
      _(c, key) {
        if (!this.valid(c))
          return this.bell();
        let now = Date.now();
        if (now - this.lastHit > 1e3 && (this.typed = ""), this.typed += c, this.lastHit = now, this.color = "cyan", c === ".")
          return this.fire();
        this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.value = this.min), this.fire(), this.render();
      }
      render() {
        if (this.closed)
          return;
        super.render();
        let clear2 = erase.line + (this.lines ? erase.down(this.lines) : "") + cursor.to(0);
        this.lines = 0;
        let error = "";
        if (this.error) {
          let lines = this.errorMsg.split(`
`);
          error += lines.reduce((a, l, i) => a + `
${i ? " " : figures.pointerSmall} ${color.red().italic(l)}`, ""), this.lines = lines.length;
        }
        let underline = !this.done || !this.done && !this.placeholder, prompt = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(this.done),
          underline ? color[this.color]().underline(this.rendered) : this.rendered
        ].join(" "), position = "";
        this.lines && (position += cursor.up(this.lines), position += cursor.left + cursor.to(strip(prompt).length)), this.out.write(clear2 + prompt + error + position);
      }
    };
    module2.exports = NumberPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/multiselect.js
var require_multiselect2 = __commonJS({
  "../../node_modules/prompts/lib/elements/multiselect.js"(exports2, module2) {
    "use strict";
    var color = require_kleur(), { cursor } = require_src(), Prompt = require_prompt2(), { clear, figures, style } = require_util3(), MultiselectPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.msg = opts.message, this.cursor = opts.cursor || 0, this.scrollIndex = opts.cursor || 0, this.hint = opts.hint || "", this.warn = opts.warn || "- This option is disabled -", this.minSelected = opts.min, this.showMinError = !1, this.maxChoices = opts.max, this.value = opts.choices.map((ch, idx) => (typeof ch == "string" && (ch = { title: ch, value: idx }), {
          title: ch && (ch.title || ch.value || ch),
          value: ch && (ch.value || idx),
          selected: ch && ch.selected,
          disabled: ch && ch.disabled
        })), this.clear = clear(""), opts.overrideRender || this.render();
      }
      reset() {
        this.value.map((v) => !v.selected), this.cursor = 0, this.fire(), this.render();
      }
      selected() {
        return this.value.filter((v) => v.selected);
      }
      abort() {
        this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      submit() {
        let selected = this.value.filter((e) => e.selected);
        this.minSelected && selected.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
      }
      first() {
        this.cursor = 0, this.render();
      }
      last() {
        this.cursor = this.value.length - 1, this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.value.length, this.render();
      }
      up() {
        this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
      }
      down() {
        this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
      }
      left() {
        this.value[this.cursor].selected = !1, this.render();
      }
      right() {
        if (this.value.filter((e) => e.selected).length >= this.maxChoices)
          return this.bell();
        this.value[this.cursor].selected = !0, this.render();
      }
      handleSpaceToggle() {
        let v = this.value[this.cursor];
        if (v.selected)
          v.selected = !1, this.render();
        else {
          if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices)
            return this.bell();
          v.selected = !0, this.render();
        }
      }
      _(c, key) {
        if (c === " ")
          this.handleSpaceToggle();
        else
          return this.bell();
      }
      renderInstructions() {
        return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    enter/return: Complete answer
    `;
      }
      renderOption(cursor2, v, i) {
        let title;
        return v.disabled ? title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title) : title = cursor2 === i ? color.cyan().underline(v.title) : v.title, (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
      }
      // shared with autocompleteMultiselect
      paginateOptions(options) {
        let c = this.cursor, styledOptions = options.map((v, i) => this.renderOption(c, v, i)), numOfOptionsToRender = 10, scopedOptions = styledOptions, hint = "";
        if (styledOptions.length === 0)
          return color.red("No matches for this query.");
        if (styledOptions.length > numOfOptionsToRender) {
          let startIndex = c - numOfOptionsToRender / 2, endIndex = c + numOfOptionsToRender / 2;
          startIndex < 0 ? (startIndex = 0, endIndex = numOfOptionsToRender) : endIndex > options.length && (endIndex = options.length, startIndex = endIndex - numOfOptionsToRender), scopedOptions = styledOptions.slice(startIndex, endIndex), hint = color.dim("(Move up and down to reveal more choices)");
        }
        return `
` + scopedOptions.join(`
`) + `
` + hint;
      }
      // shared with autocomleteMultiselect
      renderOptions(options) {
        return this.done ? "" : this.paginateOptions(options);
      }
      renderDoneOrInstructions() {
        if (this.done)
          return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
        let output = [color.gray(this.hint), this.renderInstructions()];
        return this.value[this.cursor].disabled && output.push(color.yellow(this.warn)), output.join(" ");
      }
      render() {
        if (this.closed)
          return;
        this.firstRender && this.out.write(cursor.hide), super.render();
        let prompt = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(!1),
          this.renderDoneOrInstructions()
        ].join(" ");
        this.showMinError && (prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), prompt += this.renderOptions(this.value), this.out.write(this.clear + prompt), this.clear = clear(prompt);
      }
    };
    module2.exports = MultiselectPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/autocomplete.js
var require_autocomplete2 = __commonJS({
  "../../node_modules/prompts/lib/elements/autocomplete.js"(exports2, module2) {
    "use strict";
    var color = require_kleur(), Prompt = require_prompt2(), { cursor } = require_src(), { style, clear, figures, strip } = require_util3(), getVal = (arr, i) => arr[i] && (arr[i].value || arr[i].title || arr[i]), getTitle = (arr, i) => arr[i] && (arr[i].title || arr[i].value || arr[i]), getIndex = (arr, valOrTitle) => {
      let index = arr.findIndex((el) => el.value === valOrTitle || el.title === valOrTitle);
      return index > -1 ? index : void 0;
    }, AutocompletePrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.msg = opts.message, this.suggest = opts.suggest, this.choices = opts.choices, this.initial = typeof opts.initial == "number" ? opts.initial : getIndex(opts.choices, opts.initial), this.select = this.initial || opts.cursor || 0, this.fallback = opts.fallback || (opts.initial !== void 0 ? `${figures.pointerSmall} ${getTitle(this.choices, this.initial)}` : `${figures.pointerSmall} ${opts.noMatches || "no matches found"}`), this.suggestions = [[]], this.page = 0, this.input = "", this.limit = opts.limit || 10, this.cursor = 0, this.transform = style.render(opts.style), this.scale = this.transform.scale, this.render = this.render.bind(this), this.complete = this.complete.bind(this), this.clear = clear(""), this.complete(this.render), this.render();
      }
      moveSelect(i) {
        this.select = i, this.suggestions[this.page].length > 0 ? this.value = getVal(this.suggestions[this.page], i) : this.value = this.initial !== void 0 ? getVal(this.choices, this.initial) : null, this.fire();
      }
      async complete(cb) {
        let p = this.completing = this.suggest(this.input, this.choices), suggestions = await p;
        if (this.completing !== p)
          return;
        if (this.suggestions = suggestions.map((s, i, arr) => ({ title: getTitle(arr, i), value: getVal(arr, i) })).reduce((arr, sug) => (arr[arr.length - 1].length < this.limit ? arr[arr.length - 1].push(sug) : arr.push([sug]), arr), [[]]), this.isFallback = !1, this.completing = !1, this.suggestions[this.page] || (this.page = 0), !this.suggestions.length && this.fallback) {
          let index = getIndex(this.choices, this.fallback);
          this.suggestions = [[]], index !== void 0 && this.suggestions[0].push({ title: getTitle(this.choices, index), value: getVal(this.choices, index) }), this.isFallback = !0;
        }
        let l = Math.max(suggestions.length - 1, 0);
        this.moveSelect(Math.min(l, this.select)), cb && cb();
      }
      reset() {
        this.input = "", this.complete(() => {
          this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
        }), this.render();
      }
      abort() {
        this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      submit() {
        this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      _(c, key) {
        let s1 = this.input.slice(0, this.cursor), s2 = this.input.slice(this.cursor);
        this.input = `${s1}${c}${s2}`, this.cursor = s1.length + 1, this.complete(this.render), this.render();
      }
      delete() {
        if (this.cursor === 0)
          return this.bell();
        let s1 = this.input.slice(0, this.cursor - 1), s2 = this.input.slice(this.cursor);
        this.input = `${s1}${s2}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
      }
      deleteForward() {
        if (this.cursor * this.scale >= this.rendered.length)
          return this.bell();
        let s1 = this.input.slice(0, this.cursor), s2 = this.input.slice(this.cursor + 1);
        this.input = `${s1}${s2}`, this.complete(this.render), this.render();
      }
      first() {
        this.moveSelect(0), this.render();
      }
      last() {
        this.moveSelect(this.suggestions[this.page].length - 1), this.render();
      }
      up() {
        if (this.select <= 0)
          return this.bell();
        this.moveSelect(this.select - 1), this.render();
      }
      down() {
        if (this.select >= this.suggestions[this.page].length - 1)
          return this.bell();
        this.moveSelect(this.select + 1), this.render();
      }
      next() {
        this.select === this.suggestions[this.page].length - 1 ? (this.page = (this.page + 1) % this.suggestions.length, this.moveSelect(0)) : this.moveSelect(this.select + 1), this.render();
      }
      nextPage() {
        if (this.page >= this.suggestions.length - 1)
          return this.bell();
        this.page++, this.moveSelect(0), this.render();
      }
      prevPage() {
        if (this.page <= 0)
          return this.bell();
        this.page--, this.moveSelect(0), this.render();
      }
      left() {
        if (this.cursor <= 0)
          return this.bell();
        this.cursor = this.cursor - 1, this.render();
      }
      right() {
        if (this.cursor * this.scale >= this.rendered.length)
          return this.bell();
        this.cursor = this.cursor + 1, this.render();
      }
      render() {
        if (this.closed)
          return;
        super.render(), this.lineCount && this.out.write(cursor.down(this.lineCount));
        let prompt = color.bold(`${style.symbol(this.done, this.aborted)} ${this.msg} `) + `${style.delimiter(this.completing)} `, length = strip(prompt).length;
        if (this.done && this.suggestions[this.page][this.select] ? prompt += `${this.suggestions[this.page][this.select].title}` : (this.rendered = `${this.transform.render(this.input)}`, length += this.rendered.length, prompt += this.rendered), !this.done) {
          this.lineCount = this.suggestions[this.page].length;
          let suggestions = this.suggestions[this.page].reduce((acc, item, i) => acc + `
${i === this.select ? color.cyan(item.title) : item.title}`, "");
          if (suggestions && !this.isFallback)
            prompt += suggestions, this.suggestions.length > 1 && (this.lineCount++, prompt += color.blue(`
Page ${this.page + 1}/${this.suggestions.length}`));
          else {
            let fallbackIndex = getIndex(this.choices, this.fallback), fallbackTitle = fallbackIndex !== void 0 ? getTitle(this.choices, fallbackIndex) : this.fallback;
            prompt += `
${color.gray(fallbackTitle)}`, this.lineCount++;
          }
        }
        if (this.out.write(this.clear + prompt), this.clear = clear(prompt), this.lineCount && !this.done) {
          let pos = cursor.up(this.lineCount);
          pos += cursor.left + cursor.to(length), pos += cursor.move(-this.rendered.length + this.cursor * this.scale), this.out.write(pos);
        }
      }
    };
    module2.exports = AutocompletePrompt;
  }
});

// ../../node_modules/prompts/lib/elements/autocompleteMultiselect.js
var require_autocompleteMultiselect2 = __commonJS({
  "../../node_modules/prompts/lib/elements/autocompleteMultiselect.js"(exports2, module2) {
    "use strict";
    var color = require_kleur(), { cursor } = require_src(), MultiselectPrompt = require_multiselect2(), { clear, style, figures } = require_util3(), AutocompleteMultiselectPrompt = class extends MultiselectPrompt {
      constructor(opts = {}) {
        opts.overrideRender = !0, super(opts), this.inputValue = "", this.clear = clear(""), this.filteredOptions = this.value, this.render();
      }
      last() {
        this.cursor = this.filteredOptions.length - 1, this.render();
      }
      next() {
        this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
      }
      up() {
        this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
      }
      down() {
        this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
      }
      left() {
        this.filteredOptions[this.cursor].selected = !1, this.render();
      }
      right() {
        if (this.value.filter((e) => e.selected).length >= this.maxChoices)
          return this.bell();
        this.filteredOptions[this.cursor].selected = !0, this.render();
      }
      delete() {
        this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
      }
      updateFilteredOptions() {
        let currentHighlight = this.filteredOptions[this.cursor];
        this.filteredOptions = this.value.filter((v) => this.inputValue ? !!(typeof v.title == "string" && v.title.toLowerCase().includes(this.inputValue.toLowerCase()) || typeof v.value == "string" && v.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
        let newHighlightIndex = this.filteredOptions.findIndex((v) => v === currentHighlight);
        this.cursor = newHighlightIndex < 0 ? 0 : newHighlightIndex, this.render();
      }
      handleSpaceToggle() {
        let v = this.filteredOptions[this.cursor];
        if (v.selected)
          v.selected = !1, this.render();
        else {
          if (v.disabled || this.value.filter((e) => e.selected).length >= this.maxChoices)
            return this.bell();
          v.selected = !0, this.render();
        }
      }
      handleInputChange(c) {
        this.inputValue = this.inputValue + c, this.updateFilteredOptions();
      }
      _(c, key) {
        c === " " ? this.handleSpaceToggle() : this.handleInputChange(c);
      }
      renderInstructions() {
        return `
Instructions:
    ${figures.arrowUp}/${figures.arrowDown}: Highlight option
    ${figures.arrowLeft}/${figures.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
    `;
      }
      renderCurrentInput() {
        return `
Filtered results for: ${this.inputValue ? this.inputValue : color.gray("Enter something to filter")}
`;
      }
      renderOption(cursor2, v, i) {
        let title;
        return v.disabled ? title = cursor2 === i ? color.gray().underline(v.title) : color.strikethrough().gray(v.title) : title = cursor2 === i ? color.cyan().underline(v.title) : v.title, (v.selected ? color.green(figures.radioOn) : figures.radioOff) + "  " + title;
      }
      renderDoneOrInstructions() {
        if (this.done)
          return this.value.filter((e) => e.selected).map((v) => v.title).join(", ");
        let output = [color.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
        return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && output.push(color.yellow(this.warn)), output.join(" ");
      }
      render() {
        if (this.closed)
          return;
        this.firstRender && this.out.write(cursor.hide), super.render();
        let prompt = [
          style.symbol(this.done, this.aborted),
          color.bold(this.msg),
          style.delimiter(!1),
          this.renderDoneOrInstructions()
        ].join(" ");
        this.showMinError && (prompt += color.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), prompt += this.renderOptions(this.filteredOptions), this.out.write(this.clear + prompt), this.clear = clear(prompt);
      }
    };
    module2.exports = AutocompleteMultiselectPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/confirm.js
var require_confirm2 = __commonJS({
  "../../node_modules/prompts/lib/elements/confirm.js"(exports2, module2) {
    var color = require_kleur(), Prompt = require_prompt2(), { style } = require_util3(), { erase, cursor } = require_src(), ConfirmPrompt = class extends Prompt {
      constructor(opts = {}) {
        super(opts), this.msg = opts.message, this.value = opts.initial, this.initialValue = !!opts.initial, this.yesMsg = opts.yes || "yes", this.yesOption = opts.yesOption || "(Y/n)", this.noMsg = opts.no || "no", this.noOption = opts.noOption || "(y/N)", this.render();
      }
      reset() {
        this.value = this.initialValue, this.fire(), this.render();
      }
      abort() {
        this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      submit() {
        this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
      }
      _(c, key) {
        return c.toLowerCase() === "y" ? (this.value = !0, this.submit()) : c.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.bell();
      }
      render() {
        this.closed || (this.firstRender && this.out.write(cursor.hide), super.render(), this.out.write(
          erase.line + cursor.to(0) + [
            style.symbol(this.done, this.aborted),
            color.bold(this.msg),
            style.delimiter(this.done),
            this.done ? this.value ? this.yesMsg : this.noMsg : color.gray(this.initialValue ? this.yesOption : this.noOption)
          ].join(" ")
        ));
      }
    };
    module2.exports = ConfirmPrompt;
  }
});

// ../../node_modules/prompts/lib/elements/index.js
var require_elements2 = __commonJS({
  "../../node_modules/prompts/lib/elements/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      TextPrompt: require_text2(),
      SelectPrompt: require_select2(),
      TogglePrompt: require_toggle2(),
      DatePrompt: require_date2(),
      NumberPrompt: require_number2(),
      MultiselectPrompt: require_multiselect2(),
      AutocompletePrompt: require_autocomplete2(),
      AutocompleteMultiselectPrompt: require_autocompleteMultiselect2(),
      ConfirmPrompt: require_confirm2()
    };
  }
});

// ../../node_modules/prompts/lib/prompts.js
var require_prompts2 = __commonJS({
  "../../node_modules/prompts/lib/prompts.js"(exports2) {
    "use strict";
    var $2 = exports2, el = require_elements2(), noop2 = (v) => v;
    function toPrompt(type, args, opts = {}) {
      return new Promise((res, rej) => {
        let p = new el[type](args), onAbort = opts.onAbort || noop2, onSubmit = opts.onSubmit || noop2;
        p.on("state", args.onState || noop2), p.on("submit", (x) => res(onSubmit(x))), p.on("abort", (x) => rej(onAbort(x)));
      });
    }
    $2.text = (args) => toPrompt("TextPrompt", args);
    $2.password = (args) => (args.style = "password", $2.text(args));
    $2.invisible = (args) => (args.style = "invisible", $2.text(args));
    $2.number = (args) => toPrompt("NumberPrompt", args);
    $2.date = (args) => toPrompt("DatePrompt", args);
    $2.confirm = (args) => toPrompt("ConfirmPrompt", args);
    $2.list = (args) => {
      let sep2 = args.separator || ",";
      return toPrompt("TextPrompt", args, {
        onSubmit: (str) => str.split(sep2).map((s) => s.trim())
      });
    };
    $2.toggle = (args) => toPrompt("TogglePrompt", args);
    $2.select = (args) => toPrompt("SelectPrompt", args);
    $2.multiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      let toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("MultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    $2.autocompleteMultiselect = (args) => {
      args.choices = [].concat(args.choices || []);
      let toSelected = (items) => items.filter((item) => item.selected).map((item) => item.value);
      return toPrompt("AutocompleteMultiselectPrompt", args, {
        onAbort: toSelected,
        onSubmit: toSelected
      });
    };
    var byTitle = (input, choices) => Promise.resolve(
      choices.filter((item) => item.title.slice(0, input.length).toLowerCase() === input.toLowerCase())
    );
    $2.autocomplete = (args) => (args.suggest = args.suggest || byTitle, args.choices = [].concat(args.choices || []), toPrompt("AutocompletePrompt", args));
  }
});

// ../../node_modules/prompts/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/prompts/lib/index.js"(exports2, module2) {
    "use strict";
    var prompts6 = require_prompts2(), passOn = ["suggest", "format", "onState", "validate", "onRender"], noop2 = () => {
    };
    async function prompt(questions = [], { onSubmit = noop2, onCancel = noop2 } = {}) {
      let answers = {}, override2 = prompt._override || {};
      questions = [].concat(questions);
      let answer, question, quit, name, type, getFormattedAnswer = async (question2, answer2, skipValidation = !1) => {
        if (!(!skipValidation && question2.validate && question2.validate(answer2) !== !0))
          return question2.format ? await question2.format(answer2, answers) : answer2;
      };
      for (question of questions) {
        ({ name, type } = question);
        for (let key in question) {
          if (passOn.includes(key))
            continue;
          let value = question[key];
          question[key] = typeof value == "function" ? await value(answer, { ...answers }, question) : value;
        }
        if (typeof question.message != "string")
          throw new Error("prompt message is required");
        if ({ name, type } = question, !!type) {
          if (prompts6[type] === void 0)
            throw new Error(`prompt type (${type}) is not defined`);
          if (override2[question.name] !== void 0 && (answer = await getFormattedAnswer(question, override2[question.name]), answer !== void 0)) {
            answers[name] = answer;
            continue;
          }
          try {
            answer = prompt._injected ? getInjectedAnswer(prompt._injected) : await prompts6[type](question), answers[name] = answer = await getFormattedAnswer(question, answer, !0), quit = await onSubmit(question, answer, answers);
          } catch {
            quit = !await onCancel(question, answers);
          }
          if (quit)
            return answers;
        }
      }
      return answers;
    }
    function getInjectedAnswer(injected) {
      let answer = injected.shift();
      if (answer instanceof Error)
        throw answer;
      return answer;
    }
    function inject(answers) {
      prompt._injected = (prompt._injected || []).concat(answers);
    }
    function override(answers) {
      prompt._override = Object.assign({}, answers);
    }
    module2.exports = Object.assign(prompt, { prompt, prompts: prompts6, inject, override });
  }
});

// ../../node_modules/prompts/index.js
var require_prompts3 = __commonJS({
  "../../node_modules/prompts/index.js"(exports2, module2) {
    function isNodeLT(tar) {
      tar = (Array.isArray(tar) ? tar : tar.split(".")).map(Number);
      let i = 0, src = process.versions.node.split(".").map(Number);
      for (; i < tar.length; i++) {
        if (src[i] > tar[i])
          return !1;
        if (tar[i] > src[i])
          return !0;
      }
      return !1;
    }
    module2.exports = isNodeLT("8.6.0") ? require_dist() : require_lib2();
  }
});

// ../../node_modules/zx/node_modules/which/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/zx/node_modules/which/lib/index.js"(exports2, module2) {
    var isexe = require_isexe(), { join: join3, delimiter, sep: sep2, posix: posix3 } = require("path"), isWindows = process.platform === "win32", rSlash = new RegExp(`[${posix3.sep}${sep2 === posix3.sep ? "" : sep2}]`.replace(/(\\)/g, "\\$1")), rRel = new RegExp(`^\\.${rSlash.source}`), getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" }), getPathInfo = (cmd, {
      path: optPath = process.env.PATH,
      pathExt: optPathExt = process.env.PATHEXT,
      delimiter: optDelimiter = delimiter
    }) => {
      let pathEnv = cmd.match(rSlash) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(optPath || /* istanbul ignore next: very unusual */
        "").split(optDelimiter)
      ];
      if (isWindows) {
        let pathExtExe = optPathExt || [".EXE", ".CMD", ".BAT", ".COM"].join(optDelimiter), pathExt = pathExtExe.split(optDelimiter);
        return cmd.includes(".") && pathExt[0] !== "" && pathExt.unshift(""), { pathEnv, pathExt, pathExtExe };
      }
      return { pathEnv, pathExt: [""] };
    }, getPathPart = (raw, cmd) => {
      let pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw;
      return (!pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : "") + join3(pathPart, cmd);
    }, which2 = async (cmd, opt = {}) => {
      let { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [];
      for (let envPart of pathEnv) {
        let p = getPathPart(envPart, cmd);
        for (let ext2 of pathExt) {
          let withExt = p + ext2;
          if (await isexe(withExt, { pathExt: pathExtExe, ignoreErrors: !0 })) {
            if (!opt.all)
              return withExt;
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    }, whichSync = (cmd, opt = {}) => {
      let { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [];
      for (let pathEnvPart of pathEnv) {
        let p = getPathPart(pathEnvPart, cmd);
        for (let ext2 of pathExt) {
          let withExt = p + ext2;
          if (isexe.sync(withExt, { pathExt: pathExtExe, ignoreErrors: !0 })) {
            if (!opt.all)
              return withExt;
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// ../../node_modules/through/index.js
var require_through = __commonJS({
  "../../node_modules/through/index.js"(exports2, module2) {
    var Stream3 = require("stream");
    exports2 = module2.exports = through;
    through.through = through;
    function through(write, end, opts) {
      write = write || function(data) {
        this.queue(data);
      }, end = end || function() {
        this.queue(null);
      };
      var ended = !1, destroyed = !1, buffer = [], _ended = !1, stream2 = new Stream3();
      stream2.readable = stream2.writable = !0, stream2.paused = !1, stream2.autoDestroy = !(opts && opts.autoDestroy === !1), stream2.write = function(data) {
        return write.call(this, data), !stream2.paused;
      };
      function drain() {
        for (; buffer.length && !stream2.paused; ) {
          var data = buffer.shift();
          if (data === null)
            return stream2.emit("end");
          stream2.emit("data", data);
        }
      }
      stream2.queue = stream2.push = function(data) {
        return _ended || (data === null && (_ended = !0), buffer.push(data), drain()), stream2;
      }, stream2.on("end", function() {
        stream2.readable = !1, !stream2.writable && stream2.autoDestroy && process.nextTick(function() {
          stream2.destroy();
        });
      });
      function _end() {
        stream2.writable = !1, end.call(stream2), !stream2.readable && stream2.autoDestroy && stream2.destroy();
      }
      return stream2.end = function(data) {
        if (!ended)
          return ended = !0, arguments.length && stream2.write(data), _end(), stream2;
      }, stream2.destroy = function() {
        if (!destroyed)
          return destroyed = !0, ended = !0, buffer.length = 0, stream2.writable = stream2.readable = !1, stream2.emit("close"), stream2;
      }, stream2.pause = function() {
        if (!stream2.paused)
          return stream2.paused = !0, stream2;
      }, stream2.resume = function() {
        return stream2.paused && (stream2.paused = !1, stream2.emit("resume")), drain(), stream2.paused || stream2.emit("drain"), stream2;
      }, stream2;
    }
  }
});

// ../../node_modules/from/index.js
var require_from = __commonJS({
  "../../node_modules/from/index.js"(exports2, module2) {
    "use strict";
    var Stream3 = require("stream");
    module2.exports = function from(source) {
      if (Array.isArray(source)) {
        var source_index = 0, source_len = source.length;
        return from(function(i2) {
          return source_index < source_len ? this.emit("data", source[source_index++]) : this.emit("end"), !0;
        });
      }
      var s = new Stream3(), i = 0;
      s.ended = !1, s.started = !1, s.readable = !0, s.writable = !1, s.paused = !1, s.ended = !1, s.pause = function() {
        s.started = !0, s.paused = !0;
      };
      function next() {
        if (s.started = !0, !s.ended)
          for (; !s.ended && !s.paused && source.call(s, i++, function() {
            !s.ended && !s.paused && process.nextTick(next);
          }); )
            ;
      }
      return s.resume = function() {
        s.started = !0, s.paused = !1, next();
      }, s.on("end", function() {
        s.ended = !0, s.readable = !1, process.nextTick(s.destroy);
      }), s.destroy = function() {
        s.ended = !0, s.emit("close");
      }, process.nextTick(function() {
        s.started || s.resume();
      }), s;
    };
  }
});

// ../../node_modules/duplexer/index.js
var require_duplexer = __commonJS({
  "../../node_modules/duplexer/index.js"(exports2, module2) {
    var Stream3 = require("stream"), writeMethods = ["write", "end", "destroy"], readMethods = ["resume", "pause"], readEvents = ["data", "close"], slice = Array.prototype.slice;
    module2.exports = duplex;
    function forEach(arr, fn) {
      if (arr.forEach)
        return arr.forEach(fn);
      for (var i = 0; i < arr.length; i++)
        fn(arr[i], i);
    }
    function duplex(writer, reader) {
      var stream2 = new Stream3(), ended = !1;
      return forEach(writeMethods, proxyWriter), forEach(readMethods, proxyReader), forEach(readEvents, proxyStream), reader.on("end", handleEnd), writer.on("drain", function() {
        stream2.emit("drain");
      }), writer.on("error", reemit), reader.on("error", reemit), stream2.writable = writer.writable, stream2.readable = reader.readable, stream2;
      function proxyWriter(methodName) {
        stream2[methodName] = method;
        function method() {
          return writer[methodName].apply(writer, arguments);
        }
      }
      function proxyReader(methodName) {
        stream2[methodName] = method;
        function method() {
          stream2.emit(methodName);
          var func = reader[methodName];
          if (func)
            return func.apply(reader, arguments);
          reader.emit(methodName);
        }
      }
      function proxyStream(methodName) {
        reader.on(methodName, reemit2);
        function reemit2() {
          var args = slice.call(arguments);
          args.unshift(methodName), stream2.emit.apply(stream2, args);
        }
      }
      function handleEnd() {
        if (!ended) {
          ended = !0;
          var args = slice.call(arguments);
          args.unshift("end"), stream2.emit.apply(stream2, args);
        }
      }
      function reemit(err) {
        stream2.emit("error", err);
      }
    }
  }
});

// ../../node_modules/map-stream/index.js
var require_map_stream = __commonJS({
  "../../node_modules/map-stream/index.js"(exports2, module2) {
    var Stream3 = require("stream").Stream;
    module2.exports = function(mapper, opts) {
      var stream2 = new Stream3(), self = this, inputs = 0, outputs = 0, ended = !1, paused = !1, destroyed = !1, lastWritten = 0, inNext = !1;
      this.opts = opts || {};
      var errorEventName = this.opts.failures ? "failure" : "error", writeQueue = {};
      stream2.writable = !0, stream2.readable = !0;
      function queueData(data, number) {
        var nextToWrite = lastWritten + 1;
        if (number === nextToWrite ? (data !== void 0 && stream2.emit.apply(stream2, ["data", data]), lastWritten++, nextToWrite++) : writeQueue[number] = data, writeQueue.hasOwnProperty(nextToWrite)) {
          var dataToWrite = writeQueue[nextToWrite];
          return delete writeQueue[nextToWrite], queueData(dataToWrite, nextToWrite);
        }
        outputs++, inputs === outputs && (paused && (paused = !1, stream2.emit("drain")), ended && end());
      }
      function next(err, data, number) {
        destroyed || (inNext = !0, (!err || self.opts.failures) && queueData(data, number), err && stream2.emit.apply(stream2, [errorEventName, err]), inNext = !1);
      }
      function wrappedMapper(input, number, callback) {
        return mapper.call(null, input, function(err, data) {
          callback(err, data, number);
        });
      }
      stream2.write = function(data) {
        if (ended)
          throw new Error("map stream is not writable");
        inNext = !1, inputs++;
        try {
          var written = wrappedMapper(data, inputs, next);
          return paused = written === !1, !paused;
        } catch (err) {
          if (inNext)
            throw err;
          return next(err), !paused;
        }
      };
      function end(data) {
        if (ended = !0, stream2.writable = !1, data !== void 0)
          return queueData(data, inputs);
        inputs == outputs && (stream2.readable = !1, stream2.emit("end"), stream2.destroy());
      }
      return stream2.end = function(data) {
        ended || end();
      }, stream2.destroy = function() {
        ended = destroyed = !0, stream2.writable = stream2.readable = paused = !1, process.nextTick(function() {
          stream2.emit("close");
        });
      }, stream2.pause = function() {
        paused = !0;
      }, stream2.resume = function() {
        paused = !1;
      }, stream2;
    };
  }
});

// ../../node_modules/pause-stream/index.js
var require_pause_stream = __commonJS({
  "../../node_modules/pause-stream/index.js"(exports2, module2) {
    module2.exports = require_through();
  }
});

// ../../node_modules/event-stream/node_modules/split/index.js
var require_split = __commonJS({
  "../../node_modules/event-stream/node_modules/split/index.js"(exports2, module2) {
    var through = require_through(), Decoder = require("string_decoder").StringDecoder;
    module2.exports = split;
    function split(matcher, mapper, options) {
      var decoder = new Decoder(), soFar = "", maxLength = options && options.maxLength;
      typeof matcher == "function" && (mapper = matcher, matcher = null), matcher || (matcher = /\r?\n/);
      function emit(stream2, piece) {
        if (mapper) {
          try {
            piece = mapper(piece);
          } catch (err) {
            return stream2.emit("error", err);
          }
          typeof piece < "u" && stream2.queue(piece);
        } else
          stream2.queue(piece);
      }
      function next(stream2, buffer) {
        var pieces = ((soFar ?? "") + buffer).split(matcher);
        soFar = pieces.pop(), maxLength && soFar.length > maxLength && stream2.emit("error", new Error("maximum buffer reached"));
        for (var i = 0; i < pieces.length; i++) {
          var piece = pieces[i];
          emit(stream2, piece);
        }
      }
      return through(
        function(b) {
          next(this, decoder.write(b));
        },
        function() {
          decoder.end && next(this, decoder.end()), soFar != null && emit(this, soFar), this.queue(null);
        }
      );
    }
  }
});

// ../../node_modules/stream-combiner/index.js
var require_stream_combiner = __commonJS({
  "../../node_modules/stream-combiner/index.js"(exports2, module2) {
    var duplexer = require_duplexer();
    module2.exports = function() {
      var streams = [].slice.call(arguments), first = streams[0], last = streams[streams.length - 1], thepipe = duplexer(first, last);
      if (streams.length == 1)
        return streams[0];
      if (!streams.length)
        throw new Error("connect called with empty args");
      function recurse(streams2) {
        streams2.length < 2 || (streams2[0].pipe(streams2[1]), recurse(streams2.slice(1)));
      }
      recurse(streams);
      function onerror() {
        var args = [].slice.call(arguments);
        args.unshift("error"), thepipe.emit.apply(thepipe, args);
      }
      for (var i = 1; i < streams.length - 1; i++)
        streams[i].on("error", onerror);
      return thepipe;
    };
  }
});

// ../../node_modules/event-stream/index.js
var require_event_stream = __commonJS({
  "../../node_modules/event-stream/index.js"(exports2) {
    var Stream3 = require("stream").Stream, es = exports2, through = require_through(), from = require_from(), duplex = require_duplexer(), map = require_map_stream(), pause = require_pause_stream(), split = require_split(), pipeline = require_stream_combiner(), immediately = global.setImmediate || process.nextTick;
    es.Stream = Stream3;
    es.through = through;
    es.from = from;
    es.duplex = duplex;
    es.map = map;
    es.pause = pause;
    es.split = split;
    es.pipeline = es.connect = es.pipe = pipeline;
    es.concat = //actually this should be called concat
    es.merge = function() {
      var toMerge = [].slice.call(arguments);
      toMerge.length === 1 && toMerge[0] instanceof Array && (toMerge = toMerge[0]);
      var stream2 = new Stream3();
      stream2.setMaxListeners(0);
      var endCount = 0;
      return stream2.writable = stream2.readable = !0, toMerge.length ? toMerge.forEach(function(e) {
        e.pipe(stream2, { end: !1 });
        var ended = !1;
        e.on("end", function() {
          ended || (ended = !0, endCount++, endCount == toMerge.length && stream2.emit("end"));
        });
      }) : process.nextTick(function() {
        stream2.emit("end");
      }), stream2.write = function(data) {
        this.emit("data", data);
      }, stream2.destroy = function() {
        toMerge.forEach(function(e) {
          e.destroy && e.destroy();
        });
      }, stream2;
    };
    es.writeArray = function(done) {
      if (typeof done != "function")
        throw new Error("function writeArray (done): done must be function");
      var a = new Stream3(), array = [], isDone = !1;
      return a.write = function(l) {
        array.push(l);
      }, a.end = function() {
        isDone = !0, done(null, array);
      }, a.writable = !0, a.readable = !1, a.destroy = function() {
        a.writable = a.readable = !1, !isDone && done(new Error("destroyed before end"), array);
      }, a;
    };
    es.readArray = function(array) {
      var stream2 = new Stream3(), i = 0, paused = !1, ended = !1;
      if (stream2.readable = !0, stream2.writable = !1, !Array.isArray(array))
        throw new Error("event-stream.read expects an array");
      return stream2.resume = function() {
        if (!ended) {
          paused = !1;
          for (var l = array.length; i < l && !paused && !ended; )
            stream2.emit("data", array[i++]);
          i == l && !ended && (ended = !0, stream2.readable = !1, stream2.emit("end"));
        }
      }, process.nextTick(stream2.resume), stream2.pause = function() {
        paused = !0;
      }, stream2.destroy = function() {
        ended = !0, stream2.emit("close");
      }, stream2;
    };
    es.readable = function(func, continueOnError) {
      var stream2 = new Stream3(), i = 0, paused = !1, ended = !1, reading = !1;
      if (stream2.readable = !0, stream2.writable = !1, typeof func != "function")
        throw new Error("event-stream.readable expects async function");
      stream2.on("end", function() {
        ended = !0;
      });
      function get(err, data) {
        err ? (stream2.emit("error", err), continueOnError || stream2.emit("end")) : arguments.length > 1 && stream2.emit("data", data), immediately(function() {
          if (!(ended || paused || reading))
            try {
              reading = !0, func.call(stream2, i++, function() {
                reading = !1, get.apply(null, arguments);
              });
            } catch (err2) {
              stream2.emit("error", err2);
            }
        });
      }
      return stream2.resume = function() {
        paused = !1, get();
      }, process.nextTick(get), stream2.pause = function() {
        paused = !0;
      }, stream2.destroy = function() {
        stream2.emit("end"), stream2.emit("close"), ended = !0;
      }, stream2;
    };
    es.mapSync = function(sync2) {
      return es.through(function(data) {
        var mappedData;
        try {
          mappedData = sync2(data);
        } catch (err) {
          return this.emit("error", err);
        }
        mappedData !== void 0 && this.emit("data", mappedData);
      });
    };
    es.log = function(name) {
      return es.through(function(data) {
        var args = [].slice.call(arguments);
        name ? console.error(name, data) : console.error(data), this.emit("data", data);
      });
    };
    es.child = function(child) {
      return es.duplex(child.stdin, child.stdout);
    };
    es.parse = function(options) {
      var emitError = !!(options && options.error);
      return es.through(function(data) {
        var obj;
        try {
          data && (obj = JSON.parse(data.toString()));
        } catch (err) {
          return emitError ? this.emit("error", err) : console.error(err, "attempting to parse:", data);
        }
        obj !== void 0 && this.emit("data", obj);
      });
    };
    es.stringify = function() {
      var Buffer2 = require("buffer").Buffer;
      return es.mapSync(function(e) {
        return JSON.stringify(Buffer2.isBuffer(e) ? e.toString() : e) + `
`;
      });
    };
    es.replace = function(from2, to) {
      return es.pipeline(es.split(from2), es.join(to));
    };
    es.join = function(str) {
      if (typeof str == "function")
        return es.wait(str);
      var first = !0;
      return es.through(function(data) {
        return first || this.emit("data", str), first = !1, this.emit("data", data), !0;
      });
    };
    es.wait = function(callback) {
      var arr = [];
      return es.through(
        function(data) {
          arr.push(data);
        },
        function() {
          var body = Buffer.isBuffer(arr[0]) ? Buffer.concat(arr) : arr.join("");
          this.emit("data", body), this.emit("end"), callback && callback(null, body);
        }
      );
    };
    es.pipeable = function() {
      throw new Error("[EVENT-STREAM] es.pipeable is deprecated");
    };
  }
});

// ../../node_modules/ps-tree/index.js
var require_ps_tree = __commonJS({
  "../../node_modules/ps-tree/index.js"(exports2, module2) {
    "use strict";
    var spawn2 = require("child_process").spawn, es = require_event_stream();
    module2.exports = function(pid, callback) {
      var headers = null;
      if (typeof callback != "function")
        throw new Error("childrenOfPid(pid, callback) expects callback");
      typeof pid == "number" && (pid = pid.toString());
      var processLister;
      process.platform === "win32" ? processLister = spawn2("wmic.exe", ["PROCESS", "GET", "Name,ProcessId,ParentProcessId,Status"]) : processLister = spawn2("ps", ["-A", "-o", "ppid,pid,stat,comm"]), es.connect(
        // spawn('ps', ['-A', '-o', 'ppid,pid,stat,comm']).stdout,
        processLister.stdout,
        es.split(),
        es.map(function(line, cb) {
          var columns = line.trim().split(/\s+/);
          if (!headers)
            return headers = columns, headers = headers.map(normalizeHeader), cb();
          for (var row = {}, h = headers.slice(); h.length; )
            row[h.shift()] = h.length ? columns.shift() : columns.join(" ");
          return cb(null, row);
        }),
        es.writeArray(function(err, ps) {
          var parents = {}, children = [];
          parents[pid] = !0, ps.forEach(function(proc3) {
            parents[proc3.PPID] && (parents[proc3.PID] = !0, children.push(proc3));
          }), callback(null, children);
        })
      ).on("error", callback);
    };
    function normalizeHeader(str) {
      if (process.platform !== "win32")
        return str;
      switch (str) {
        case "Name":
          return "COMMAND";
        case "ParentProcessId":
          return "PPID";
        case "ProcessId":
          return "PID";
        case "Status":
          return "STAT";
        default:
          throw new Error("Unknown process listing header: " + str);
      }
    }
  }
});

// ../../node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "../../node_modules/merge2/index.js"(exports2, module2) {
    "use strict";
    var Stream3 = require("stream"), PassThrough = Stream3.PassThrough, slice = Array.prototype.slice;
    module2.exports = merge22;
    function merge22() {
      let streamsQueue = [], args = slice.call(arguments), merging = !1, options = args[args.length - 1];
      options && !Array.isArray(options) && options.pipe == null ? args.pop() : options = {};
      let doEnd = options.end !== !1, doPipeError = options.pipeError === !0;
      options.objectMode == null && (options.objectMode = !0), options.highWaterMark == null && (options.highWaterMark = 64 * 1024);
      let mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++)
          streamsQueue.push(pauseStreams(arguments[i], options));
        return mergeStream(), this;
      }
      function mergeStream() {
        if (merging)
          return;
        merging = !0;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        Array.isArray(streams) || (streams = [streams]);
        let pipesCount = streams.length + 1;
        function next() {
          --pipesCount > 0 || (merging = !1, mergeStream());
        }
        function pipe(stream2) {
          function onend() {
            stream2.removeListener("merge2UnpipeEnd", onend), stream2.removeListener("end", onend), doPipeError && stream2.removeListener("error", onerror), next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream2._readableState.endEmitted)
            return next();
          stream2.on("merge2UnpipeEnd", onend), stream2.on("end", onend), doPipeError && stream2.on("error", onerror), stream2.pipe(mergedStream, { end: !1 }), stream2.resume();
        }
        for (let i = 0; i < streams.length; i++)
          pipe(streams[i]);
        next();
      }
      function endStream() {
        merging = !1, mergedStream.emit("queueDrain"), doEnd && mergedStream.end();
      }
      return mergedStream.setMaxListeners(0), mergedStream.add = addStream, mergedStream.on("unpipe", function(stream2) {
        stream2.emit("merge2UnpipeEnd");
      }), args.length && addStream.apply(null, args), mergedStream;
    }
    function pauseStreams(streams, options) {
      if (Array.isArray(streams))
        for (let i = 0, len = streams.length; i < len; i++)
          streams[i] = pauseStreams(streams[i], options);
      else {
        if (!streams._readableState && streams.pipe && (streams = streams.pipe(PassThrough(options))), !streams._readableState || !streams.pause || !streams.pipe)
          throw new Error("Only readable stream can be merged.");
        streams.pause();
      }
      return streams;
    }
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/utils/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.splitWhen = exports2.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports2.flatten = flatten;
    function splitWhen(items, predicate) {
      let result = [[]], groupIndex = 0;
      for (let item of items)
        predicate(item) ? (groupIndex++, result[groupIndex] = []) : result[groupIndex].push(item);
      return result;
    }
    exports2.splitWhen = splitWhen;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/utils/errno.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/utils/fs.js
var require_fs2 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name, this.isBlockDevice = stats.isBlockDevice.bind(stats), this.isCharacterDevice = stats.isCharacterDevice.bind(stats), this.isDirectory = stats.isDirectory.bind(stats), this.isFIFO = stats.isFIFO.bind(stats), this.isFile = stats.isFile.bind(stats), this.isSocket = stats.isSocket.bind(stats), this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/utils/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.convertPosixPathToPattern = exports2.convertWindowsPathToPattern = exports2.convertPathToPattern = exports2.escapePosixPath = exports2.escapeWindowsPath = exports2.escape = exports2.removeLeadingDotSegment = exports2.makeAbsolute = exports2.unixify = void 0;
    var os2 = require("os"), path6 = require("path"), IS_WINDOWS_PLATFORM = os2.platform() === "win32", LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2, POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g, WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g, DOS_DEVICE_PATH_RE = /^\\\\([.?])/, WINDOWS_BACKSLASHES_RE = /\\(?![!()+@[\]{}])/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd2, filepath) {
      return path6.resolve(cwd2, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        let secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\")
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment;
    exports2.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
    function escapeWindowsPath(pattern) {
      return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escapeWindowsPath = escapeWindowsPath;
    function escapePosixPath(pattern) {
      return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escapePosixPath = escapePosixPath;
    exports2.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
    function convertWindowsPathToPattern(filepath) {
      return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
    }
    exports2.convertWindowsPathToPattern = convertWindowsPathToPattern;
    function convertPosixPathToPattern(filepath) {
      return escapePosixPath(filepath);
    }
    exports2.convertPosixPathToPattern = convertPosixPathToPattern;
  }
});

// ../../node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "../../node_modules/is-extglob/index.js"(exports2, module2) {
    module2.exports = function(str) {
      if (typeof str != "string" || str === "")
        return !1;
      for (var match2; match2 = /(\\).|([@?!+*]\(.*\))/g.exec(str); ) {
        if (match2[2])
          return !0;
        str = str.slice(match2.index + match2[0].length);
      }
      return !1;
    };
  }
});

// ../../node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "../../node_modules/is-glob/index.js"(exports2, module2) {
    var isExtglob = require_is_extglob(), chars = { "{": "}", "(": ")", "[": "]" }, strictCheck = function(str) {
      if (str[0] === "!")
        return !0;
      for (var index = 0, pipeIndex = -2, closeSquareIndex = -2, closeCurlyIndex = -2, closeParenIndex = -2, backSlashIndex = -2; index < str.length; ) {
        if (str[index] === "*" || str[index + 1] === "?" && /[\].+)]/.test(str[index]) || closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]" && (closeSquareIndex < index && (closeSquareIndex = str.indexOf("]", index)), closeSquareIndex > index && (backSlashIndex === -1 || backSlashIndex > closeSquareIndex || (backSlashIndex = str.indexOf("\\", index), backSlashIndex === -1 || backSlashIndex > closeSquareIndex))) || closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}" && (closeCurlyIndex = str.indexOf("}", index), closeCurlyIndex > index && (backSlashIndex = str.indexOf("\\", index), backSlashIndex === -1 || backSlashIndex > closeCurlyIndex)) || closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")" && (closeParenIndex = str.indexOf(")", index), closeParenIndex > index && (backSlashIndex = str.indexOf("\\", index), backSlashIndex === -1 || backSlashIndex > closeParenIndex)) || pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|" && (pipeIndex < index && (pipeIndex = str.indexOf("|", index)), pipeIndex !== -1 && str[pipeIndex + 1] !== ")" && (closeParenIndex = str.indexOf(")", pipeIndex), closeParenIndex > pipeIndex && (backSlashIndex = str.indexOf("\\", pipeIndex), backSlashIndex === -1 || backSlashIndex > closeParenIndex))))
          return !0;
        if (str[index] === "\\") {
          var open3 = str[index + 1];
          index += 2;
          var close = chars[open3];
          if (close) {
            var n = str.indexOf(close, index);
            n !== -1 && (index = n + 1);
          }
          if (str[index] === "!")
            return !0;
        } else
          index++;
      }
      return !1;
    }, relaxedCheck = function(str) {
      if (str[0] === "!")
        return !0;
      for (var index = 0; index < str.length; ) {
        if (/[*?{}()[\]]/.test(str[index]))
          return !0;
        if (str[index] === "\\") {
          var open3 = str[index + 1];
          index += 2;
          var close = chars[open3];
          if (close) {
            var n = str.indexOf(close, index);
            n !== -1 && (index = n + 1);
          }
          if (str[index] === "!")
            return !0;
        } else
          index++;
      }
      return !1;
    };
    module2.exports = function(str, options) {
      if (typeof str != "string" || str === "")
        return !1;
      if (isExtglob(str))
        return !0;
      var check = strictCheck;
      return options && options.strict === !1 && (check = relaxedCheck), check(str);
    };
  }
});

// ../../node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "../../node_modules/glob-parent/index.js"(exports2, module2) {
    "use strict";
    var isGlob = require_is_glob(), pathPosixDirname = require("path").posix.dirname, isWin32 = require("os").platform() === "win32", slash2 = "/", backslash = /\\/g, enclosure = /[\{\[].*[\}\]]$/, globby4 = /(^|[^\\])([\{\[]|\([^\)]+$)/, escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function(str, opts) {
      var options = Object.assign({ flipBackslashes: !0 }, opts);
      options.flipBackslashes && isWin32 && str.indexOf(slash2) < 0 && (str = str.replace(backslash, slash2)), enclosure.test(str) && (str += slash2), str += "a";
      do
        str = pathPosixDirname(str);
      while (isGlob(str) || globby4.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// ../../node_modules/braces/lib/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = (num) => typeof num == "number" ? Number.isInteger(num) : typeof num == "string" && num.trim() !== "" ? Number.isInteger(Number(num)) : !1;
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min, max, step = 1, limit) => limit === !1 || !exports2.isInteger(min) || !exports2.isInteger(max) ? !1 : (Number(max) - Number(min)) / Number(step) >= limit;
    exports2.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      node && (type && node.type === type || node.type === "open" || node.type === "close") && node.escaped !== !0 && (node.value = "\\" + node.value, node.escaped = !0);
    };
    exports2.encloseBrace = (node) => node.type !== "brace" || node.commas >> 0 + node.ranges >> 0 ? !1 : (node.invalid = !0, !0);
    exports2.isInvalidBrace = (block) => block.type !== "brace" ? !1 : block.invalid === !0 || block.dollar ? !0 : !(block.commas >> 0 + block.ranges >> 0) || block.open !== !0 || block.close !== !0 ? (block.invalid = !0, !0) : !1;
    exports2.isOpenOrClose = (node) => node.type === "open" || node.type === "close" ? !0 : node.open === !0 || node.close === !0;
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => (node.type === "text" && acc.push(node.value), node.type === "range" && (node.type = "text"), acc), []);
    exports2.flatten = (...args) => {
      let result = [], flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      return flat(args), result;
    };
  }
});

// ../../node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent), invalidNode = node.invalid === !0 && options.escapeInvalid === !0, output = "";
        if (node.value)
          return (invalidBlock || invalidNode) && utils.isOpenOrClose(node) ? "\\" + node.value : node.value;
        if (node.value)
          return node.value;
        if (node.nodes)
          for (let child of node.nodes)
            output += stringify(child);
        return output;
      };
      return stringify(ast);
    };
  }
});

// ../../node_modules/to-regex-range/node_modules/is-number/index.js
var require_is_number = __commonJS({
  "../../node_modules/to-regex-range/node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(num) {
      return typeof num == "number" ? num - num === 0 : typeof num == "string" && num.trim() !== "" ? Number.isFinite ? Number.isFinite(+num) : isFinite(+num) : !1;
    };
  }
});

// ../../node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "../../node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    var isNumber = require_is_number(), toRegexRange = (min, max, options) => {
      if (isNumber(min) === !1)
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      if (max === void 0 || min === max)
        return String(min);
      if (isNumber(max) === !1)
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      let opts = { relaxZeros: !0, ...options };
      typeof opts.strictZeros == "boolean" && (opts.relaxZeros = opts.strictZeros === !1);
      let relax = String(opts.relaxZeros), shorthand = String(opts.shorthand), capture = String(opts.capture), wrap2 = String(opts.wrap), cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap2;
      if (toRegexRange.cache.hasOwnProperty(cacheKey))
        return toRegexRange.cache[cacheKey].result;
      let a = Math.min(min, max), b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        return opts.capture ? `(${result})` : opts.wrap === !1 ? result : `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max), state = { min, max, a, b }, positives = [], negatives = [];
      if (isPadded && (state.isPadded = isPadded, state.maxLen = String(state.max).length), a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts), a = state.a = 0;
      }
      return b >= 0 && (positives = splitToPatterns(a, b, state, opts)), state.negatives = negatives, state.positives = positives, state.result = collatePatterns(negatives, positives, opts), opts.capture === !0 ? state.result = `(${state.result})` : opts.wrap !== !1 && positives.length + negatives.length > 1 && (state.result = `(?:${state.result})`), toRegexRange.cache[cacheKey] = state, state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", !1, options) || [], onlyPositive = filterPatterns(pos, neg, "", !1, options) || [], intersected = filterPatterns(neg, pos, "-?", !0, options) || [];
      return onlyNegative.concat(intersected).concat(onlyPositive).join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1, zeros = 1, stop = countNines(min, nines), stops = /* @__PURE__ */ new Set([max]);
      for (; min <= stop && stop <= max; )
        stops.add(stop), nines += 1, stop = countNines(min, nines);
      for (stop = countZeros(max + 1, zeros) - 1; min < stop && stop <= max; )
        stops.add(stop), zeros += 1, stop = countZeros(max + 1, zeros) - 1;
      return stops = [...stops], stops.sort(compare), stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop)
        return { pattern: start, count: [], digits: 0 };
      let zipped = zip(start, stop), digits = zipped.length, pattern = "", count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        startDigit === stopDigit ? pattern += startDigit : startDigit !== "0" || stopDigit !== "9" ? pattern += toCharacterClass(startDigit, stopDigit, options) : count++;
      }
      return count && (pattern += options.shorthand === !0 ? "\\d" : "[0-9]"), { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max), tokens = [], start = min, prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i], obj = rangeToPattern(String(start), String(max2), options), zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          prev.count.length > 1 && prev.count.pop(), prev.count.push(obj.count[0]), prev.string = prev.pattern + toQuantifier(prev.count), start = max2 + 1;
          continue;
        }
        tok.isPadded && (zeros = padZeros(max2, tok, options)), obj.string = zeros + obj.pattern + toQuantifier(obj.count), tokens.push(obj), start = max2 + 1, prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        !intersection && !contains(comparison, "string", string) && result.push(prefix + string), intersection && contains(comparison, "string", string) && result.push(prefix + string);
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      return stop || start > 1 ? `{${start + (stop ? "," + stop : "")}}` : "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded)
        return value;
      let diff = Math.abs(tok.maxLen - String(value).length), relax = options.relaxZeros !== !1;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default:
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// ../../node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "../../node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    var util = require("util"), toRegexRange = require_to_regex_range(), isObject = (val) => val !== null && typeof val == "object" && !Array.isArray(val), transform = (toNumber) => (value) => toNumber === !0 ? Number(value) : String(value), isValidValue = (value) => typeof value == "number" || typeof value == "string" && value !== "", isNumber = (num) => Number.isInteger(+num), zeros = (input) => {
      let value = `${input}`, index = -1;
      if (value[0] === "-" && (value = value.slice(1)), value === "0")
        return !1;
      for (; value[++index] === "0"; )
        ;
      return index > 0;
    }, stringify = (start, end, options) => typeof start == "string" || typeof end == "string" ? !0 : options.stringify === !0, pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        dash && (input = input.slice(1)), input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      return toNumber === !1 ? String(input) : input;
    }, toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      for (negative && (input = input.slice(1), maxLength--); input.length < maxLength; )
        input = "0" + input;
      return negative ? "-" + input : input;
    }, toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0), parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:", positives = "", negatives = "", result;
      return parts.positives.length && (positives = parts.positives.join("|")), parts.negatives.length && (negatives = `-(${prefix}${parts.negatives.join("|")})`), positives && negatives ? result = `${positives}|${negatives}` : result = positives || negatives, options.wrap ? `(${prefix}${result})` : result;
    }, toRange = (a, b, isNumbers, options) => {
      if (isNumbers)
        return toRegexRange(a, b, { wrap: !1, ...options });
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    }, toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap2 = options.wrap === !0, prefix = options.capture ? "" : "?:";
        return wrap2 ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    }, rangeError = (...args) => new RangeError("Invalid range arguments: " + util.inspect(...args)), invalidRange = (start, end, options) => {
      if (options.strictRanges === !0)
        throw rangeError([start, end]);
      return [];
    }, invalidStep = (step, options) => {
      if (options.strictRanges === !0)
        throw new TypeError(`Expected step "${step}" to be a number`);
      return [];
    }, fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start), b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === !0)
          throw rangeError([start, end]);
        return [];
      }
      a === 0 && (a = 0), b === 0 && (b = 0);
      let descending = a > b, startString = String(start), endString = String(end), stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString), maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0, toNumber = padded === !1 && stringify(start, end, options) === !1, format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1)
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), !0, options);
      let parts = { negatives: [], positives: [] }, push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num)), range = [], index = 0;
      for (; descending ? a >= b : a <= b; )
        options.toRegex === !0 && step > 1 ? push(a) : range.push(pad(format(a, index), maxLen, toNumber)), a = descending ? a - step : a + step, index++;
      return options.toRegex === !0 ? step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: !1, ...options }) : range;
    }, fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1)
        return invalidRange(start, end, options);
      let format = options.transform || ((val) => String.fromCharCode(val)), a = `${start}`.charCodeAt(0), b = `${end}`.charCodeAt(0), descending = a > b, min = Math.min(a, b), max = Math.max(a, b);
      if (options.toRegex && step === 1)
        return toRange(min, max, !1, options);
      let range = [], index = 0;
      for (; descending ? a >= b : a <= b; )
        range.push(format(a, index)), a = descending ? a - step : a + step, index++;
      return options.toRegex === !0 ? toRegex(range, null, { wrap: !1, options }) : range;
    }, fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start))
        return [start];
      if (!isValidValue(start) || !isValidValue(end))
        return invalidRange(start, end, options);
      if (typeof step == "function")
        return fill(start, end, 1, { transform: step });
      if (isObject(step))
        return fill(start, end, 0, step);
      let opts = { ...options };
      return opts.capture === !0 && (opts.wrap = !0), step = step || opts.step || 1, isNumber(step) ? isNumber(start) && isNumber(end) ? fillNumbers(start, end, step, opts) : fillLetters(start, end, Math.max(Math.abs(step), 1), opts) : step != null && !isObject(step) ? invalidStep(step, opts) : fill(start, end, 1, step);
    };
    module2.exports = fill;
  }
});

// ../../node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "../../node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range(), utils = require_utils3(), compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent), invalidNode = node.invalid === !0 && options.escapeInvalid === !0, invalid = invalidBlock === !0 || invalidNode === !0, prefix = options.escapeInvalid === !0 ? "\\" : "", output = "";
        if (node.isOpen === !0 || node.isClose === !0)
          return prefix + node.value;
        if (node.type === "open")
          return invalid ? prefix + node.value : "(";
        if (node.type === "close")
          return invalid ? prefix + node.value : ")";
        if (node.type === "comma")
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        if (node.value)
          return node.value;
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes), range = fill(...args, { ...options, wrap: !1, toRegex: !0 });
          if (range.length !== 0)
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
        }
        if (node.nodes)
          for (let child of node.nodes)
            output += walk(child, node);
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// ../../node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "../../node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range(), stringify = require_stringify(), utils = require_utils3(), append = (queue = "", stash = "", enclose = !1) => {
      let result = [];
      if (queue = [].concat(queue), stash = [].concat(stash), !stash.length)
        return queue;
      if (!queue.length)
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      for (let item of queue)
        if (Array.isArray(item))
          for (let value of item)
            result.push(append(value, stash, enclose));
        else
          for (let ele of stash)
            enclose === !0 && typeof ele == "string" && (ele = `{${ele}}`), result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
      return utils.flatten(result);
    }, expand2 = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit, walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent, q = parent.queue;
        for (; p.type !== "brace" && p.type !== "root" && p.parent; )
          p = p.parent, q = p.queue;
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== !0 && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit))
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          let range = fill(...args, options);
          range.length === 0 && (range = stringify(node, options)), q.push(append(q.pop(), range)), node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node), queue = node.queue, block = node;
        for (; block.type !== "brace" && block.type !== "root" && block.parent; )
          block = block.parent, queue = block.queue;
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            i === 1 && queue.push(""), queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          child.nodes && walk(child, node);
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand2;
  }
});

// ../../node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: `
`,
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// ../../node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "../../node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify(), {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants(), parse6 = (input, options = {}) => {
      if (typeof input != "string")
        throw new TypeError("Expected a string");
      let opts = options || {}, max = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max)
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      let ast = { type: "root", input, nodes: [] }, stack = [ast], block = ast, prev = ast, brackets = 0, length = input.length, index = 0, depth = 0, value, memo = {}, advance = () => input[index++], push = (node) => {
        if (node.type === "text" && prev.type === "dot" && (prev.type = "text"), prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        return block.nodes.push(node), node.parent = block, node.prev = prev, prev = node, node;
      };
      for (push({ type: "bos" }); index < length; )
        if (block = stack[stack.length - 1], value = advance(), !(value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE)) {
          if (value === CHAR_BACKSLASH) {
            push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
            continue;
          }
          if (value === CHAR_RIGHT_SQUARE_BRACKET) {
            push({ type: "text", value: "\\" + value });
            continue;
          }
          if (value === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            let closed = !0, next;
            for (; index < length && (next = advance()); ) {
              if (value += next, next === CHAR_LEFT_SQUARE_BRACKET) {
                brackets++;
                continue;
              }
              if (next === CHAR_BACKSLASH) {
                value += advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET && (brackets--, brackets === 0))
                break;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_LEFT_PARENTHESES) {
            block = push({ type: "paren", nodes: [] }), stack.push(block), push({ type: "text", value });
            continue;
          }
          if (value === CHAR_RIGHT_PARENTHESES) {
            if (block.type !== "paren") {
              push({ type: "text", value });
              continue;
            }
            block = stack.pop(), push({ type: "text", value }), block = stack[stack.length - 1];
            continue;
          }
          if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
            let open3 = value, next;
            for (options.keepQuotes !== !0 && (value = ""); index < length && (next = advance()); ) {
              if (next === CHAR_BACKSLASH) {
                value += next + advance();
                continue;
              }
              if (next === open3) {
                options.keepQuotes === !0 && (value += next);
                break;
              }
              value += next;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_LEFT_CURLY_BRACE) {
            depth++;
            let brace = {
              type: "brace",
              open: !0,
              close: !1,
              dollar: prev.value && prev.value.slice(-1) === "$" || block.dollar === !0,
              depth,
              commas: 0,
              ranges: 0,
              nodes: []
            };
            block = push(brace), stack.push(block), push({ type: "open", value });
            continue;
          }
          if (value === CHAR_RIGHT_CURLY_BRACE) {
            if (block.type !== "brace") {
              push({ type: "text", value });
              continue;
            }
            let type = "close";
            block = stack.pop(), block.close = !0, push({ type, value }), depth--, block = stack[stack.length - 1];
            continue;
          }
          if (value === CHAR_COMMA && depth > 0) {
            if (block.ranges > 0) {
              block.ranges = 0;
              let open3 = block.nodes.shift();
              block.nodes = [open3, { type: "text", value: stringify(block) }];
            }
            push({ type: "comma", value }), block.commas++;
            continue;
          }
          if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
            let siblings = block.nodes;
            if (depth === 0 || siblings.length === 0) {
              push({ type: "text", value });
              continue;
            }
            if (prev.type === "dot") {
              if (block.range = [], prev.value += value, prev.type = "range", block.nodes.length !== 3 && block.nodes.length !== 5) {
                block.invalid = !0, block.ranges = 0, prev.type = "text";
                continue;
              }
              block.ranges++, block.args = [];
              continue;
            }
            if (prev.type === "range") {
              siblings.pop();
              let before = siblings[siblings.length - 1];
              before.value += prev.value + value, prev = before, block.ranges--;
              continue;
            }
            push({ type: "dot", value });
            continue;
          }
          push({ type: "text", value });
        }
      do
        if (block = stack.pop(), block.type !== "root") {
          block.nodes.forEach((node) => {
            node.nodes || (node.type === "open" && (node.isOpen = !0), node.type === "close" && (node.isClose = !0), node.nodes || (node.type = "text"), node.invalid = !0);
          });
          let parent = stack[stack.length - 1], index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      while (stack.length > 0);
      return push({ type: "eos" }), ast;
    };
    module2.exports = parse6;
  }
});

// ../../node_modules/braces/index.js
var require_braces = __commonJS({
  "../../node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify(), compile = require_compile(), expand2 = require_expand(), parse6 = require_parse2(), braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input))
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          Array.isArray(result) ? output.push(...result) : output.push(result);
        }
      else
        output = [].concat(braces.create(input, options));
      return options && options.expand === !0 && options.nodupes === !0 && (output = [...new Set(output)]), output;
    };
    braces.parse = (input, options = {}) => parse6(input, options);
    braces.stringify = (input, options = {}) => stringify(typeof input == "string" ? braces.parse(input, options) : input, options);
    braces.compile = (input, options = {}) => (typeof input == "string" && (input = braces.parse(input, options)), compile(input, options));
    braces.expand = (input, options = {}) => {
      typeof input == "string" && (input = braces.parse(input, options));
      let result = expand2(input, options);
      return options.noempty === !0 && (result = result.filter(Boolean)), options.nodupes === !0 && (result = [...new Set(result)]), result;
    };
    braces.create = (input, options = {}) => input === "" || input.length < 3 ? [input] : options.expand !== !0 ? braces.compile(input, options) : braces.expand(input, options);
    module2.exports = braces;
  }
});

// ../../node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), WIN_SLASH = "\\\\/", WIN_NO_SLASH = `[^${WIN_SLASH}]`, DOT_LITERAL = "\\.", PLUS_LITERAL = "\\+", QMARK_LITERAL = "\\?", SLASH_LITERAL = "\\/", ONE_CHAR = "(?=.)", QMARK = "[^/]", END_ANCHOR = `(?:${SLASH_LITERAL}|$)`, START_ANCHOR = `(?:^|${SLASH_LITERAL})`, DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`, NO_DOT = `(?!${DOT_LITERAL})`, NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`, NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`, NO_DOTS_SLASH = `(?!${DOTS_SLASH})`, QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`, STAR = `${QMARK}*?`, POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    }, WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    }, POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path6.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win322) {
        return win322 === !0 ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../../node_modules/picomatch/lib/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path6 = require("path"), win322 = process.platform === "win32", {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports2.isObject = (val) => val !== null && typeof val == "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => str.replace(REGEX_REMOVE_BACKSLASH, (match2) => match2 === "\\" ? "" : match2);
    exports2.supportsLookbehinds = () => {
      let segs = process.version.slice(1).split(".").map(Number);
      return segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10;
    };
    exports2.isWindows = (options) => options && typeof options.windows == "boolean" ? options.windows : win322 === !0 || path6.sep === "\\";
    exports2.escapeLast = (input, char, lastIdx) => {
      let idx = input.lastIndexOf(char, lastIdx);
      return idx === -1 ? input : input[idx - 1] === "\\" ? exports2.escapeLast(input, char, idx - 1) : `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      return output.startsWith("./") && (output = output.slice(2), state.prefix = "./"), output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      let prepend = options.contains ? "" : "^", append = options.contains ? "" : "$", output = `${prepend}(?:${input})${append}`;
      return state.negated === !0 && (output = `(?:^(?!${output}).*$)`), output;
    };
  }
});

// ../../node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "../../node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4(), {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2(), isPathSeparator = (code) => code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH, depth = (token) => {
      token.isPrefix !== !0 && (token.depth = token.isGlobstar ? 1 / 0 : 1);
    }, scan = (input, options) => {
      let opts = options || {}, length = input.length - 1, scanToEnd = opts.parts === !0 || opts.scanToEnd === !0, slashes = [], tokens = [], parts = [], str = input, index = -1, start = 0, lastIndex = 0, isBrace = !1, isBracket = !1, isGlob = !1, isExtglob = !1, isGlobstar = !1, braceEscaped = !1, backslashes = !1, negated = !1, negatedExtglob = !1, finished = !1, braces = 0, prev, code, token = { value: "", depth: 0, isGlob: !1 }, eos = () => index >= length, peek = () => str.charCodeAt(index + 1), advance = () => (prev = code, str.charCodeAt(++index));
      for (; index < length; ) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = !0, code = advance(), code === CHAR_LEFT_CURLY_BRACE && (braceEscaped = !0);
          continue;
        }
        if (braceEscaped === !0 || code === CHAR_LEFT_CURLY_BRACE) {
          for (braces++; eos() !== !0 && (code = advance()); ) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = !0, advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== !0 && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              if (isBrace = token.isBrace = !0, isGlob = token.isGlob = !0, finished = !0, scanToEnd === !0)
                continue;
              break;
            }
            if (braceEscaped !== !0 && code === CHAR_COMMA) {
              if (isBrace = token.isBrace = !0, isGlob = token.isGlob = !0, finished = !0, scanToEnd === !0)
                continue;
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE && (braces--, braces === 0)) {
              braceEscaped = !1, isBrace = token.isBrace = !0, finished = !0;
              break;
            }
          }
          if (scanToEnd === !0)
            continue;
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          if (slashes.push(index), tokens.push(token), token = { value: "", depth: 0, isGlob: !1 }, finished === !0)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== !0 && (code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK) === !0 && peek() === CHAR_LEFT_PARENTHESES) {
          if (isGlob = token.isGlob = !0, isExtglob = token.isExtglob = !0, finished = !0, code === CHAR_EXCLAMATION_MARK && index === start && (negatedExtglob = !0), scanToEnd === !0) {
            for (; eos() !== !0 && (code = advance()); ) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = !0, code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob = token.isGlob = !0, finished = !0;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK && (isGlobstar = token.isGlobstar = !0), isGlob = token.isGlob = !0, finished = !0, scanToEnd === !0)
            continue;
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          if (isGlob = token.isGlob = !0, finished = !0, scanToEnd === !0)
            continue;
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          for (; eos() !== !0 && (next = advance()); ) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = !0, advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = !0, isGlob = token.isGlob = !0, finished = !0;
              break;
            }
          }
          if (scanToEnd === !0)
            continue;
          break;
        }
        if (opts.nonegate !== !0 && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = !0, start++;
          continue;
        }
        if (opts.noparen !== !0 && code === CHAR_LEFT_PARENTHESES) {
          if (isGlob = token.isGlob = !0, scanToEnd === !0) {
            for (; eos() !== !0 && (code = advance()); ) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = !0, code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = !0;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === !0) {
          if (finished = !0, scanToEnd === !0)
            continue;
          break;
        }
      }
      opts.noext === !0 && (isExtglob = !1, isGlob = !1);
      let base = str, prefix = "", glob2 = "";
      start > 0 && (prefix = str.slice(0, start), str = str.slice(start), lastIndex -= start), base && isGlob === !0 && lastIndex > 0 ? (base = str.slice(0, lastIndex), glob2 = str.slice(lastIndex)) : isGlob === !0 ? (base = "", glob2 = str) : base = str, base && base !== "" && base !== "/" && base !== str && isPathSeparator(base.charCodeAt(base.length - 1)) && (base = base.slice(0, -1)), opts.unescape === !0 && (glob2 && (glob2 = utils.removeBackslashes(glob2)), base && backslashes === !0 && (base = utils.removeBackslashes(base)));
      let state = {
        prefix,
        input,
        start,
        base,
        glob: glob2,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === !0 && (state.maxDepth = 0, isPathSeparator(code) || tokens.push(token), state.tokens = tokens), opts.parts === !0 || opts.tokens === !0) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          let n = prevIndex ? prevIndex + 1 : start, i = slashes[idx], value = input.slice(n, i);
          opts.tokens && (idx === 0 && start !== 0 ? (tokens[idx].isPrefix = !0, tokens[idx].value = prefix) : tokens[idx].value = value, depth(tokens[idx]), state.maxDepth += tokens[idx].depth), (idx !== 0 || value !== "") && parts.push(value), prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          let value = input.slice(prevIndex + 1);
          parts.push(value), opts.tokens && (tokens[tokens.length - 1].value = value, depth(tokens[tokens.length - 1]), state.maxDepth += tokens[tokens.length - 1].depth);
        }
        state.slashes = slashes, state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// ../../node_modules/picomatch/lib/parse.js
var require_parse3 = __commonJS({
  "../../node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2(), utils = require_utils4(), {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants, expandRange = (args, options) => {
      if (typeof options.expandRange == "function")
        return options.expandRange(...args, options);
      args.sort();
      let value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    }, syntaxError = (type, char) => `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`, parse6 = (input, options) => {
      if (typeof input != "string")
        throw new TypeError("Expected a string");
      input = REPLACEMENTS[input] || input;
      let opts = { ...options }, max = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH, len = input.length;
      if (len > max)
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      let bos = { type: "bos", value: "", output: opts.prepend || "" }, tokens = [bos], capture = opts.capture ? "" : "?:", win322 = utils.isWindows(options), PLATFORM_CHARS = constants.globChars(win322), EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS), {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS, globstar = (opts2) => `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`, nodot = opts.dot ? "" : NO_DOT, qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT, star3 = opts.bash === !0 ? globstar(opts) : STAR;
      opts.capture && (star3 = `(${star3})`), typeof opts.noext == "boolean" && (opts.noextglob = opts.noext);
      let state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === !0,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: !1,
        negated: !1,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: !1,
        tokens
      };
      input = utils.removePrefix(input, state), len = input.length;
      let extglobs = [], braces = [], stack = [], prev = bos, value, eos = () => state.index === len - 1, peek = state.peek = (n = 1) => input[state.index + n], advance = state.advance = () => input[++state.index] || "", remaining = () => input.slice(state.index + 1), consume = (value2 = "", num = 0) => {
        state.consumed += value2, state.index += num;
      }, append = (token) => {
        state.output += token.output != null ? token.output : token.value, consume(token.value);
      }, negate = () => {
        let count = 1;
        for (; peek() === "!" && (peek(2) !== "(" || peek(3) === "?"); )
          advance(), state.start++, count++;
        return count % 2 === 0 ? !1 : (state.negated = !0, state.start++, !0);
      }, increment = (type) => {
        state[type]++, stack.push(type);
      }, decrement = (type) => {
        state[type]--, stack.pop();
      }, push = (tok) => {
        if (prev.type === "globstar") {
          let isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace"), isExtglob = tok.extglob === !0 || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob && (state.output = state.output.slice(0, -prev.output.length), prev.type = "star", prev.value = "*", prev.output = star3, state.output += prev.output);
        }
        if (extglobs.length && tok.type !== "paren" && (extglobs[extglobs.length - 1].inner += tok.value), (tok.value || tok.output) && append(tok), prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value, prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev, tokens.push(tok), prev = tok;
      }, extglobOpen = (type, value2) => {
        let token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev, token.parens = state.parens, token.output = state.output;
        let output = (opts.capture ? "(" : "") + token.open;
        increment("parens"), push({ type, value: value2, output: state.output ? "" : ONE_CHAR }), push({ type: "paren", extglob: !0, value: advance(), output }), extglobs.push(token);
      }, extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : ""), rest;
        if (token.type === "negate") {
          let extglobStar = star3;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/") && (extglobStar = globstar(opts)), (extglobStar !== star3 || eos() || /^\)+$/.test(remaining())) && (output = token.close = `)$))${extglobStar}`), token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            let expression = parse6(rest, { ...options, fastpaths: !1 }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          token.prev.type === "bos" && (state.negatedExtglob = !0);
        }
        push({ type: "paren", extglob: !0, value, output }), decrement("parens");
      };
      if (opts.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = !1, output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => first === "\\" ? (backslashes = !0, m) : first === "?" ? esc ? esc + first + (rest ? QMARK.repeat(rest.length) : "") : index === 0 ? qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "") : QMARK.repeat(chars.length) : first === "." ? DOT_LITERAL.repeat(chars.length) : first === "*" ? esc ? esc + first + (rest ? star3 : "") : star3 : esc ? m : `\\${m}`);
        return backslashes === !0 && (opts.unescape === !0 ? output = output.replace(/\\/g, "") : output = output.replace(/\\+/g, (m) => m.length % 2 === 0 ? "\\\\" : m ? "\\" : "")), output === input && opts.contains === !0 ? (state.output = input, state) : (state.output = utils.wrapOutput(output, state, options), state);
      }
      for (; !eos(); ) {
        if (value = advance(), value === "\0")
          continue;
        if (value === "\\") {
          let next = peek();
          if (next === "/" && opts.bash !== !0 || next === "." || next === ";")
            continue;
          if (!next) {
            value += "\\", push({ type: "text", value });
            continue;
          }
          let match2 = /^\\+/.exec(remaining()), slashes = 0;
          if (match2 && match2[0].length > 2 && (slashes = match2[0].length, state.index += slashes, slashes % 2 !== 0 && (value += "\\")), opts.unescape === !0 ? value = advance() : value += advance(), state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== !1 && value === ":") {
            let inner = prev.value.slice(1);
            if (inner.includes("[") && (prev.posix = !0, inner.includes(":"))) {
              let idx = prev.value.lastIndexOf("["), pre = prev.value.slice(0, idx), rest2 = prev.value.slice(idx + 2), posix3 = POSIX_REGEX_SOURCE[rest2];
              if (posix3) {
                prev.value = pre + posix3, state.backtrack = !0, advance(), !bos.output && tokens.indexOf(prev) === 1 && (bos.output = ONE_CHAR);
                continue;
              }
            }
          }
          (value === "[" && peek() !== ":" || value === "-" && peek() === "]") && (value = `\\${value}`), value === "]" && (prev.value === "[" || prev.value === "[^") && (value = `\\${value}`), opts.posix === !0 && value === "!" && prev.value === "[" && (value = "^"), prev.value += value, append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value), prev.value += value, append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1, opts.keepQuotes === !0 && push({ type: "text", value });
          continue;
        }
        if (value === "(") {
          increment("parens"), push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === !0)
            throw new SyntaxError(syntaxError("opening", "("));
          let extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" }), decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === !0 || !remaining().includes("]")) {
            if (opts.nobracket !== !0 && opts.strictBrackets === !0)
              throw new SyntaxError(syntaxError("closing", "]"));
            value = `\\${value}`;
          } else
            increment("brackets");
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === !0 || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === !0)
              throw new SyntaxError(syntaxError("opening", "["));
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          let prevValue = prev.value.slice(1);
          if (prev.posix !== !0 && prevValue[0] === "^" && !prevValue.includes("/") && (value = `/${value}`), prev.value += value, append({ value }), opts.literalBrackets === !1 || utils.hasRegexChars(prevValue))
            continue;
          let escaped = utils.escapeRegex(prev.value);
          if (state.output = state.output.slice(0, -prev.value.length), opts.literalBrackets === !0) {
            state.output += escaped, prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`, state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== !0) {
          increment("braces");
          let open3 = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open3), push(open3);
          continue;
        }
        if (value === "}") {
          let brace = braces[braces.length - 1];
          if (opts.nobrace === !0 || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === !0) {
            let arr = tokens.slice(), range = [];
            for (let i = arr.length - 1; i >= 0 && (tokens.pop(), arr[i].type !== "brace"); i--)
              arr[i].type !== "dots" && range.unshift(arr[i].value);
            output = expandRange(range, opts), state.backtrack = !0;
          }
          if (brace.comma !== !0 && brace.dots !== !0) {
            let out = state.output.slice(0, brace.outputIndex), toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{", value = output = "\\}", state.output = out;
            for (let t of toks)
              state.output += t.output || t.value;
          }
          push({ type: "brace", value, output }), decrement("braces"), braces.pop();
          continue;
        }
        if (value === "|") {
          extglobs.length > 0 && extglobs[extglobs.length - 1].conditions++, push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value, brace = braces[braces.length - 1];
          brace && stack[stack.length - 1] === "braces" && (brace.comma = !0, output = "|"), push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1, state.consumed = "", state.output = "", tokens.pop(), prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            prev.value === "." && (prev.output = DOT_LITERAL);
            let brace = braces[braces.length - 1];
            prev.type = "dots", prev.output += value, prev.value += value, brace.dots = !0;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          if (!(prev && prev.value === "(") && opts.noextglob !== !0 && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            let next = peek(), output = value;
            if (next === "<" && !utils.supportsLookbehinds())
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) && (output = `\\${value}`), push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== !0 && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== !0 && peek() === "(" && (peek(2) !== "?" || !/[!=<:]/.test(peek(3)))) {
            extglobOpen("negate", value);
            continue;
          }
          if (opts.nonegate !== !0 && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== !0 && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === !1) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== !0 && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: !0, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          (value === "$" || value === "^") && (value = `\\${value}`);
          let match2 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          match2 && (value += match2[0], state.index += match2[0].length), push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === !0)) {
          prev.type = "star", prev.star = !0, prev.value += value, prev.output = star3, state.backtrack = !0, state.globstar = !0, consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== !0 && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === !0) {
            consume(value);
            continue;
          }
          let prior = prev.prev, before = prior.prev, isStart = prior.type === "slash" || prior.type === "bos", afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === !0 && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          let isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace"), isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          for (; rest.slice(0, 3) === "/**"; ) {
            let after = input[state.index + 4];
            if (after && after !== "/")
              break;
            rest = rest.slice(3), consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar", prev.value += value, prev.output = globstar(opts), state.output = prev.output, state.globstar = !0, consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length), prior.output = `(?:${prior.output}`, prev.type = "globstar", prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)"), prev.value += value, state.globstar = !0, state.output += prior.output + prev.output, consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            let end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length), prior.output = `(?:${prior.output}`, prev.type = "globstar", prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`, prev.value += value, state.output += prior.output + prev.output, state.globstar = !0, consume(value + advance()), push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar", prev.value += value, prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`, state.output = prev.output, state.globstar = !0, consume(value + advance()), push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length), prev.type = "globstar", prev.output = globstar(opts), prev.value += value, state.output += prev.output, state.globstar = !0, consume(value);
          continue;
        }
        let token = { type: "star", value, output: star3 };
        if (opts.bash === !0) {
          token.output = ".*?", (prev.type === "bos" || prev.type === "slash") && (token.output = nodot + token.output), push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === !0) {
          token.output = value, push(token);
          continue;
        }
        (state.index === state.start || prev.type === "slash" || prev.type === "dot") && (prev.type === "dot" ? (state.output += NO_DOT_SLASH, prev.output += NO_DOT_SLASH) : opts.dot === !0 ? (state.output += NO_DOTS_SLASH, prev.output += NO_DOTS_SLASH) : (state.output += nodot, prev.output += nodot), peek() !== "*" && (state.output += ONE_CHAR, prev.output += ONE_CHAR)), push(token);
      }
      for (; state.brackets > 0; ) {
        if (opts.strictBrackets === !0)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "["), decrement("brackets");
      }
      for (; state.parens > 0; ) {
        if (opts.strictBrackets === !0)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "("), decrement("parens");
      }
      for (; state.braces > 0; ) {
        if (opts.strictBrackets === !0)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{"), decrement("braces");
      }
      if (opts.strictSlashes !== !0 && (prev.type === "star" || prev.type === "bracket") && push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` }), state.backtrack === !0) {
        state.output = "";
        for (let token of state.tokens)
          state.output += token.output != null ? token.output : token.value, token.suffix && (state.output += token.suffix);
      }
      return state;
    };
    parse6.fastpaths = (input, options) => {
      let opts = { ...options }, max = typeof opts.maxLength == "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH, len = input.length;
      if (len > max)
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      input = REPLACEMENTS[input] || input;
      let win322 = utils.isWindows(options), {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win322), nodot = opts.dot ? NO_DOTS : NO_DOT, slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT, capture = opts.capture ? "" : "?:", state = { negated: !1, prefix: "" }, star3 = opts.bash === !0 ? ".*?" : STAR;
      opts.capture && (star3 = `(${star3})`);
      let globstar = (opts2) => opts2.noglobstar === !0 ? star3 : `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`, create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star3}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star3}`;
          case "*.*":
            return `${nodot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
          case "*/*":
            return `${nodot}${star3}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star3}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star3}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star3}`;
          default: {
            let match2 = /^(.*?)\.(\w+)$/.exec(str);
            if (!match2)
              return;
            let source2 = create(match2[1]);
            return source2 ? source2 + DOT_LITERAL + match2[2] : void 0;
          }
        }
      }, output = utils.removePrefix(input, state), source = create(output);
      return source && opts.strictSlashes !== !0 && (source += `${SLASH_LITERAL}?`), source;
    };
    module2.exports = parse6;
  }
});

// ../../node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "../../node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), scan = require_scan(), parse6 = require_parse3(), utils = require_utils4(), constants = require_constants2(), isObject = (val) => val && typeof val == "object" && !Array.isArray(val), picomatch = (glob2, options, returnState = !1) => {
      if (Array.isArray(glob2)) {
        let fns = glob2.map((input) => picomatch(input, options, returnState));
        return (str) => {
          for (let isMatch of fns) {
            let state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return !1;
        };
      }
      let isState = isObject(glob2) && glob2.tokens && glob2.input;
      if (glob2 === "" || typeof glob2 != "string" && !isState)
        throw new TypeError("Expected pattern to be a non-empty string");
      let opts = options || {}, posix3 = utils.isWindows(options), regex = isState ? picomatch.compileRe(glob2, options) : picomatch.makeRe(glob2, options, !1, !0), state = regex.state;
      delete regex.state;
      let isIgnored = () => !1;
      if (opts.ignore) {
        let ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      let matcher = (input, returnObject = !1) => {
        let { isMatch, match: match2, output } = picomatch.test(input, regex, options, { glob: glob2, posix: posix3 }), result = { glob: glob2, state, regex, posix: posix3, input, output, match: match2, isMatch };
        return typeof opts.onResult == "function" && opts.onResult(result), isMatch === !1 ? (result.isMatch = !1, returnObject ? result : !1) : isIgnored(input) ? (typeof opts.onIgnore == "function" && opts.onIgnore(result), result.isMatch = !1, returnObject ? result : !1) : (typeof opts.onMatch == "function" && opts.onMatch(result), returnObject ? result : !0);
      };
      return returnState && (matcher.state = state), matcher;
    };
    picomatch.test = (input, regex, options, { glob: glob2, posix: posix3 } = {}) => {
      if (typeof input != "string")
        throw new TypeError("Expected input to be a string");
      if (input === "")
        return { isMatch: !1, output: "" };
      let opts = options || {}, format = opts.format || (posix3 ? utils.toPosixSlashes : null), match2 = input === glob2, output = match2 && format ? format(input) : input;
      return match2 === !1 && (output = format ? format(input) : input, match2 = output === glob2), (match2 === !1 || opts.capture === !0) && (opts.matchBase === !0 || opts.basename === !0 ? match2 = picomatch.matchBase(input, regex, options, posix3) : match2 = regex.exec(output)), { isMatch: !!match2, match: match2, output };
    };
    picomatch.matchBase = (input, glob2, options, posix3 = utils.isWindows(options)) => (glob2 instanceof RegExp ? glob2 : picomatch.makeRe(glob2, options)).test(path6.basename(input));
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => Array.isArray(pattern) ? pattern.map((p) => picomatch.parse(p, options)) : parse6(pattern, { ...options, fastpaths: !1 });
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = !1, returnState = !1) => {
      if (returnOutput === !0)
        return state.output;
      let opts = options || {}, prepend = opts.contains ? "" : "^", append = opts.contains ? "" : "$", source = `${prepend}(?:${state.output})${append}`;
      state && state.negated === !0 && (source = `^(?!${source}).*$`);
      let regex = picomatch.toRegex(source, options);
      return returnState === !0 && (regex.state = state), regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = !1, returnState = !1) => {
      if (!input || typeof input != "string")
        throw new TypeError("Expected a non-empty string");
      let parsed = { negated: !1, fastpaths: !0 };
      return options.fastpaths !== !1 && (input[0] === "." || input[0] === "*") && (parsed.output = parse6.fastpaths(input, options)), parsed.output || (parsed = parse6(input, options)), picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        let opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === !0)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// ../../node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "../../node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// ../../node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "../../node_modules/micromatch/index.js"(exports2, module2) {
    "use strict";
    var util = require("util"), braces = require_braces(), picomatch = require_picomatch2(), utils = require_utils4(), isEmptyString = (val) => val === "" || val === "./", micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns), list = [].concat(list);
      let omit = /* @__PURE__ */ new Set(), keep = /* @__PURE__ */ new Set(), items = /* @__PURE__ */ new Set(), negatives = 0, onResult = (state) => {
        items.add(state.output), options && options.onResult && options.onResult(state);
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, !0), negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        negated && negatives++;
        for (let item of list) {
          let matched = isMatch(item, !0);
          (negated ? !matched.isMatch : matched.isMatch) && (negated ? omit.add(matched.output) : (omit.delete(matched.output), keep.add(matched.output)));
        }
      }
      let matches = (negatives === patterns.length ? [...items] : [...keep]).filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === !0)
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        if (options.nonull === !0 || options.nullglob === !0)
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set(), items = [], onResult = (state) => {
        options.onResult && options.onResult(state), items.push(state.output);
      }, matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items)
        matches.has(item) || result.add(item);
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str != "string")
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      if (Array.isArray(pattern))
        return pattern.some((p) => micromatch.contains(str, p, options));
      if (typeof pattern == "string") {
        if (isEmptyString(str) || isEmptyString(pattern))
          return !1;
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern))
          return !0;
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: !0 });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj))
        throw new TypeError("Expected the first argument to be an object");
      let keys = micromatch(Object.keys(obj), patterns, options), res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item)))
          return !0;
      }
      return !1;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item)))
          return !1;
      }
      return !0;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str != "string")
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob2, input, options) => {
      let posix3 = utils.isWindows(options), match2 = picomatch.makeRe(String(glob2), { ...options, capture: !0 }).exec(posix3 ? utils.toPosixSlashes(input) : input);
      if (match2)
        return match2.slice(1).map((v) => v === void 0 ? "" : v);
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || []))
        for (let str of braces(String(pattern), options))
          res.push(picomatch.parse(str, options));
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern != "string")
        throw new TypeError("Expected a string");
      return options && options.nobrace === !0 || !/\{.*\}/.test(pattern) ? [pattern] : braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern != "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: !0 });
    };
    module2.exports = micromatch;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/utils/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.removeDuplicateSlashes = exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.isPatternRelatedToParentDirectory = exports2.getPatternsOutsideCurrentDirectory = exports2.getPatternsInsideCurrentDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
    var path6 = require("path"), globParent = require_glob_parent(), micromatch = require_micromatch(), GLOBSTAR2 = "**", ESCAPE_SYMBOL = "\\", COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/, REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/, REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/, GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/, BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./, DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern2(pattern, options);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern2(pattern, options = {}) {
      return pattern === "" ? !1 : !!(options.caseSensitiveMatch === !1 || pattern.includes(ESCAPE_SYMBOL) || COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern) || options.extglob !== !1 && GLOB_EXTENSION_SYMBOLS_RE.test(pattern) || options.braceExpansion !== !1 && hasBraceExpansion(pattern));
    }
    exports2.isDynamicPattern = isDynamicPattern2;
    function hasBraceExpansion(pattern) {
      let openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1)
        return !1;
      let closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1)
        return !1;
      let braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern2(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern2(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern2;
    function isPositivePattern(pattern) {
      return !isNegativePattern2(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern2);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports2.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports2.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports2.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: !1 });
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR2);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR2);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      let basename2 = path6.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename2);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => collection.concat(expandBraceExpansion(pattern)), []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      let patterns = micromatch.braces(pattern, { expand: !0, nodupes: !0, keepEscaping: !0 });
      return patterns.sort((a, b) => a.length - b.length), patterns.filter((pattern2) => pattern2 !== "");
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: !0 }));
      return parts.length === 0 && (parts = [pattern]), parts[0].startsWith("/") && (parts[0] = parts[0].slice(1), parts.unshift("")), parts;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe2(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports2.makeRe = makeRe2;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe2(pattern, options));
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports2.matchAny = matchAny;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports2.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/utils/stream.js
var require_stream2 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/utils/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.merge = void 0;
    var merge22 = require_merge2();
    function merge(streams) {
      let mergedStream = merge22(streams);
      return streams.forEach((stream2) => {
        stream2.once("error", (error) => mergedStream.emit("error", error));
      }), mergedStream.once("close", () => propagateCloseEventToSources(streams)), mergedStream.once("end", () => propagateCloseEventToSources(streams)), mergedStream;
    }
    exports2.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream2) => stream2.emit("close"));
    }
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/utils/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.isEmpty = exports2.isString = void 0;
    function isString2(input) {
      return typeof input == "string";
    }
    exports2.isString = isString2;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/utils/index.js
var require_utils5 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
    var array = require_array();
    exports2.array = array;
    var errno = require_errno();
    exports2.errno = errno;
    var fs7 = require_fs2();
    exports2.fs = fs7;
    var path6 = require_path();
    exports2.path = path6;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream2 = require_stream2();
    exports2.stream = stream2;
    var string = require_string();
    exports2.string = string;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/managers/tasks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
    var utils = require_utils5();
    function generate(input, settings) {
      let patterns = processPatterns(input, settings), ignore = processPatterns(settings.ignore, settings), positivePatterns = getPositivePatterns(patterns), negativePatterns = getNegativePatternsAsPositive(patterns, ignore), staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings)), dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings)), staticTasks = convertPatternsToTasks(
        staticPatterns,
        negativePatterns,
        /* dynamic */
        !1
      ), dynamicTasks = convertPatternsToTasks(
        dynamicPatterns,
        negativePatterns,
        /* dynamic */
        !0
      );
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate;
    function processPatterns(input, settings) {
      let patterns = input;
      return settings.braceExpansion && (patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns)), settings.baseNameMatch && (patterns = patterns.map((pattern) => pattern.includes("/") ? pattern : `**/${pattern}`)), patterns.map((pattern) => utils.pattern.removeDuplicateSlashes(pattern));
    }
    function convertPatternsToTasks(positive, negative, dynamic) {
      let tasks = [], patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive), patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive), outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory), insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      return tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic)), "." in insideCurrentDirectoryGroup ? tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic)) : tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic)), tasks;
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      return utils.pattern.getNegativePatterns(patterns).concat(ignore).map(utils.pattern.convertToPositivePattern);
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      let group = {};
      return patterns.reduce((collection, pattern) => {
        let base = utils.pattern.getBaseDirectory(pattern);
        return base in collection ? collection[base].push(pattern) : collection[base] = [pattern], collection;
      }, group);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => convertPatternGroupToTask(base, positive[base], negative, dynamic));
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.read = void 0;
    function read(path6, settings, callback) {
      settings.fs.lstat(path6, (lstatError, lstat6) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat6.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat6);
          return;
        }
        settings.fs.stat(path6, (statError, stat3) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat6);
            return;
          }
          settings.markSymbolicLink && (stat3.isSymbolicLink = () => !0), callSuccessCallback(callback, stat3);
        });
      });
    }
    exports2.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// ../../node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.read = void 0;
    function read(path6, settings) {
      let lstat6 = settings.fs.lstatSync(path6);
      if (!lstat6.isSymbolicLink() || !settings.followSymbolicLink)
        return lstat6;
      try {
        let stat3 = settings.fs.statSync(path6);
        return settings.markSymbolicLink && (stat3.isSymbolicLink = () => !0), stat3;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink)
          return lstat6;
        throw error;
      }
    }
    exports2.read = read;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs3 = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs7 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs7.lstat,
      stat: fs7.stat,
      lstatSync: fs7.lstatSync,
      statSync: fs7.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      return fsMethods === void 0 ? exports2.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var fs7 = require_fs3(), Settings = class {
      constructor(_options = {}) {
        this._options = _options, this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, !0), this.fs = fs7.createFileSystemAdapter(this._options.fs), this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0);
      }
      _getValue(option, value) {
        return option ?? value;
      }
    };
    exports2.default = Settings;
  }
});

// ../../node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "../../node_modules/@nodelib/fs.stat/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.statSync = exports2.stat = exports2.Settings = void 0;
    var async = require_async(), sync2 = require_sync(), settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat3(path6, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback == "function") {
        async.read(path6, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path6, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat3;
    function statSync2(path6, optionsOrSettings) {
      let settings = getSettings(optionsOrSettings);
      return sync2.read(path6, settings);
    }
    exports2.statSync = statSync2;
    function getSettings(settingsOrOptions = {}) {
      return settingsOrOptions instanceof settings_1.default ? settingsOrOptions : new settings_1.default(settingsOrOptions);
    }
  }
});

// ../../node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "../../node_modules/queue-microtask/index.js"(exports2, module2) {
    var promise;
    module2.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// ../../node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "../../node_modules/run-parallel/index.js"(exports2, module2) {
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys, isSync = !0;
      Array.isArray(tasks) ? (results = [], pending = tasks.length) : (keys = Object.keys(tasks), results = {}, pending = keys.length);
      function done(err) {
        function end() {
          cb && cb(err, results), cb = null;
        }
        isSync ? queueMicrotask2(end) : end();
      }
      function each(i, err, result) {
        results[i] = result, (--pending === 0 || err) && done(err);
      }
      pending ? keys ? keys.forEach(function(key) {
        tasks[key](function(err, result) {
          each(key, err, result);
        });
      }) : tasks.forEach(function(task, i) {
        task(function(err, result) {
          each(i, err, result);
        });
      }) : done(null), isSync = !1;
    }
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants3 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0)
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10), MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10), SUPPORTED_MAJOR_VERSION = 10, SUPPORTED_MINOR_VERSION = 10, IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION, IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs4 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name, this.isBlockDevice = stats.isBlockDevice.bind(stats), this.isCharacterDevice = stats.isCharacterDevice.bind(stats), this.isDirectory = stats.isDirectory.bind(stats), this.isFIFO = stats.isFIFO.bind(stats), this.isFile = stats.isFile.bind(stats), this.isSocket = stats.isSocket.bind(stats), this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils6 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.fs = void 0;
    var fs7 = require_fs4();
    exports2.fs = fs7;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      return a.endsWith(separator) ? a + b : a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out(), rpl = require_run_parallel(), constants_1 = require_constants3(), utils = require_utils6(), common = require_common();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir4(directory, settings, callback);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: !0 }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        let entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        let tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats), done(null, entry);
        });
      };
    }
    function readdir4(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        let tasks = names.map((name) => {
          let path6 = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path6, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              let entry = {
                name,
                path: path6,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              settings.stats && (entry.stats = stats), done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir4;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out(), constants_1 = require_constants3(), utils = require_utils6(), common = require_common();
    function read(directory, settings) {
      return !settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES ? readdirWithFileTypes(directory, settings) : readdir4(directory, settings);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings) {
      return settings.fs.readdirSync(directory, { withFileTypes: !0 }).map((dirent) => {
        let entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks)
          try {
            let stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink)
              throw error;
          }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir4(directory, settings) {
      return settings.fs.readdirSync(directory).map((name) => {
        let entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator), stats = fsStat.statSync(entryPath, settings.fsStatSettings), entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        return settings.stats && (entry.stats = stats), entry;
      });
    }
    exports2.readdir = readdir4;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs5 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs7 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs7.lstat,
      stat: fs7.stat,
      lstatSync: fs7.lstatSync,
      statSync: fs7.statSync,
      readdir: fs7.readdir,
      readdirSync: fs7.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      return fsMethods === void 0 ? exports2.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var path6 = require("path"), fsStat = require_out(), fs7 = require_fs5(), Settings = class {
      constructor(_options = {}) {
        this._options = _options, this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !1), this.fs = fs7.createFileSystemAdapter(this._options.fs), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path6.sep), this.stats = this._getValue(this._options.stats, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0), this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option ?? value;
      }
    };
    exports2.default = Settings;
  }
});

// ../../node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "../../node_modules/@nodelib/fs.scandir/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
    var async = require_async2(), sync2 = require_sync2(), settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path6, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback == "function") {
        async.read(path6, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path6, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path6, optionsOrSettings) {
      let settings = getSettings(optionsOrSettings);
      return sync2.read(path6, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      return settingsOrOptions instanceof settings_1.default ? settingsOrOptions : new settings_1.default(settingsOrOptions);
    }
  }
});

// ../../node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "../../node_modules/reusify/reusify.js"(exports2, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor(), tail = head;
      function get() {
        var current = head;
        return current.next ? head = current.next : (head = new Constructor(), tail = head), current.next = null, current;
      }
      function release(obj) {
        tail.next = obj, tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// ../../node_modules/fastq/queue.js
var require_queue = __commonJS({
  "../../node_modules/fastq/queue.js"(exports2, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context == "function" && (concurrency = worker, worker = context, context = null), concurrency < 1)
        throw new Error("fastqueue concurrency must be greater than 1");
      var cache2 = reusify(Task), queueHead = null, queueTail = null, _running = 0, errorHandler = null, self = {
        push,
        drain: noop2,
        saturated: noop2,
        pause,
        paused: !1,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop2,
        kill,
        killAndDrain,
        error
      };
      return self;
      function running() {
        return _running;
      }
      function pause() {
        self.paused = !0;
      }
      function length() {
        for (var current = queueHead, counter = 0; current; )
          current = current.next, counter++;
        return counter;
      }
      function getQueue() {
        for (var current = queueHead, tasks = []; current; )
          tasks.push(current.value), current = current.next;
        return tasks;
      }
      function resume() {
        if (self.paused) {
          self.paused = !1;
          for (var i = 0; i < self.concurrency; i++)
            _running++, release();
        }
      }
      function idle() {
        return _running === 0 && self.length() === 0;
      }
      function push(value, done) {
        var current = cache2.get();
        current.context = context, current.release = release, current.value = value, current.callback = done || noop2, current.errorHandler = errorHandler, _running === self.concurrency || self.paused ? queueTail ? (queueTail.next = current, queueTail = current) : (queueHead = current, queueTail = current, self.saturated()) : (_running++, worker.call(context, current.value, current.worked));
      }
      function unshift(value, done) {
        var current = cache2.get();
        current.context = context, current.release = release, current.value = value, current.callback = done || noop2, _running === self.concurrency || self.paused ? queueHead ? (current.next = queueHead, queueHead = current) : (queueHead = current, queueTail = current, self.saturated()) : (_running++, worker.call(context, current.value, current.worked));
      }
      function release(holder) {
        holder && cache2.release(holder);
        var next = queueHead;
        next ? self.paused ? _running-- : (queueTail === queueHead && (queueTail = null), queueHead = next.next, next.next = null, worker.call(context, next.value, next.worked), queueTail === null && self.empty()) : --_running === 0 && self.drain();
      }
      function kill() {
        queueHead = null, queueTail = null, self.drain = noop2;
      }
      function killAndDrain() {
        queueHead = null, queueTail = null, self.drain(), self.drain = noop2;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop2() {
    }
    function Task() {
      this.value = null, this.callback = noop2, this.next = null, this.release = noop2, this.context = null, this.errorHandler = null;
      var self = this;
      this.worked = function(err, result) {
        var callback = self.callback, errorHandler = self.errorHandler, val = self.value;
        self.value = null, self.callback = noop2, self.errorHandler && errorHandler(err, val), callback.call(self.context, err, result), self.release(self);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      typeof context == "function" && (concurrency = worker, worker = context, context = null);
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency), pushCb = queue.push, unshiftCb = queue.unshift;
      return queue.push = push, queue.unshift = unshift, queue.drained = drained, queue;
      function push(value) {
        var p = new Promise(function(resolve7, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve7(result);
          });
        });
        return p.catch(noop2), p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve7, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve7(result);
          });
        });
        return p.catch(noop2), p;
      }
      function drained() {
        if (queue.idle())
          return new Promise(function(resolve7) {
            resolve7();
          });
        var previousDrain = queue.drain, p = new Promise(function(resolve7) {
          queue.drain = function() {
            previousDrain(), resolve7();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common2 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
    function isFatalError(settings, error) {
      return settings.errorFilter === null ? !0 : !settings.errorFilter(error);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter2, value) {
      return filter2 === null || filter2(value);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      return a === "" ? b : a.endsWith(separator) ? a + b : a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var common = require_common2(), Reader = class {
      constructor(_root, _settings) {
        this._root = _root, this._settings = _settings, this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports2.default = Reader;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var events_1 = require("events"), fsScandir = require_out2(), fastq = require_queue(), common = require_common2(), reader_1 = require_reader(), AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings), this._settings = _settings, this._scandir = fsScandir.scandir, this._emitter = new events_1.EventEmitter(), this._queue = fastq(this._worker.bind(this), this._settings.concurrency), this._isFatalError = !1, this._isDestroyed = !1, this._queue.drain = () => {
          this._isFatalError || this._emitter.emit("end");
        };
      }
      read() {
        return this._isFatalError = !1, this._isDestroyed = !1, setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        }), this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed)
          throw new Error("The reader is already destroyed");
        this._isDestroyed = !0, this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        let queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
          error !== null && this._handleError(error);
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (let entry of entries)
            this._handleEntry(entry, item.base);
          done(null, void 0);
        });
      }
      _handleError(error) {
        this._isDestroyed || !common.isFatalError(this._settings, error) || (this._isFatalError = !0, this._isDestroyed = !0, this._emitter.emit("error", error));
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError)
          return;
        let fullpath = entry.path;
        base !== void 0 && (entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator)), common.isAppliedFilter(this._settings.entryFilter, entry) && this._emitEntry(entry), entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry) && this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports2.default = AsyncReader;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var async_1 = require_async3(), AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root, this._settings = _settings, this._reader = new async_1.default(this._root, this._settings), this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        }), this._reader.onEntry((entry) => {
          this._storage.push(entry);
        }), this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        }), this._reader.read();
      }
    };
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// ../../node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var stream_1 = require("stream"), async_1 = require_async3(), StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root, this._settings = _settings, this._reader = new async_1.default(this._root, this._settings), this._stream = new stream_1.Readable({
          objectMode: !0,
          read: () => {
          },
          destroy: () => {
            this._reader.isDestroyed || this._reader.destroy();
          }
        });
      }
      read() {
        return this._reader.onError((error) => {
          this._stream.emit("error", error);
        }), this._reader.onEntry((entry) => {
          this._stream.push(entry);
        }), this._reader.onEnd(() => {
          this._stream.push(null);
        }), this._reader.read(), this._stream;
      }
    };
    exports2.default = StreamProvider;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var fsScandir = require_out2(), common = require_common2(), reader_1 = require_reader(), SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments), this._scandir = fsScandir.scandirSync, this._storage = [], this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        return this._pushToQueue(this._root, this._settings.basePath), this._handleQueue(), this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (let item of this._queue.values())
          this._handleDirectory(item.directory, item.base);
      }
      _handleDirectory(directory, base) {
        try {
          let entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (let entry of entries)
            this._handleEntry(entry, base);
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (common.isFatalError(this._settings, error))
          throw error;
      }
      _handleEntry(entry, base) {
        let fullpath = entry.path;
        base !== void 0 && (entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator)), common.isAppliedFilter(this._settings.entryFilter, entry) && this._pushToStorage(entry), entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry) && this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports2.default = SyncReader;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var sync_1 = require_sync3(), SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root, this._settings = _settings, this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports2.default = SyncProvider;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var path6 = require("path"), fsScandir = require_out2(), Settings = class {
      constructor(_options = {}) {
        this._options = _options, this.basePath = this._getValue(this._options.basePath, void 0), this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY), this.deepFilter = this._getValue(this._options.deepFilter, null), this.entryFilter = this._getValue(this._options.entryFilter, null), this.errorFilter = this._getValue(this._options.errorFilter, null), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path6.sep), this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option ?? value;
      }
    };
    exports2.default = Settings;
  }
});

// ../../node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "../../node_modules/@nodelib/fs.walk/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
    var async_1 = require_async4(), stream_1 = require_stream3(), sync_1 = require_sync4(), settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback == "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      let settings = getSettings(optionsOrSettings);
      return new sync_1.default(directory, settings).read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      let settings = getSettings(optionsOrSettings);
      return new stream_1.default(directory, settings).read();
    }
    exports2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      return settingsOrOptions instanceof settings_1.default ? settingsOrOptions : new settings_1.default(settingsOrOptions);
    }
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var path6 = require("path"), fsStat = require_out(), utils = require_utils5(), Reader = class {
      constructor(_settings) {
        this._settings = _settings, this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path6.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        let entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        return this._settings.stats && (entry.stats = stats), entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports2.default = Reader;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/readers/stream.js
var require_stream4 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/readers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var stream_1 = require("stream"), fsStat = require_out(), fsWalk = require_out3(), reader_1 = require_reader2(), ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments), this._walkStream = fsWalk.walkStream, this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        let filepaths = patterns.map(this._getFullEntryPath, this), stream2 = new stream_1.PassThrough({ objectMode: !0 });
        stream2._write = (index, _enc, done) => this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
          entry !== null && options.entryFilter(entry) && stream2.push(entry), index === filepaths.length - 1 && stream2.end(), done();
        }).catch(done);
        for (let i = 0; i < filepaths.length; i++)
          stream2.write(i);
        return stream2;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error))
            return null;
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve7, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => error === null ? resolve7(stats) : reject(error));
        });
      }
    };
    exports2.default = ReaderStream;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/readers/async.js
var require_async5 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var fsWalk = require_out3(), reader_1 = require_reader2(), stream_1 = require_stream4(), ReaderAsync = class extends reader_1.default {
      constructor() {
        super(...arguments), this._walkAsync = fsWalk.walk, this._readerStream = new stream_1.default(this._settings);
      }
      dynamic(root, options) {
        return new Promise((resolve7, reject) => {
          this._walkAsync(root, options, (error, entries) => {
            error === null ? resolve7(entries) : reject(error);
          });
        });
      }
      async static(patterns, options) {
        let entries = [], stream2 = this._readerStream.static(patterns, options);
        return new Promise((resolve7, reject) => {
          stream2.once("error", reject), stream2.on("data", (entry) => entries.push(entry)), stream2.once("end", () => resolve7(entries));
        });
      }
    };
    exports2.default = ReaderAsync;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/providers/matchers/matcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var utils = require_utils5(), Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns, this._settings = _settings, this._micromatchOptions = _micromatchOptions, this._storage = [], this._fillStorage();
      }
      _fillStorage() {
        for (let pattern of this._patterns) {
          let segments = this._getPatternSegments(pattern), sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        return utils.pattern.getPatternParts(pattern, this._micromatchOptions).map((part) => utils.pattern.isDynamicPattern(part, this._settings) ? {
          dynamic: !0,
          pattern: part,
          patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
        } : {
          dynamic: !1,
          pattern: part
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports2.default = Matcher;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/providers/matchers/partial.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var matcher_1 = require_matcher(), PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        let parts = filepath.split("/"), levels = parts.length, patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (let pattern of patterns) {
          let section = pattern.sections[0];
          if (!pattern.complete && levels > section.length || parts.every((part, index) => {
            let segment = pattern.segments[index];
            return !!(segment.dynamic && segment.patternRe.test(part) || !segment.dynamic && segment.pattern === part);
          }))
            return !0;
        }
        return !1;
      }
    };
    exports2.default = PartialMatcher;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/providers/filters/deep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var utils = require_utils5(), partial_1 = require_partial(), DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings, this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        let matcher = this._getMatcher(positive), negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        let affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path) || this._isSkippedSymbolicLink(entry))
          return !1;
        let filepath = utils.path.removeLeadingDotSegment(entry.path);
        return this._isSkippedByPositivePatterns(filepath, matcher) ? !1 : this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        return this._settings.deep === 1 / 0 ? !1 : this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        let entryPathDepth = entryPath.split("/").length;
        if (basePath === "")
          return entryPathDepth;
        let basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports2.default = DeepFilter;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/providers/filters/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var utils = require_utils5(), EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings, this._micromatchOptions = _micromatchOptions, this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        let positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions), negativeRe = utils.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: !0 }));
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        let filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._settings.unique && this._isDuplicateEntry(filepath) || this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry) || this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe))
          return !1;
        let isDirectory = entry.dirent.isDirectory(), isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory);
        return this._settings.unique && isMatched && this._createIndexRecord(filepath), isMatched;
      }
      _isDuplicateEntry(filepath) {
        return this.index.has(filepath);
      }
      _createIndexRecord(filepath) {
        this.index.set(filepath, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute)
          return !1;
        let fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(filepath, patternsRe, isDirectory) {
        let isMatched = utils.pattern.matchAny(filepath, patternsRe);
        return !isMatched && isDirectory ? utils.pattern.matchAny(filepath + "/", patternsRe) : isMatched;
      }
    };
    exports2.default = EntryFilter;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/providers/filters/error.js
var require_error2 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/providers/filters/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var utils = require_utils5(), ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports2.default = ErrorFilter;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/providers/transformers/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var utils = require_utils5(), EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        return this._settings.absolute && (filepath = utils.path.makeAbsolute(this._settings.cwd, filepath), filepath = utils.path.unixify(filepath)), this._settings.markDirectories && entry.dirent.isDirectory() && (filepath += "/"), this._settings.objectMode ? Object.assign(Object.assign({}, entry), { path: filepath }) : filepath;
      }
    };
    exports2.default = EntryTransformer;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/providers/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var path6 = require("path"), deep_1 = require_deep(), entry_1 = require_entry(), error_1 = require_error2(), entry_2 = require_entry2(), Provider = class {
      constructor(_settings) {
        this._settings = _settings, this.errorFilter = new error_1.default(this._settings), this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions()), this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions()), this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path6.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        let basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: !0,
          strictSlashes: !1
        };
      }
    };
    exports2.default = Provider;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var async_1 = require_async5(), provider_1 = require_provider(), ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments), this._reader = new async_1.default(this._settings);
      }
      async read(task) {
        let root = this._getRootDirectory(task), options = this._getReaderOptions(task);
        return (await this.api(root, task, options)).map((entry) => options.transform(entry));
      }
      api(root, task, options) {
        return task.dynamic ? this._reader.dynamic(root, options) : this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderAsync;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/providers/stream.js
var require_stream5 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var stream_1 = require("stream"), stream_2 = require_stream4(), provider_1 = require_provider(), ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments), this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        let root = this._getRootDirectory(task), options = this._getReaderOptions(task), source = this.api(root, task, options), destination = new stream_1.Readable({ objectMode: !0, read: () => {
        } });
        return source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end")), destination.once("close", () => source.destroy()), destination;
      }
      api(root, task, options) {
        return task.dynamic ? this._reader.dynamic(root, options) : this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderStream;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var fsStat = require_out(), fsWalk = require_out3(), reader_1 = require_reader2(), ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments), this._walkSync = fsWalk.walkSync, this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        let entries = [];
        for (let pattern of patterns) {
          let filepath = this._getFullEntryPath(pattern), entry = this._getEntry(filepath, pattern, options);
          entry === null || !options.entryFilter(entry) || entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          let stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error))
            return null;
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports2.default = ReaderSync;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var sync_1 = require_sync5(), provider_1 = require_provider(), ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments), this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        let root = this._getRootDirectory(task), options = this._getReaderOptions(task);
        return this.api(root, task, options).map(options.transform);
      }
      api(root, task, options) {
        return task.dynamic ? this._reader.dynamic(root, options) : this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderSync;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs7 = require("fs"), os2 = require("os"), CPU_COUNT = Math.max(os2.cpus().length, 1);
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs7.lstat,
      lstatSync: fs7.lstatSync,
      stat: fs7.stat,
      statSync: fs7.statSync,
      readdir: fs7.readdir,
      readdirSync: fs7.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options, this.absolute = this._getValue(this._options.absolute, !1), this.baseNameMatch = this._getValue(this._options.baseNameMatch, !1), this.braceExpansion = this._getValue(this._options.braceExpansion, !0), this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, !0), this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT), this.cwd = this._getValue(this._options.cwd, process.cwd()), this.deep = this._getValue(this._options.deep, 1 / 0), this.dot = this._getValue(this._options.dot, !1), this.extglob = this._getValue(this._options.extglob, !0), this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !0), this.fs = this._getFileSystemMethods(this._options.fs), this.globstar = this._getValue(this._options.globstar, !0), this.ignore = this._getValue(this._options.ignore, []), this.markDirectories = this._getValue(this._options.markDirectories, !1), this.objectMode = this._getValue(this._options.objectMode, !1), this.onlyDirectories = this._getValue(this._options.onlyDirectories, !1), this.onlyFiles = this._getValue(this._options.onlyFiles, !0), this.stats = this._getValue(this._options.stats, !1), this.suppressErrors = this._getValue(this._options.suppressErrors, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !1), this.unique = this._getValue(this._options.unique, !0), this.onlyDirectories && (this.onlyFiles = !1), this.stats && (this.objectMode = !0), this.ignore = [].concat(this.ignore);
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports2.default = Settings;
  }
});

// ../../node_modules/zx/node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "../../node_modules/zx/node_modules/fast-glob/out/index.js"(exports2, module2) {
    "use strict";
    var taskManager = require_tasks(), async_1 = require_async6(), stream_1 = require_stream5(), sync_1 = require_sync6(), settings_1 = require_settings4(), utils = require_utils5();
    async function FastGlob(source, options) {
      assertPatternsInput2(source);
      let works = getWorks(source, async_1.default, options), result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      FastGlob2.glob = FastGlob2, FastGlob2.globSync = sync2, FastGlob2.globStream = stream2, FastGlob2.async = FastGlob2;
      function sync2(source, options) {
        assertPatternsInput2(source);
        let works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync2;
      function stream2(source, options) {
        assertPatternsInput2(source);
        let works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream2;
      function generateTasks2(source, options) {
        assertPatternsInput2(source);
        let patterns = [].concat(source), settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks2;
      function isDynamicPattern2(source, options) {
        assertPatternsInput2(source);
        let settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern2;
      function escapePath(source) {
        return assertPatternsInput2(source), utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
      function convertPathToPattern(source) {
        return assertPatternsInput2(source), utils.path.convertPathToPattern(source);
      }
      FastGlob2.convertPathToPattern = convertPathToPattern;
      let posix3;
      (function(posix4) {
        function escapePath2(source) {
          return assertPatternsInput2(source), utils.path.escapePosixPath(source);
        }
        posix4.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          return assertPatternsInput2(source), utils.path.convertPosixPathToPattern(source);
        }
        posix4.convertPathToPattern = convertPathToPattern2;
      })(posix3 = FastGlob2.posix || (FastGlob2.posix = {}));
      let win322;
      (function(win323) {
        function escapePath2(source) {
          return assertPatternsInput2(source), utils.path.escapeWindowsPath(source);
        }
        win323.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          return assertPatternsInput2(source), utils.path.convertWindowsPathToPattern(source);
        }
        win323.convertPathToPattern = convertPathToPattern2;
      })(win322 = FastGlob2.win32 || (FastGlob2.win32 = {}));
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      let patterns = [].concat(source), settings = new settings_1.default(options), tasks = taskManager.generate(patterns, settings), provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput2(input) {
      if (![].concat(input).every((item) => utils.string.isString(item) && !utils.string.isEmpty(item)))
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
    }
    module2.exports = FastGlob;
  }
});

// ../../node_modules/path-type/index.js
var require_path_type = __commonJS({
  "../../node_modules/path-type/index.js"(exports2) {
    "use strict";
    var { promisify: promisify2 } = require("util"), fs7 = require("fs");
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath != "string")
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      try {
        return (await promisify2(fs7[fsStatType])(filePath))[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT")
          return !1;
        throw error;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath != "string")
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      try {
        return fs7[fsStatType](filePath)[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT")
          return !1;
        throw error;
      }
    }
    exports2.isFile = isType.bind(null, "stat", "isFile");
    exports2.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports2.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports2.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports2.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports2.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  }
});

// ../../node_modules/dir-glob/index.js
var require_dir_glob = __commonJS({
  "../../node_modules/dir-glob/index.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), pathType = require_path_type(), getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0], getPath = (filepath, cwd2) => {
      let pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
      return path6.isAbsolute(pth) ? pth : path6.join(cwd2, pth);
    }, addExtensions = (file, extensions) => path6.extname(file) ? `**/${file}` : `**/${file}.${getExtensions(extensions)}`, getGlob = (directory, options) => {
      if (options.files && !Array.isArray(options.files))
        throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
      if (options.extensions && !Array.isArray(options.extensions))
        throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
      return options.files && options.extensions ? options.files.map((x) => path6.posix.join(directory, addExtensions(x, options.extensions))) : options.files ? options.files.map((x) => path6.posix.join(directory, `**/${x}`)) : options.extensions ? [path6.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)] : [path6.posix.join(directory, "**")];
    };
    module2.exports = async (input, options) => {
      if (options = {
        cwd: process.cwd(),
        ...options
      }, typeof options.cwd != "string")
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      let globs = await Promise.all([].concat(input).map(async (x) => await pathType.isDirectory(getPath(x, options.cwd)) ? getGlob(x, options) : x));
      return [].concat.apply([], globs);
    };
    module2.exports.sync = (input, options) => {
      if (options = {
        cwd: process.cwd(),
        ...options
      }, typeof options.cwd != "string")
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      let globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
      return [].concat.apply([], globs);
    };
  }
});

// ../../node_modules/zx/node_modules/ignore/index.js
var require_ignore = __commonJS({
  "../../node_modules/zx/node_modules/ignore/index.js"(exports2, module2) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "", SPACE = " ", ESCAPE = "\\", REGEX_TEST_BLANK_LINE = /^\s+$/, REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/, REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/, REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/, REGEX_SPLITALL_CRLF = /\r?\n/g, REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/, SLASH = "/", TMP_KEY_IGNORE = "node-ignore";
    typeof Symbol < "u" && (TMP_KEY_IGNORE = Symbol.for("node-ignore"));
    var KEY_IGNORE = TMP_KEY_IGNORE, define = (object, key, value) => Object.defineProperty(object, key, { value }), REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g, RETURN_FALSE = () => !1, sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match2, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match2 : EMPTY
    ), cleanRangeBackSlash = (slashes) => {
      let { length } = slashes;
      return slashes.slice(0, length - length % 2);
    }, REPLACERS = [
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match2) => match2.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      // replace (\ ) with ' '
      [
        /\\\s/g,
        () => SPACE
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match2) => `\\${match2}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function() {
          return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          let unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match2, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" && endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match2) => /\/$/.test(match2) ? `${match2}$` : `${match2}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => `${p1 ? `${p1}[^/]+` : "[^/]*"}(?=$|\\/$)`
      ]
    ], regexCache = /* @__PURE__ */ Object.create(null), makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      return source || (source = REPLACERS.reduce(
        (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
        pattern
      ), regexCache[pattern] = source), ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    }, isString2 = (subject) => typeof subject == "string", checkPattern = (pattern) => pattern && isString2(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0, splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF), IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin, this.pattern = pattern, this.negative = negative, this.regex = regex;
      }
    }, createRule = (pattern, ignoreCase) => {
      let origin = pattern, negative = !1;
      pattern.indexOf("!") === 0 && (negative = !0, pattern = pattern.substr(1)), pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      let regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    }, throwError = (message, Ctor) => {
      throw new Ctor(message);
    }, checkPath = (path6, originalPath, doThrow) => isString2(path6) ? path6 ? checkPath.isNotRelative(path6) ? doThrow(
      `path should be a \`path.relative()\`d string, but got "${originalPath}"`,
      RangeError
    ) : !0 : doThrow("path must not be empty", TypeError) : doThrow(
      `path must be a string, but got \`${originalPath}\``,
      TypeError
    ), isNotRelative = (path6) => REGEX_TEST_INVALID_PATH.test(path6);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore2 = class {
      constructor({
        ignorecase = !0,
        ignoreCase = ignorecase,
        allowRelativePaths = !1
      } = {}) {
        define(this, KEY_IGNORE, !0), this._rules = [], this._ignoreCase = ignoreCase, this._allowRelativePaths = allowRelativePaths, this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null), this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules), this._added = !0;
          return;
        }
        if (checkPattern(pattern)) {
          let rule = createRule(pattern, this._ignoreCase);
          this._added = !0, this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        return this._added = !1, makeArray(
          isString2(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this), this._added && this._initCache(), this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path6, checkUnignored) {
        let ignored = !1, unignored = !1;
        return this._rules.forEach((rule) => {
          let { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored)
            return;
          rule.regex.test(path6) && (ignored = !negative, unignored = negative);
        }), {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache2, checkUnignored, slices) {
        let path6 = originalPath && checkPath.convert(originalPath);
        return checkPath(
          path6,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        ), this._t(path6, cache2, checkUnignored, slices);
      }
      _t(path6, cache2, checkUnignored, slices) {
        if (path6 in cache2)
          return cache2[path6];
        if (slices || (slices = path6.split(SLASH)), slices.pop(), !slices.length)
          return cache2[path6] = this._testOne(path6, checkUnignored);
        let parent = this._t(
          slices.join(SLASH) + SLASH,
          cache2,
          checkUnignored,
          slices
        );
        return cache2[path6] = parent.ignored ? parent : this._testOne(path6, checkUnignored);
      }
      ignores(path6) {
        return this._test(path6, this._ignoreCache, !1).ignored;
      }
      createFilter() {
        return (path6) => !this.ignores(path6);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path6) {
        return this._test(path6, this._testCache, !0);
      }
    }, factory = (options) => new Ignore2(options), isPathValid = (path6) => checkPath(path6 && checkPath.convert(path6), path6, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process < "u" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      let makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      let REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path6) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path6) || isNotRelative(path6);
    }
  }
});

// ../../node_modules/minimist/index.js
var require_minimist = __commonJS({
  "../../node_modules/minimist/index.js"(exports2, module2) {
    "use strict";
    function hasKey(obj, keys) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      var key = keys[keys.length - 1];
      return key in o;
    }
    function isNumber(x) {
      return typeof x == "number" || /^0x[0-9a-f]+$/i.test(x) ? !0 : /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function isConstructorOrProto(obj, key) {
      return key === "constructor" && typeof obj[key] == "function" || key === "__proto__";
    }
    module2.exports = function(args, opts) {
      opts || (opts = {});
      var flags = {
        bools: {},
        strings: {},
        unknownFn: null
      };
      typeof opts.unknown == "function" && (flags.unknownFn = opts.unknown), typeof opts.boolean == "boolean" && opts.boolean ? flags.allBools = !0 : [].concat(opts.boolean).filter(Boolean).forEach(function(key2) {
        flags.bools[key2] = !0;
      });
      var aliases = {};
      function aliasIsBoolean(key2) {
        return aliases[key2].some(function(x) {
          return flags.bools[x];
        });
      }
      Object.keys(opts.alias || {}).forEach(function(key2) {
        aliases[key2] = [].concat(opts.alias[key2]), aliases[key2].forEach(function(x) {
          aliases[x] = [key2].concat(aliases[key2].filter(function(y) {
            return x !== y;
          }));
        });
      }), [].concat(opts.string).filter(Boolean).forEach(function(key2) {
        flags.strings[key2] = !0, aliases[key2] && [].concat(aliases[key2]).forEach(function(k) {
          flags.strings[k] = !0;
        });
      });
      var defaults3 = opts.default || {}, argv2 = { _: [] };
      function argDefined(key2, arg2) {
        return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key2] || flags.bools[key2] || aliases[key2];
      }
      function setKey(obj, keys, value2) {
        for (var o = obj, i2 = 0; i2 < keys.length - 1; i2++) {
          var key2 = keys[i2];
          if (isConstructorOrProto(o, key2))
            return;
          o[key2] === void 0 && (o[key2] = {}), (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype) && (o[key2] = {}), o[key2] === Array.prototype && (o[key2] = []), o = o[key2];
        }
        var lastKey = keys[keys.length - 1];
        isConstructorOrProto(o, lastKey) || ((o === Object.prototype || o === Number.prototype || o === String.prototype) && (o = {}), o === Array.prototype && (o = []), o[lastKey] === void 0 || flags.bools[lastKey] || typeof o[lastKey] == "boolean" ? o[lastKey] = value2 : Array.isArray(o[lastKey]) ? o[lastKey].push(value2) : o[lastKey] = [o[lastKey], value2]);
      }
      function setArg(key2, val, arg2) {
        if (!(arg2 && flags.unknownFn && !argDefined(key2, arg2) && flags.unknownFn(arg2) === !1)) {
          var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
          setKey(argv2, key2.split("."), value2), (aliases[key2] || []).forEach(function(x) {
            setKey(argv2, x.split("."), value2);
          });
        }
      }
      Object.keys(flags.bools).forEach(function(key2) {
        setArg(key2, defaults3[key2] === void 0 ? !1 : defaults3[key2]);
      });
      var notFlags = [];
      args.indexOf("--") !== -1 && (notFlags = args.slice(args.indexOf("--") + 1), args = args.slice(0, args.indexOf("--")));
      for (var i = 0; i < args.length; i++) {
        var arg = args[i], key, next;
        if (/^--.+=/.test(arg)) {
          var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
          key = m[1];
          var value = m[2];
          flags.bools[key] && (value = value !== "false"), setArg(key, value, arg);
        } else if (/^--no-.+/.test(arg))
          key = arg.match(/^--no-(.+)/)[1], setArg(key, !1, arg);
        else if (/^--.+/.test(arg))
          key = arg.match(/^--(.+)/)[1], next = args[i + 1], next !== void 0 && !/^(-|--)[^-]/.test(next) && !flags.bools[key] && !flags.allBools && (!aliases[key] || !aliasIsBoolean(key)) ? (setArg(key, next, arg), i += 1) : /^(true|false)$/.test(next) ? (setArg(key, next === "true", arg), i += 1) : setArg(key, flags.strings[key] ? "" : !0, arg);
        else if (/^-[^-]+/.test(arg)) {
          for (var letters = arg.slice(1, -1).split(""), broken = !1, j = 0; j < letters.length; j++) {
            if (next = arg.slice(j + 2), next === "-") {
              setArg(letters[j], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && next[0] === "=") {
              setArg(letters[j], next.slice(1), arg), broken = !0;
              break;
            }
            if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next, arg), broken = !0;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2), arg), broken = !0;
              break;
            } else
              setArg(letters[j], flags.strings[letters[j]] ? "" : !0, arg);
          }
          key = arg.slice(-1)[0], !broken && key !== "-" && (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (!aliases[key] || !aliasIsBoolean(key)) ? (setArg(key, args[i + 1], arg), i += 1) : args[i + 1] && /^(true|false)$/.test(args[i + 1]) ? (setArg(key, args[i + 1] === "true", arg), i += 1) : setArg(key, flags.strings[key] ? "" : !0, arg));
        } else if ((!flags.unknownFn || flags.unknownFn(arg) !== !1) && argv2._.push(flags.strings._ || !isNumber(arg) ? arg : Number(arg)), opts.stopEarly) {
          argv2._.push.apply(argv2._, args.slice(i + 1));
          break;
        }
      }
      return Object.keys(defaults3).forEach(function(k) {
        hasKey(argv2, k.split(".")) || (setKey(argv2, k.split("."), defaults3[k]), (aliases[k] || []).forEach(function(x) {
          setKey(argv2, x.split("."), defaults3[k]);
        }));
      }), opts["--"] ? argv2["--"] = notFlags.slice() : notFlags.forEach(function(k) {
        argv2._.push(k);
      }), argv2;
    };
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/nodes/identity.js"(exports2) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias"), DOC = Symbol.for("yaml.document"), MAP = Symbol.for("yaml.map"), PAIR = Symbol.for("yaml.pair"), SCALAR = Symbol.for("yaml.scalar"), SEQ = Symbol.for("yaml.seq"), NODE_TYPE = Symbol.for("yaml.node.type"), isAlias = (node) => !!node && typeof node == "object" && node[NODE_TYPE] === ALIAS, isDocument = (node) => !!node && typeof node == "object" && node[NODE_TYPE] === DOC, isMap = (node) => !!node && typeof node == "object" && node[NODE_TYPE] === MAP, isPair = (node) => !!node && typeof node == "object" && node[NODE_TYPE] === PAIR, isScalar = (node) => !!node && typeof node == "object" && node[NODE_TYPE] === SCALAR, isSeq = (node) => !!node && typeof node == "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node == "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return !0;
        }
      return !1;
    }
    function isNode(node) {
      if (node && typeof node == "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return !0;
        }
      return !1;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    exports2.ALIAS = ALIAS;
    exports2.DOC = DOC;
    exports2.MAP = MAP;
    exports2.NODE_TYPE = NODE_TYPE;
    exports2.PAIR = PAIR;
    exports2.SCALAR = SCALAR;
    exports2.SEQ = SEQ;
    exports2.hasAnchor = hasAnchor;
    exports2.isAlias = isAlias;
    exports2.isCollection = isCollection;
    exports2.isDocument = isDocument;
    exports2.isMap = isMap;
    exports2.isNode = isNode;
    exports2.isPair = isPair;
    exports2.isScalar = isScalar;
    exports2.isSeq = isSeq;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/visit.js"(exports2) {
    "use strict";
    var identity = require_identity(), BREAK = Symbol("break visit"), SKIP = Symbol("skip children"), REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      let visitor_ = initVisitor(visitor);
      identity.isDocument(node) ? visit_(null, node.contents, visitor_, Object.freeze([node])) === REMOVE && (node.contents = null) : visit_(null, node, visitor_, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path6) {
      let ctrl = callVisitor(key, node, visitor, path6);
      if (identity.isNode(ctrl) || identity.isPair(ctrl))
        return replaceNode(key, path6, ctrl), visit_(key, ctrl, visitor, path6);
      if (typeof ctrl != "symbol") {
        if (identity.isCollection(node)) {
          path6 = Object.freeze(path6.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            let ci = visit_(i, node.items[i], visitor, path6);
            if (typeof ci == "number")
              i = ci - 1;
            else {
              if (ci === BREAK)
                return BREAK;
              ci === REMOVE && (node.items.splice(i, 1), i -= 1);
            }
          }
        } else if (identity.isPair(node)) {
          path6 = Object.freeze(path6.concat(node));
          let ck = visit_("key", node.key, visitor, path6);
          if (ck === BREAK)
            return BREAK;
          ck === REMOVE && (node.key = null);
          let cv = visit_("value", node.value, visitor, path6);
          if (cv === BREAK)
            return BREAK;
          cv === REMOVE && (node.value = null);
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      let visitor_ = initVisitor(visitor);
      identity.isDocument(node) ? await visitAsync_(null, node.contents, visitor_, Object.freeze([node])) === REMOVE && (node.contents = null) : await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path6) {
      let ctrl = await callVisitor(key, node, visitor, path6);
      if (identity.isNode(ctrl) || identity.isPair(ctrl))
        return replaceNode(key, path6, ctrl), visitAsync_(key, ctrl, visitor, path6);
      if (typeof ctrl != "symbol") {
        if (identity.isCollection(node)) {
          path6 = Object.freeze(path6.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            let ci = await visitAsync_(i, node.items[i], visitor, path6);
            if (typeof ci == "number")
              i = ci - 1;
            else {
              if (ci === BREAK)
                return BREAK;
              ci === REMOVE && (node.items.splice(i, 1), i -= 1);
            }
          }
        } else if (identity.isPair(node)) {
          path6 = Object.freeze(path6.concat(node));
          let ck = await visitAsync_("key", node.key, visitor, path6);
          if (ck === BREAK)
            return BREAK;
          ck === REMOVE && (node.key = null);
          let cv = await visitAsync_("value", node.value, visitor, path6);
          if (cv === BREAK)
            return BREAK;
          cv === REMOVE && (node.value = null);
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      return typeof visitor == "object" && (visitor.Collection || visitor.Node || visitor.Value) ? Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor) : visitor;
    }
    function callVisitor(key, node, visitor, path6) {
      var _a2, _b, _c, _d, _e;
      if (typeof visitor == "function")
        return visitor(key, node, path6);
      if (identity.isMap(node))
        return (_a2 = visitor.Map) == null ? void 0 : _a2.call(visitor, key, node, path6);
      if (identity.isSeq(node))
        return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node, path6);
      if (identity.isPair(node))
        return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node, path6);
      if (identity.isScalar(node))
        return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node, path6);
      if (identity.isAlias(node))
        return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node, path6);
    }
    function replaceNode(key, path6, node) {
      let parent = path6[path6.length - 1];
      if (identity.isCollection(parent))
        parent.items[key] = node;
      else if (identity.isPair(parent))
        key === "key" ? parent.key = node : parent.value = node;
      else if (identity.isDocument(parent))
        parent.contents = node;
      else {
        let pt = identity.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports2.visit = visit;
    exports2.visitAsync = visitAsync;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/doc/directives.js"(exports2) {
    "use strict";
    var identity = require_identity(), visit = require_visit(), escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    }, escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]), Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, _Directives.defaultYaml, yaml), this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        let copy2 = new _Directives(this.yaml, this.tags);
        return copy2.docStart = this.docStart, copy2;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        let res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = !0;
            break;
          case "1.2":
            this.atNextDocument = !1, this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            }, this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        this.atNextDocument && (this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, _Directives.defaultTags), this.atNextDocument = !1);
        let parts = line.trim().split(/[ \t]+/), name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2 && (onError(0, "%TAG directive should contain exactly two parts"), parts.length < 2))
              return !1;
            let [handle, prefix] = parts;
            return this.tags[handle] = prefix, !0;
          }
          case "%YAML": {
            if (this.yaml.explicit = !0, parts.length !== 1)
              return onError(0, "%YAML directive should contain exactly one part"), !1;
            let [version2] = parts;
            if (version2 === "1.1" || version2 === "1.2")
              return this.yaml.version = version2, !0;
            {
              let isValid = /^\d+\.\d+$/.test(version2);
              return onError(6, `Unsupported YAML version ${version2}`, isValid), !1;
            }
          }
          default:
            return onError(0, `Unknown directive ${name}`, !0), !1;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!")
          return onError(`Not a valid tag: ${source}`), null;
        if (source[1] === "<") {
          let verbatim = source.slice(2, -1);
          return verbatim === "!" || verbatim === "!!" ? (onError(`Verbatim tags aren't resolved, so ${source} is invalid.`), null) : (source[source.length - 1] !== ">" && onError("Verbatim tags must end with a >"), verbatim);
        }
        let [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        suffix || onError(`The ${source} tag has no suffix`);
        let prefix = this.tags[handle];
        if (prefix)
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            return onError(String(error)), null;
          }
        return handle === "!" ? source : (onError(`Could not resolve tag: ${source}`), null);
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (let [handle, prefix] of Object.entries(this.tags))
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        let lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], tagEntries = Object.entries(this.tags), tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
          let tags = {};
          visit.visit(doc.contents, (_key, node) => {
            identity.isNode(node) && node.tag && (tags[node.tag] = !0);
          }), tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (let [handle, prefix] of tagEntries)
          handle === "!!" && prefix === "tag:yaml.org,2002:" || (!doc || tagNames.some((tn) => tn.startsWith(prefix))) && lines.push(`%TAG ${handle} ${prefix}`);
        return lines.join(`
`);
      }
    };
    Directives.defaultYaml = { explicit: !1, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports2.Directives = Directives;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/doc/anchors.js"(exports2) {
    "use strict";
    var identity = require_identity(), visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        let msg = `Anchor must not contain whitespace or control characters: ${JSON.stringify(anchor)}`;
        throw new Error(msg);
      }
      return !0;
    }
    function anchorNames(root) {
      let anchors = /* @__PURE__ */ new Set();
      return visit.visit(root, {
        Value(_key, node) {
          node.anchor && anchors.add(node.anchor);
        }
      }), anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; ; ++i) {
        let name = `${prefix}${i}`;
        if (!exclude.has(name))
          return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      let aliasObjects = [], sourceObjects = /* @__PURE__ */ new Map(), prevAnchors = null;
      return {
        onAnchor: (source) => {
          aliasObjects.push(source), prevAnchors || (prevAnchors = anchorNames(doc));
          let anchor = findNewAnchor(prefix, prevAnchors);
          return prevAnchors.add(anchor), anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (let source of aliasObjects) {
            let ref = sourceObjects.get(source);
            if (typeof ref == "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node)))
              ref.node.anchor = ref.anchor;
            else {
              let error = new Error("Failed to resolve repeated object (this should not happen)");
              throw error.source = source, error;
            }
          }
        },
        sourceObjects
      };
    }
    exports2.anchorIsValid = anchorIsValid;
    exports2.anchorNames = anchorNames;
    exports2.createNodeAnchors = createNodeAnchors;
    exports2.findNewAnchor = findNewAnchor;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/doc/applyReviver.js"(exports2) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val == "object")
        if (Array.isArray(val))
          for (let i = 0, len = val.length; i < len; ++i) {
            let v0 = val[i], v1 = applyReviver(reviver, val, String(i), v0);
            v1 === void 0 ? delete val[i] : v1 !== v0 && (val[i] = v1);
          }
        else if (val instanceof Map)
          for (let k of Array.from(val.keys())) {
            let v0 = val.get(k), v1 = applyReviver(reviver, val, k, v0);
            v1 === void 0 ? val.delete(k) : v1 !== v0 && val.set(k, v1);
          }
        else if (val instanceof Set)
          for (let v0 of Array.from(val)) {
            let v1 = applyReviver(reviver, val, v0, v0);
            v1 === void 0 ? val.delete(v0) : v1 !== v0 && (val.delete(v0), val.add(v1));
          }
        else
          for (let [k, v0] of Object.entries(val)) {
            let v1 = applyReviver(reviver, val, k, v0);
            v1 === void 0 ? delete val[k] : v1 !== v0 && (val[k] = v1);
          }
      return reviver.call(obj, key, val);
    }
    exports2.applyReviver = applyReviver;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/nodes/toJS.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function toJS(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
      if (value && typeof value.toJSON == "function") {
        if (!ctx || !identity.hasAnchor(value))
          return value.toJSON(arg, ctx);
        let data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value, data), ctx.onCreate = (res2) => {
          data.res = res2, delete ctx.onCreate;
        };
        let res = value.toJSON(arg, ctx);
        return ctx.onCreate && ctx.onCreate(res), res;
      }
      return typeof value == "bigint" && !(ctx != null && ctx.keep) ? Number(value) : value;
    }
    exports2.toJS = toJS;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/nodes/Node.js"(exports2) {
    "use strict";
    var applyReviver = require_applyReviver(), identity = require_identity(), toJS = require_toJS(), NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        let copy2 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        return this.range && (copy2.range = this.range.slice()), copy2;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
          throw new TypeError("A document argument is required");
        let ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: !0,
          mapAsMap: mapAsMap === !0,
          mapKeyWarned: !1,
          maxAliasCount: typeof maxAliasCount == "number" ? maxAliasCount : 100
        }, res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor == "function")
          for (let { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver == "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports2.NodeBase = NodeBase;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/nodes/Alias.js"(exports2) {
    "use strict";
    var anchors = require_anchors(), visit = require_visit(), identity = require_identity(), Node = require_Node(), toJS = require_toJS(), Alias = class extends Node.NodeBase {
      constructor(source) {
        super(identity.ALIAS), this.source = source, Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found;
        return visit.visit(doc, {
          Node: (_key, node) => {
            if (node === this)
              return visit.visit.BREAK;
            node.anchor === this.source && (found = node);
          }
        }), found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        let { anchors: anchors2, doc, maxAliasCount } = ctx, source = this.resolve(doc);
        if (!source) {
          let msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source);
        if (data || (toJS.toJS(source, null, ctx), data = anchors2.get(source)), !data || data.res === void 0) {
          let msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0 && (data.count += 1, data.aliasCount === 0 && (data.aliasCount = getAliasCount(doc, source, anchors2)), data.count * data.aliasCount > maxAliasCount)) {
          let msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        let src = `*${this.source}`;
        if (ctx) {
          if (anchors.anchorIsValid(this.source), ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            let msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity.isAlias(node)) {
        let source = node.resolve(doc), anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        let count = 0;
        for (let item of node.items) {
          let c = getAliasCount(doc, item, anchors2);
          c > count && (count = c);
        }
        return count;
      } else if (identity.isPair(node)) {
        let kc = getAliasCount(doc, node.key, anchors2), vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports2.Alias = Alias;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/nodes/Scalar.js"(exports2) {
    "use strict";
    var identity = require_identity(), Node = require_Node(), toJS = require_toJS(), isScalarValue = (value) => !value || typeof value != "function" && typeof value != "object", Scalar = class extends Node.NodeBase {
      constructor(value) {
        super(identity.SCALAR), this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx != null && ctx.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports2.Scalar = Scalar;
    exports2.isScalarValue = isScalarValue;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/doc/createNode.js"(exports2) {
    "use strict";
    var Alias = require_Alias(), identity = require_identity(), Scalar = require_Scalar(), defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        let match2 = tags.filter((t) => t.tag === tagName), tagObj = match2.find((t) => !t.format) ?? match2[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => {
        var _a2;
        return ((_a2 = t.identify) == null ? void 0 : _a2.call(t, value)) && !t.format;
      });
    }
    function createNode(value, tagName, ctx) {
      var _a2, _b, _c;
      if (identity.isDocument(value) && (value = value.contents), identity.isNode(value))
        return value;
      if (identity.isPair(value)) {
        let map = (_b = (_a2 = ctx.schema[identity.MAP]).createNode) == null ? void 0 : _b.call(_a2, ctx.schema, null, ctx);
        return map.items.push(value), map;
      }
      (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt < "u" && value instanceof BigInt) && (value = value.valueOf());
      let { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx, ref;
      if (aliasDuplicateObjects && value && typeof value == "object") {
        if (ref = sourceObjects.get(value), ref)
          return ref.anchor || (ref.anchor = onAnchor(value)), new Alias.Alias(ref.anchor);
        ref = { anchor: null, node: null }, sourceObjects.set(value, ref);
      }
      tagName != null && tagName.startsWith("!!") && (tagName = defaultTagPrefix + tagName.slice(2));
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON == "function" && (value = value.toJSON()), !value || typeof value != "object") {
          let node2 = new Scalar.Scalar(value);
          return ref && (ref.node = node2), node2;
        }
        tagObj = value instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
      }
      onTagObj && (onTagObj(tagObj), delete ctx.onTagObj);
      let node = tagObj != null && tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof ((_c = tagObj == null ? void 0 : tagObj.nodeClass) == null ? void 0 : _c.from) == "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
      return tagName ? node.tag = tagName : tagObj.default || (node.tag = tagObj.tag), ref && (ref.node = node), node;
    }
    exports2.createNode = createNode;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/nodes/Collection.js"(exports2) {
    "use strict";
    var createNode = require_createNode(), identity = require_identity(), Node = require_Node();
    function collectionFromPath(schema, path6, value) {
      let v = value;
      for (let i = path6.length - 1; i >= 0; --i) {
        let k = path6[i];
        if (typeof k == "number" && Number.isInteger(k) && k >= 0) {
          let a = [];
          a[k] = v, v = a;
        } else
          v = /* @__PURE__ */ new Map([[k, v]]);
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: !1,
        keepUndefined: !1,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path6) => path6 == null || typeof path6 == "object" && !!path6[Symbol.iterator]().next().done, Collection = class extends Node.NodeBase {
      constructor(type, schema) {
        super(type), Object.defineProperty(this, "schema", {
          value: schema,
          configurable: !0,
          enumerable: !1,
          writable: !0
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        let copy2 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        return schema && (copy2.schema = schema), copy2.items = copy2.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it), this.range && (copy2.range = this.range.slice()), copy2;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path6, value) {
        if (isEmptyPath(path6))
          this.add(value);
        else {
          let [key, ...rest] = path6, node = this.get(key, !0);
          if (identity.isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path6) {
        let [key, ...rest] = path6;
        if (rest.length === 0)
          return this.delete(key);
        let node = this.get(key, !0);
        if (identity.isCollection(node))
          return node.deleteIn(rest);
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path6, keepScalar) {
        let [key, ...rest] = path6, node = this.get(key, !0);
        return rest.length === 0 ? !keepScalar && identity.isScalar(node) ? node.value : node : identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity.isPair(node))
            return !1;
          let n = node.value;
          return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path6) {
        let [key, ...rest] = path6;
        if (rest.length === 0)
          return this.has(key);
        let node = this.get(key, !0);
        return identity.isCollection(node) ? node.hasIn(rest) : !1;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path6, value) {
        let [key, ...rest] = path6;
        if (rest.length === 0)
          this.set(key, value);
        else {
          let node = this.get(key, !0);
          if (identity.isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    Collection.maxFlowStringSingleLineLength = 60;
    exports2.Collection = Collection;
    exports2.collectionFromPath = collectionFromPath;
    exports2.isEmptyPath = isEmptyPath;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/stringify/stringifyComment.js"(exports2) {
    "use strict";
    var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent) {
      return /^\n+$/.test(comment) ? comment.substring(1) : indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    var lineComment = (str, indent, comment) => str.endsWith(`
`) ? indentComment(comment, indent) : comment.includes(`
`) ? `
` + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
    exports2.indentComment = indentComment;
    exports2.lineComment = lineComment;
    exports2.stringifyComment = stringifyComment;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/stringify/foldFlowLines.js"(exports2) {
    "use strict";
    var FOLD_FLOW = "flow", FOLD_BLOCK = "block", FOLD_QUOTED = "quoted";
    function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text;
      let endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      let folds = [], escapedFolds = {}, end = lineWidth - indent.length;
      typeof indentAtStart == "number" && (indentAtStart > lineWidth - Math.max(2, minContentWidth) ? folds.push(0) : end = lineWidth - indentAtStart);
      let split, prev, overflow = !1, i = -1, escStart = -1, escEnd = -1;
      mode === FOLD_BLOCK && (i = consumeMoreIndentedLines(text, i), i !== -1 && (end = i + endStep));
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          switch (escStart = i, text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === `
`)
          mode === FOLD_BLOCK && (i = consumeMoreIndentedLines(text, i)), end = i + endStep, split = void 0;
        else {
          if (ch === " " && prev && prev !== " " && prev !== `
` && prev !== "	") {
            let next = text[i + 1];
            next && next !== " " && next !== `
` && next !== "	" && (split = i);
          }
          if (i >= end)
            if (split)
              folds.push(split), end = split + endStep, split = void 0;
            else if (mode === FOLD_QUOTED) {
              for (; prev === " " || prev === "	"; )
                prev = ch, ch = text[i += 1], overflow = !0;
              let j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j), escapedFolds[j] = !0, end = j + endStep, split = void 0;
            } else
              overflow = !0;
        }
        prev = ch;
      }
      if (overflow && onOverflow && onOverflow(), folds.length === 0)
        return text;
      onFold && onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        let fold = folds[i2], end2 = folds[i2 + 1] || text.length;
        fold === 0 ? res = `
${indent}${text.slice(0, end2)}` : (mode === FOLD_QUOTED && escapedFolds[fold] && (res += `${text[fold]}\\`), res += `
${indent}${text.slice(fold + 1, end2)}`);
      }
      return res;
    }
    function consumeMoreIndentedLines(text, i) {
      let ch = text[i + 1];
      for (; ch === " " || ch === "	"; ) {
        do
          ch = text[i += 1];
        while (ch && ch !== `
`);
        ch = text[i + 1];
      }
      return i;
    }
    exports2.FOLD_BLOCK = FOLD_BLOCK;
    exports2.FOLD_FLOW = FOLD_FLOW;
    exports2.FOLD_QUOTED = FOLD_QUOTED;
    exports2.foldFlowLines = foldFlowLines;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/stringify/stringifyString.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), foldFlowLines = require_foldFlowLines(), getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    }), containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return !1;
      let limit = lineWidth - indentLength, strLen = str.length;
      if (strLen <= limit)
        return !1;
      for (let i = 0, start = 0; i < strLen; ++i)
        if (str[i] === `
`) {
          if (i - start > limit)
            return !0;
          if (start = i + 1, strLen - start <= limit)
            return !1;
        }
      return !0;
    }
    function doubleQuotedString(value, ctx) {
      let json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON)
        return json;
      let { implicitKey } = ctx, minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength, indent = ctx.indent || (containsDocumentMarker(value) ? "  " : ""), str = "", start = 0;
      for (let i = 0, ch = json[i]; ch; ch = json[++i])
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n" && (str += json.slice(start, i) + "\\ ", i += 1, start = i, ch = "\\"), ch === "\\")
          switch (json[i + 1]) {
            case "u":
              {
                str += json.slice(start, i);
                let code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    code.substr(0, 2) === "00" ? str += "\\x" + code.substr(2) : str += json.substr(i, 6);
                }
                i += 5, start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength)
                i += 1;
              else {
                for (str += json.slice(start, i) + `

`; json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"'; )
                  str += `
`, i += 2;
                str += indent, json[i + 2] === " " && (str += "\\"), i += 1, start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      return str = start ? str + json.slice(start) : json, implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, !1));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.options.singleQuote === !1 || ctx.implicitKey && value.includes(`
`) || /[ \t]\n|\n[ \t]/.test(value))
        return doubleQuotedString(value, ctx);
      let indent = ctx.indent || (containsDocumentMarker(value) ? "  " : ""), res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, !1));
    }
    function quotedString(value, ctx) {
      let { singleQuote } = ctx.options, qs;
      if (singleQuote === !1)
        qs = doubleQuotedString;
      else {
        let hasDouble = value.includes('"'), hasSingle = value.includes("'");
        hasDouble && !hasSingle ? qs = singleQuotedString : hasSingle && !hasDouble ? qs = doubleQuotedString : qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
      let { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value))
        return quotedString(value, ctx);
      let indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : ""), literal = blockQuote === "literal" ? !0 : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? !1 : type === Scalar.Scalar.BLOCK_LITERAL ? !0 : !lineLengthOverLimit(value, lineWidth, indent.length);
      if (!value)
        return literal ? `|
` : `>
`;
      let chomp, endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        let ch = value[endStart - 1];
        if (ch !== `
` && ch !== "	" && ch !== " ")
          break;
      }
      let end = value.substring(endStart), endNlPos = end.indexOf(`
`);
      endNlPos === -1 ? chomp = "-" : value === end || endNlPos !== end.length - 1 ? (chomp = "+", onChompKeep && onChompKeep()) : chomp = "", end && (value = value.slice(0, -end.length), end[end.length - 1] === `
` && (end = end.slice(0, -1)), end = end.replace(blockEndNewlines, `$&${indent}`));
      let startWithSpace = !1, startEnd, startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        let ch = value[startEnd];
        if (ch === " ")
          startWithSpace = !0;
        else if (ch === `
`)
          startNlPos = startEnd;
        else
          break;
      }
      let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      start && (value = value.substring(start.length), start = start.replace(/\n+/g, `$&${indent}`));
      let header = (literal ? "|" : ">") + (startWithSpace ? indent ? "2" : "1" : "") + chomp;
      if (comment && (header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " ")), onComment && onComment()), literal)
        return value = value.replace(/\n+/g, `$&${indent}`), `${header}
${indent}${start}${value}${end}`;
      value = value.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      let body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx, !0));
      return `${header}
${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      let { type, value } = item, { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
      if (implicitKey && value.includes(`
`) || inFlow && /[[\]{},]/.test(value))
        return quotedString(value, ctx);
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value))
        return implicitKey || inFlow || !value.includes(`
`) ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes(`
`))
        return blockString(item, ctx, onComment, onChompKeep);
      if (containsDocumentMarker(value)) {
        if (indent === "")
          return ctx.forceBlockIndent = !0, blockString(item, ctx, onComment, onChompKeep);
        if (implicitKey && indent === indentStep)
          return quotedString(value, ctx);
      }
      let str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        let test = (tag) => {
          var _a2;
          return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a2 = tag.test) == null ? void 0 : _a2.test(str));
        }, { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat != null && compat.some(test))
          return quotedString(value, ctx);
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, !1));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      let { implicitKey, inFlow } = ctx, ss = typeof item.value == "string" ? item : Object.assign({}, item, { value: String(item.value) }), { type } = item;
      type !== Scalar.Scalar.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value) && (type = Scalar.Scalar.QUOTE_DOUBLE);
      let _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      }, res = _stringify(type);
      if (res === null) {
        let { defaultKeyType, defaultStringType } = ctx.options, t = implicitKey && defaultKeyType || defaultStringType;
        if (res = _stringify(t), res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports2.stringifyString = stringifyString;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/stringify/stringify.js
var require_stringify2 = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/stringify/stringify.js"(exports2) {
    "use strict";
    var anchors = require_anchors(), identity = require_identity(), stringifyComment = require_stringifyComment(), stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      let opt = Object.assign({
        blockQuote: !0,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: !1,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: !0,
        indentSeq: !0,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: !1,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: !0
      }, doc.schema.toStringOptions, options), inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = !1;
          break;
        case "flow":
          inFlow = !0;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent == "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      var _a2;
      if (item.tag) {
        let match2 = tags.filter((t) => t.tag === item.tag);
        if (match2.length > 0)
          return match2.find((t) => t.format === item.format) ?? match2[0];
      }
      let tagObj, obj;
      if (identity.isScalar(item)) {
        obj = item.value;
        let match2 = tags.filter((t) => {
          var _a3;
          return (_a3 = t.identify) == null ? void 0 : _a3.call(t, obj);
        });
        tagObj = match2.find((t) => t.format === item.format) ?? match2.find((t) => !t.format);
      } else
        obj = item, tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      if (!tagObj) {
        let name = ((_a2 = obj == null ? void 0 : obj.constructor) == null ? void 0 : _a2.name) ?? typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      let props = [], anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      anchor && anchors.anchorIsValid(anchor) && (anchors$1.add(anchor), props.push(`&${anchor}`));
      let tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
      return tag && props.push(doc.directives.tagString(tag)), props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      var _a2;
      if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if ((_a2 = ctx.resolvedAliases) != null && _a2.has(item))
          throw new TypeError("Cannot stringify circular structure without alias nodes");
        ctx.resolvedAliases ? ctx.resolvedAliases.add(item) : ctx.resolvedAliases = /* @__PURE__ */ new Set([item]), item = item.resolve(ctx.doc);
      }
      let tagObj, node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      tagObj || (tagObj = getTagObject(ctx.doc.schema.tags, node));
      let props = stringifyProps(node, tagObj, ctx);
      props.length > 0 && (ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1);
      let str = typeof tagObj.stringify == "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      return props ? identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}` : str;
    }
    exports2.createStringifyContext = createStringifyContext;
    exports2.stringify = stringify;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/stringify/stringifyPair.js"(exports2) {
    "use strict";
    var identity = require_identity(), Scalar = require_Scalar(), stringify = require_stringify2(), stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      let { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx, keyComment = identity.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment)
          throw new Error("With simple keys, key nodes cannot have comments");
        if (identity.isCollection(key)) {
          let msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key == "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: !1,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
      });
      let keyCommentDone = !1, chompKeep = !1, str = stringify.stringify(key, ctx, () => keyCommentDone = !0, () => chompKeep = !0);
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = !0;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null)
          return keyCommentDone && onComment && onComment(), str === "" ? "?" : explicitKey ? `? ${str}` : str;
      } else if (allNullValues && !simpleKeys || value == null && explicitKey)
        return str = `? ${str}`, keyComment && !keyCommentDone ? str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment)) : chompKeep && onChompKeep && onChompKeep(), str;
      keyCommentDone && (keyComment = null), explicitKey ? (keyComment && (str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment))), str = `? ${str}
${indent}:`) : (str = `${str}:`, keyComment && (str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment))));
      let vsb, vcb, valueComment;
      identity.isNode(value) ? (vsb = !!value.spaceBefore, vcb = value.commentBefore, valueComment = value.comment) : (vsb = !1, vcb = null, valueComment = null, value && typeof value == "object" && (value = doc.createNode(value))), ctx.implicitKey = !1, !explicitKey && !keyComment && identity.isScalar(value) && (ctx.indentAtStart = str.length + 1), chompKeep = !1, !indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor && (ctx.indent = ctx.indent.substring(2));
      let valueCommentDone = !1, valueStr = stringify.stringify(value, ctx, () => valueCommentDone = !0, () => chompKeep = !0), ws = " ";
      if (keyComment || vsb || vcb) {
        if (ws = vsb ? `
` : "", vcb) {
          let cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        valueStr === "" && !ctx.inFlow ? ws === `
` && (ws = `

`) : ws += `
${ctx.indent}`;
      } else if (!explicitKey && identity.isCollection(value)) {
        let vs0 = valueStr[0], nl0 = valueStr.indexOf(`
`), hasNewline = nl0 !== -1, flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = !1;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!" && (sp0 = valueStr.indexOf(" ", sp0 + 1)), (sp0 === -1 || nl0 < sp0) && (hasPropsLine = !0);
          }
          hasPropsLine || (ws = `
${ctx.indent}`);
        }
      } else
        (valueStr === "" || valueStr[0] === `
`) && (ws = "");
      return str += ws + valueStr, ctx.inFlow ? valueCommentDone && onComment && onComment() : valueComment && !valueCommentDone ? str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment)) : chompKeep && onChompKeep && onChompKeep(), str;
    }
    exports2.stringifyPair = stringifyPair;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/log.js"(exports2) {
    "use strict";
    function debug(logLevel, ...messages) {
      logLevel === "debug" && console.log(...messages);
    }
    function warn(logLevel, warning) {
      (logLevel === "debug" || logLevel === "warn") && (typeof process < "u" && process.emitWarning ? process.emitWarning(warning) : console.warn(warning));
    }
    exports2.debug = debug;
    exports2.warn = warn;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports2) {
    "use strict";
    var log2 = require_log(), stringify = require_stringify2(), identity = require_identity(), Scalar = require_Scalar(), toJS = require_toJS(), MERGE_KEY = "<<";
    function addPairToJSMap(ctx, map, { key, value }) {
      if (ctx != null && ctx.doc.schema.merge && isMergeKey(key))
        if (value = identity.isAlias(value) ? value.resolve(ctx.doc) : value, identity.isSeq(value))
          for (let it of value.items)
            mergeToJSMap(ctx, map, it);
        else if (Array.isArray(value))
          for (let it of value)
            mergeToJSMap(ctx, map, it);
        else
          mergeToJSMap(ctx, map, value);
      else {
        let jsKey = toJS.toJS(key, "", ctx);
        if (map instanceof Map)
          map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        else if (map instanceof Set)
          map.add(jsKey);
        else {
          let stringKey = stringifyKey(key, jsKey, ctx), jsValue = toJS.toJS(value, stringKey, ctx);
          stringKey in map ? Object.defineProperty(map, stringKey, {
            value: jsValue,
            writable: !0,
            enumerable: !0,
            configurable: !0
          }) : map[stringKey] = jsValue;
        }
      }
      return map;
    }
    var isMergeKey = (key) => key === MERGE_KEY || identity.isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.Scalar.PLAIN);
    function mergeToJSMap(ctx, map, value) {
      let source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!identity.isMap(source))
        throw new Error("Merge sources must be maps or map aliases");
      let srcMap = source.toJSON(null, ctx, Map);
      for (let [key, value2] of srcMap)
        map instanceof Map ? map.has(key) || map.set(key, value2) : map instanceof Set ? map.add(key) : Object.prototype.hasOwnProperty.call(map, key) || Object.defineProperty(map, key, {
          value: value2,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      return map;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey != "object")
        return String(jsKey);
      if (identity.isNode(key) && (ctx != null && ctx.doc)) {
        let strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (let node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = !0, strCtx.inStringifyKey = !0;
        let strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          jsonStr.length > 40 && (jsonStr = jsonStr.substring(0, 36) + '..."'), log2.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`), ctx.mapKeyWarned = !0;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports2.addPairToJSMap = addPairToJSMap;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/nodes/Pair.js"(exports2) {
    "use strict";
    var createNode = require_createNode(), stringifyPair = require_stringifyPair(), addPairToJSMap = require_addPairToJSMap(), identity = require_identity();
    function createPair(key, value, ctx) {
      let k = createNode.createNode(key, void 0, ctx), v = createNode.createNode(value, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR }), this.key = key, this.value = value;
      }
      clone(schema) {
        let { key, value } = this;
        return identity.isNode(key) && (key = key.clone(schema)), identity.isNode(value) && (value = value.clone(schema)), new _Pair(key, value);
      }
      toJSON(_, ctx) {
        let pair = ctx != null && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx != null && ctx.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports2.Pair = Pair;
    exports2.createPair = createPair;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/stringify/stringifyCollection.js"(exports2) {
    "use strict";
    var Collection = require_Collection(), identity = require_identity(), stringify = require_stringify2(), stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      return (ctx.inFlow ?? collection.flow ? stringifyFlowCollection : stringifyBlockCollection)(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      let { indent, options: { commentString } } = ctx, itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null }), chompKeep = !1, lines = [];
      for (let i = 0; i < items.length; ++i) {
        let item = items[i], comment2 = null;
        if (identity.isNode(item))
          !chompKeep && item.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, item.commentBefore, chompKeep), item.comment && (comment2 = item.comment);
        else if (identity.isPair(item)) {
          let ik = identity.isNode(item.key) ? item.key : null;
          ik && (!chompKeep && ik.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, ik.commentBefore, chompKeep));
        }
        chompKeep = !1;
        let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = !0);
        comment2 && (str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2))), chompKeep && comment2 && (chompKeep = !1), lines.push(blockItemPrefix + str2);
      }
      let str;
      if (lines.length === 0)
        str = flowChars.start + flowChars.end;
      else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
          let line = lines[i];
          str += line ? `
${indent}${line}` : `
`;
        }
      }
      return comment ? (str += `
` + stringifyComment.indentComment(commentString(comment), indent), onComment && onComment()) : chompKeep && onChompKeep && onChompKeep(), str;
    }
    function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
      let { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      let itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: !0,
        type: null
      }), reqNewline = !1, linesAtValue = 0, lines = [];
      for (let i = 0; i < items.length; ++i) {
        let item = items[i], comment2 = null;
        if (identity.isNode(item))
          item.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, item.commentBefore, !1), item.comment && (comment2 = item.comment);
        else if (identity.isPair(item)) {
          let ik = identity.isNode(item.key) ? item.key : null;
          ik && (ik.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, ik.commentBefore, !1), ik.comment && (reqNewline = !0));
          let iv = identity.isNode(item.value) ? item.value : null;
          iv ? (iv.comment && (comment2 = iv.comment), iv.commentBefore && (reqNewline = !0)) : item.value == null && (ik != null && ik.comment) && (comment2 = ik.comment);
        }
        comment2 && (reqNewline = !0);
        let str2 = stringify.stringify(item, itemCtx, () => comment2 = null);
        i < items.length - 1 && (str2 += ","), comment2 && (str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2))), !reqNewline && (lines.length > linesAtValue || str2.includes(`
`)) && (reqNewline = !0), lines.push(str2), linesAtValue = lines.length;
      }
      let str, { start, end } = flowChars;
      if (lines.length === 0)
        str = start + end;
      else if (reqNewline || (reqNewline = lines.reduce((sum, line) => sum + line.length + 2, 2) > Collection.Collection.maxFlowStringSingleLineLength), reqNewline) {
        str = start;
        for (let line of lines)
          str += line ? `
${indentStep}${indent}${line}` : `
`;
        str += `
${indent}${end}`;
      } else
        str = `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
      return comment && (str += stringifyComment.lineComment(str, indent, commentString(comment)), onComment && onComment()), str;
    }
    function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
      if (comment && chompKeep && (comment = comment.replace(/^\n+/, "")), comment) {
        let ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart());
      }
    }
    exports2.stringifyCollection = stringifyCollection;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/nodes/YAMLMap.js"(exports2) {
    "use strict";
    var stringifyCollection = require_stringifyCollection(), addPairToJSMap = require_addPairToJSMap(), Collection = require_Collection(), identity = require_identity(), Pair = require_Pair(), Scalar = require_Scalar();
    function findPair(items, key) {
      let k = identity.isScalar(key) ? key.value : key;
      for (let it of items)
        if (identity.isPair(it) && (it.key === key || it.key === k || identity.isScalar(it.key) && it.key.value === k))
          return it;
    }
    var YAMLMap = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity.MAP, schema), this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        let { keepUndefined, replacer } = ctx, map = new this(schema), add = (key, value) => {
          if (typeof replacer == "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          (value !== void 0 || keepUndefined) && map.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map)
          for (let [key, value] of obj)
            add(key, value);
        else if (obj && typeof obj == "object")
          for (let key of Object.keys(obj))
            add(key, obj[key]);
        return typeof schema.sortMapEntries == "function" && map.items.sort(schema.sortMapEntries), map;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        var _a2;
        let _pair;
        identity.isPair(pair) ? _pair = pair : !pair || typeof pair != "object" || !("key" in pair) ? _pair = new Pair.Pair(pair, pair == null ? void 0 : pair.value) : _pair = new Pair.Pair(pair.key, pair.value);
        let prev = findPair(this.items, _pair.key), sortEntries = (_a2 = this.schema) == null ? void 0 : _a2.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value) ? prev.value.value = _pair.value : prev.value = _pair.value;
        } else if (sortEntries) {
          let i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          i === -1 ? this.items.push(_pair) : this.items.splice(i, 0, _pair);
        } else
          this.items.push(_pair);
      }
      delete(key) {
        let it = findPair(this.items, key);
        return it ? this.items.splice(this.items.indexOf(it), 1).length > 0 : !1;
      }
      get(key, keepScalar) {
        let it = findPair(this.items, key), node = it == null ? void 0 : it.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), !0);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        let map = Type ? new Type() : ctx != null && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        ctx != null && ctx.onCreate && ctx.onCreate(map);
        for (let item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (let item of this.items)
          if (!identity.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        return !ctx.allNullValues && this.hasAllNullValues(!1) && (ctx = Object.assign({}, ctx, { allNullValues: !0 })), stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports2.YAMLMap = YAMLMap;
    exports2.findPair = findPair;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/common/map.js"(exports2) {
    "use strict";
    var identity = require_identity(), YAMLMap = require_YAMLMap(), map = {
      collection: "map",
      default: !0,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map2, onError) {
        return identity.isMap(map2) || onError("Expected a mapping for this tag"), map2;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
    };
    exports2.map = map;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/nodes/YAMLSeq.js"(exports2) {
    "use strict";
    var createNode = require_createNode(), stringifyCollection = require_stringifyCollection(), Collection = require_Collection(), identity = require_identity(), Scalar = require_Scalar(), toJS = require_toJS(), YAMLSeq = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity.SEQ, schema), this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        let idx = asItemIndex(key);
        return typeof idx != "number" ? !1 : this.items.splice(idx, 1).length > 0;
      }
      get(key, keepScalar) {
        let idx = asItemIndex(key);
        if (typeof idx != "number")
          return;
        let it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        let idx = asItemIndex(key);
        return typeof idx == "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        let idx = asItemIndex(key);
        if (typeof idx != "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        let prev = this.items[idx];
        identity.isScalar(prev) && Scalar.isScalarValue(value) ? prev.value = value : this.items[idx] = value;
      }
      toJSON(_, ctx) {
        let seq = [];
        ctx != null && ctx.onCreate && ctx.onCreate(seq);
        let i = 0;
        for (let item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx ? stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        }) : JSON.stringify(this);
      }
      static from(schema, obj, ctx) {
        let { replacer } = ctx, seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer == "function") {
              let key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx = identity.isScalar(key) ? key.value : key;
      return idx && typeof idx == "string" && (idx = Number(idx)), typeof idx == "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports2.YAMLSeq = YAMLSeq;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/common/seq.js"(exports2) {
    "use strict";
    var identity = require_identity(), YAMLSeq = require_YAMLSeq(), seq = {
      collection: "seq",
      default: !0,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        return identity.isSeq(seq2) || onError("Expected a sequence for this tag"), seq2;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
    };
    exports2.seq = seq;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/common/string.js
var require_string2 = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/common/string.js"(exports2) {
    "use strict";
    var stringifyString = require_stringifyString(), string = {
      identify: (value) => typeof value == "string",
      default: !0,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        return ctx = Object.assign({ actualString: !0 }, ctx), stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports2.string = string;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/common/null.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: !0,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) => typeof source == "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    exports2.nullTag = nullTag;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/core/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), boolTag = {
      identify: (value) => typeof value == "boolean",
      default: !0,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          let sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports2.boolTag = boolTag;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/stringify/stringifyNumber.js"(exports2) {
    "use strict";
    function stringifyNumber({ format, minFractionDigits, tag, value }) {
      if (typeof value == "bigint")
        return String(value);
      let num = typeof value == "number" ? value : Number(value);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        i < 0 && (i = n.length, n += ".");
        let d = minFractionDigits - (n.length - i - 1);
        for (; d-- > 0; )
          n += "0";
      }
      return n;
    }
    exports2.stringifyNumber = stringifyNumber;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/core/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), stringifyNumber = require_stringifyNumber(), floatNaN = {
      identify: (value) => typeof value == "number",
      default: !0,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    }, floatExp = {
      identify: (value) => typeof value == "number",
      default: !0,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        let num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    }, float = {
      identify: (value) => typeof value == "number",
      default: !0,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        let node = new Scalar.Scalar(parseFloat(str)), dot = str.indexOf(".");
        return dot !== -1 && str[str.length - 1] === "0" && (node.minFractionDigits = str.length - dot - 1), node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/core/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber(), intIdentify = (value) => typeof value == "bigint" || Number.isInteger(value), intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      let { value } = node;
      return intIdentify(value) && value >= 0 ? prefix + value.toString(radix) : stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: !0,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    }, int = {
      identify: intIdentify,
      default: !0,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    }, intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: !0,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/core/schema.js"(exports2) {
    "use strict";
    var map = require_map(), _null = require_null(), seq = require_seq(), string = require_string2(), bool = require_bool(), float = require_float(), int = require_int(), schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports2.schema = schema;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/json/schema.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), map = require_map(), seq = require_seq();
    function intIdentify(value) {
      return typeof value == "bigint" || Number.isInteger(value);
    }
    var stringifyJSON = ({ value }) => JSON.stringify(value), jsonScalars = [
      {
        identify: (value) => typeof value == "string",
        default: !0,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: !0,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value == "boolean",
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value == "number",
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ], jsonError = {
      default: !0,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        return onError(`Unresolved plain scalar ${JSON.stringify(str)}`), str;
      }
    }, schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
    exports2.schema = schema;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), stringifyString = require_stringifyString(), binary = {
      identify: (value) => value instanceof Uint8Array,
      default: !1,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof Buffer == "function")
          return Buffer.from(src, "base64");
        if (typeof atob == "function") {
          let str = atob(src.replace(/[\n\r]/g, "")), buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else
          return onError("This environment does not support reading binary tags; either Buffer or atob is required"), src;
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        let buf = value, str;
        if (typeof Buffer == "function")
          str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        else if (typeof btoa == "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        if (type || (type = Scalar.Scalar.BLOCK_LITERAL), type !== Scalar.Scalar.QUOTE_DOUBLE) {
          let lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth), n = Math.ceil(str.length / lineWidth), lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth)
            lines[i] = str.substr(o, lineWidth);
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? `
` : " ");
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
    exports2.binary = binary;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports2) {
    "use strict";
    var identity = require_identity(), Pair = require_Pair(), Scalar = require_Scalar(), YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (identity.isSeq(seq))
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (!identity.isPair(item)) {
            if (identity.isMap(item)) {
              item.items.length > 1 && onError("Each pair must have its own sequence indicator");
              let pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
              if (item.commentBefore && (pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore), item.comment) {
                let cn = pair.value ?? pair.key;
                cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
              }
              item = pair;
            }
            seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
          }
        }
      else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      let { replacer } = ctx, pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          typeof replacer == "function" && (it = replacer.call(iterable, String(i++), it));
          let key, value;
          if (Array.isArray(it))
            if (it.length === 2)
              key = it[0], value = it[1];
            else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          else if (it && it instanceof Object) {
            let keys = Object.keys(it);
            if (keys.length === 1)
              key = keys[0], value = it[key];
            else
              throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
          } else
            key = it;
          pairs2.items.push(Pair.createPair(key, value, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: !1,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports2.createPairs = createPairs;
    exports2.pairs = pairs;
    exports2.resolvePairs = resolvePairs;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports2) {
    "use strict";
    var identity = require_identity(), toJS = require_toJS(), YAMLMap = require_YAMLMap(), YAMLSeq = require_YAMLSeq(), pairs = require_pairs(), YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super(), this.add = YAMLMap.YAMLMap.prototype.add.bind(this), this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this), this.get = YAMLMap.YAMLMap.prototype.get.bind(this), this.has = YAMLMap.YAMLMap.prototype.has.bind(this), this.set = YAMLMap.YAMLMap.prototype.set.bind(this), this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        let map = /* @__PURE__ */ new Map();
        ctx != null && ctx.onCreate && ctx.onCreate(map);
        for (let pair of this.items) {
          let key, value;
          if (identity.isPair(pair) ? (key = toJS.toJS(pair.key, "", ctx), value = toJS.toJS(pair.value, key, ctx)) : key = toJS.toJS(pair, "", ctx), map.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map.set(key, value);
        }
        return map;
      }
      static from(schema, iterable, ctx) {
        let pairs$1 = pairs.createPairs(schema, iterable, ctx), omap2 = new this();
        return omap2.items = pairs$1.items, omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: !1,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        let pairs$1 = pairs.resolvePairs(seq, onError), seenKeys = [];
        for (let { key } of pairs$1.items)
          identity.isScalar(key) && (seenKeys.includes(key.value) ? onError(`Ordered maps must not include duplicate keys: ${key.value}`) : seenKeys.push(key.value));
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports2.YAMLOMap = YAMLOMap;
    exports2.omap = omap;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value, source }, ctx) {
      return source && (value ? trueTag : falseTag).test.test(source) ? source : value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value) => value === !0,
      default: !0,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(!0),
      stringify: boolStringify
    }, falseTag = {
      identify: (value) => value === !1,
      default: !0,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => new Scalar.Scalar(!1),
      stringify: boolStringify
    };
    exports2.falseTag = falseTag;
    exports2.trueTag = trueTag;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), stringifyNumber = require_stringifyNumber(), floatNaN = {
      identify: (value) => typeof value == "number",
      default: !0,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    }, floatExp = {
      identify: (value) => typeof value == "number",
      default: !0,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        let num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    }, float = {
      identify: (value) => typeof value == "number",
      default: !0,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        let node = new Scalar.Scalar(parseFloat(str.replace(/_/g, ""))), dot = str.indexOf(".");
        if (dot !== -1) {
          let f = str.substring(dot + 1).replace(/_/g, "");
          f[f.length - 1] === "0" && (node.minFractionDigits = f.length);
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber(), intIdentify = (value) => typeof value == "bigint" || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      let sign = str[0];
      if ((sign === "-" || sign === "+") && (offset += 1), str = str.substring(offset).replace(/_/g, ""), intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        let n2 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      let n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      let { value } = node;
      if (intIdentify(value)) {
        let str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: !0,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    }, intOct = {
      identify: intIdentify,
      default: !0,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    }, int = {
      identify: intIdentify,
      default: !0,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    }, intHex = {
      identify: intIdentify,
      default: !0,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intBin = intBin;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports2) {
    "use strict";
    var identity = require_identity(), Pair = require_Pair(), YAMLMap = require_YAMLMap(), YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema), this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        identity.isPair(key) ? pair = key : key && typeof key == "object" && "key" in key && "value" in key && key.value === null ? pair = new Pair.Pair(key.key, null) : pair = new Pair.Pair(key, null), YAMLMap.findPair(this.items, pair.key) || this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        let pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value != "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        let prev = YAMLMap.findPair(this.items, key);
        prev && !value ? this.items.splice(this.items.indexOf(prev), 1) : !prev && value && this.items.push(new Pair.Pair(key));
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(!0))
          return super.toString(Object.assign({}, ctx, { allNullValues: !0 }), onComment, onChompKeep);
        throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        let { replacer } = ctx, set2 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable)
            typeof replacer == "function" && (value = replacer.call(iterable, value, value)), set2.items.push(Pair.createPair(value, null, ctx));
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: !1,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map, onError) {
        if (identity.isMap(map)) {
          if (map.hasAllNullValues(!0))
            return Object.assign(new YAMLSet(), map);
          onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map;
      }
    };
    exports2.YAMLSet = YAMLSet;
    exports2.set = set;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      let sign = str[0], parts = sign === "-" || sign === "+" ? str.substring(1) : str, num = (n) => asBigInt ? BigInt(n) : Number(n), res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value } = node, num = (n) => n;
      if (typeof value == "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
      let sign = "";
      value < 0 && (sign = "-", value *= num(-1));
      let _60 = num(60), parts = [value % _60];
      return value < 60 ? parts.unshift(0) : (value = (value - parts[0]) / _60, parts.unshift(value % _60), value >= 60 && (value = (value - parts[0]) / _60, parts.unshift(value))), sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value) => typeof value == "bigint" || Number.isInteger(value),
      default: !0,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    }, floatTime = {
      identify: (value) => typeof value == "number",
      default: !0,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, !1),
      stringify: stringifySexagesimal
    }, timestamp = {
      identify: (value) => value instanceof Date,
      default: !0,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        let match2 = str.match(timestamp.test);
        if (!match2)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        let [, year, month, day, hour, minute, second] = match2.map(Number), millisec = match2[7] ? Number((match2[7] + "00").substr(1, 3)) : 0, date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec), tz = match2[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, !1);
          Math.abs(d) < 30 && (d *= 60), date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    exports2.floatTime = floatTime;
    exports2.intTime = intTime;
    exports2.timestamp = timestamp;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports2) {
    "use strict";
    var map = require_map(), _null = require_null(), seq = require_seq(), string = require_string2(), binary = require_binary(), bool = require_bool2(), float = require_float2(), int = require_int2(), omap = require_omap(), pairs = require_pairs(), set = require_set(), timestamp = require_timestamp(), schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports2.schema = schema;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/tags.js"(exports2) {
    "use strict";
    var map = require_map(), _null = require_null(), seq = require_seq(), string = require_string2(), bool = require_bool(), float = require_float(), int = require_int(), schema = require_schema(), schema$1 = require_schema2(), binary = require_binary(), omap = require_omap(), pairs = require_pairs(), schema$2 = require_schema3(), set = require_set(), timestamp = require_timestamp(), schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map.map, seq.seq, string.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]), tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map.map,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    }, coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName) {
      let tags = schemas.get(schemaName);
      if (!tags)
        if (Array.isArray(customTags))
          tags = [];
        else {
          let keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
      if (Array.isArray(customTags))
        for (let tag of customTags)
          tags = tags.concat(tag);
      else
        typeof customTags == "function" && (tags = customTags(tags.slice()));
      return tags.map((tag) => {
        if (typeof tag != "string")
          return tag;
        let tagObj = tagsByName[tag];
        if (tagObj)
          return tagObj;
        let keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
      });
    }
    exports2.coreKnownTags = coreKnownTags;
    exports2.getTags = getTags;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/schema/Schema.js"(exports2) {
    "use strict";
    var identity = require_identity(), map = require_map(), seq = require_seq(), string = require_string2(), tags = require_tags(), sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0, Schema = class _Schema {
      constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null, this.merge = !!merge, this.name = typeof schema == "string" && schema || "core", this.knownTags = resolveKnownTags ? tags.coreKnownTags : {}, this.tags = tags.getTags(customTags, this.name), this.toStringOptions = toStringDefaults ?? null, Object.defineProperty(this, identity.MAP, { value: map.map }), Object.defineProperty(this, identity.SCALAR, { value: string.string }), Object.defineProperty(this, identity.SEQ, { value: seq.seq }), this.sortMapEntries = typeof sortMapEntries == "function" ? sortMapEntries : sortMapEntries === !0 ? sortMapEntriesByKey : null;
      }
      clone() {
        let copy2 = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        return copy2.tags = this.tags.slice(), copy2;
      }
    };
    exports2.Schema = Schema;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/stringify/stringifyDocument.js"(exports2) {
    "use strict";
    var identity = require_identity(), stringify = require_stringify2(), stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      var _a2;
      let lines = [], hasDirectives = options.directives === !0;
      if (options.directives !== !1 && doc.directives) {
        let dir = doc.directives.toString(doc);
        dir ? (lines.push(dir), hasDirectives = !0) : doc.directives.docStart && (hasDirectives = !0);
      }
      hasDirectives && lines.push("---");
      let ctx = stringify.createStringifyContext(doc, options), { commentString } = ctx.options;
      if (doc.commentBefore) {
        lines.length !== 1 && lines.unshift("");
        let cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = !1, contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives && lines.push(""), doc.contents.commentBefore) {
            let cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment, contentComment = doc.contents.comment;
        }
        let onChompKeep = contentComment ? void 0 : () => chompKeep = !0, body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        contentComment && (body += stringifyComment.lineComment(body, "", commentString(contentComment))), (body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---" ? lines[lines.length - 1] = `--- ${body}` : lines.push(body);
      } else
        lines.push(stringify.stringify(doc.contents, ctx));
      if ((_a2 = doc.directives) != null && _a2.docEnd)
        if (doc.comment) {
          let cs = commentString(doc.comment);
          cs.includes(`
`) ? (lines.push("..."), lines.push(stringifyComment.indentComment(cs, ""))) : lines.push(`... ${cs}`);
        } else
          lines.push("...");
      else {
        let dc = doc.comment;
        dc && chompKeep && (dc = dc.replace(/^\n+/, "")), dc && ((!chompKeep || contentComment) && lines[lines.length - 1] !== "" && lines.push(""), lines.push(stringifyComment.indentComment(commentString(dc), "")));
      }
      return lines.join(`
`) + `
`;
    }
    exports2.stringifyDocument = stringifyDocument;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/doc/Document.js"(exports2) {
    "use strict";
    var Alias = require_Alias(), Collection = require_Collection(), identity = require_identity(), Pair = require_Pair(), toJS = require_toJS(), Schema = require_Schema(), stringifyDocument = require_stringifyDocument(), anchors = require_anchors(), applyReviver = require_applyReviver(), createNode = require_createNode(), directives = require_directives(), Document = class _Document {
      constructor(value, replacer, options) {
        this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        typeof replacer == "function" || Array.isArray(replacer) ? _replacer = replacer : options === void 0 && replacer && (options = replacer, replacer = void 0);
        let opt = Object.assign({
          intAsBigInt: !1,
          keepSourceTokens: !1,
          logLevel: "warn",
          prettyErrors: !0,
          strict: !0,
          uniqueKeys: !0,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version: version2 } = opt;
        options != null && options._directives ? (this.directives = options._directives.atDocument(), this.directives.yaml.explicit && (version2 = this.directives.yaml.version)) : this.directives = new directives.Directives({ version: version2 }), this.setSchema(version2, options), this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        let copy2 = Object.create(_Document.prototype, {
          [identity.NODE_TYPE]: { value: identity.DOC }
        });
        return copy2.commentBefore = this.commentBefore, copy2.comment = this.comment, copy2.errors = this.errors.slice(), copy2.warnings = this.warnings.slice(), copy2.options = Object.assign({}, this.options), this.directives && (copy2.directives = this.directives.clone()), copy2.schema = this.schema.clone(), copy2.contents = identity.isNode(this.contents) ? this.contents.clone(copy2.schema) : this.contents, this.range && (copy2.range = this.range.slice()), copy2;
      }
      /** Adds a value to the document. */
      add(value) {
        assertCollection(this.contents) && this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path6, value) {
        assertCollection(this.contents) && this.contents.addIn(path6, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name) {
        if (!node.anchor) {
          let prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer;
        if (typeof replacer == "function")
          value = replacer.call({ "": value }, "", value), _replacer = replacer;
        else if (Array.isArray(replacer)) {
          let keyToStr = (v) => typeof v == "number" || v instanceof String || v instanceof Number, asStr = replacer.filter(keyToStr).map(String);
          asStr.length > 0 && (replacer = replacer.concat(asStr)), _replacer = replacer;
        } else
          options === void 0 && replacer && (options = replacer, replacer = void 0);
        let { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {}, { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        ), ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? !0,
          keepUndefined: keepUndefined ?? !1,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        }, node = createNode.createNode(value, tag, ctx);
        return flow && identity.isCollection(node) && (node.flow = !0), setAnchors(), node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        let k = this.createNode(key, null, options), v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : !1;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path6) {
        return Collection.isEmptyPath(path6) ? this.contents == null ? !1 : (this.contents = null, !0) : assertCollection(this.contents) ? this.contents.deleteIn(path6) : !1;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path6, keepScalar) {
        return Collection.isEmptyPath(path6) ? !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents : identity.isCollection(this.contents) ? this.contents.getIn(path6, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : !1;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path6) {
        return Collection.isEmptyPath(path6) ? this.contents !== void 0 : identity.isCollection(this.contents) ? this.contents.hasIn(path6) : !1;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        this.contents == null ? this.contents = Collection.collectionFromPath(this.schema, [key], value) : assertCollection(this.contents) && this.contents.set(key, value);
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path6, value) {
        Collection.isEmptyPath(path6) ? this.contents = value : this.contents == null ? this.contents = Collection.collectionFromPath(this.schema, Array.from(path6), value) : assertCollection(this.contents) && this.contents.setIn(path6, value);
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version2, options = {}) {
        typeof version2 == "number" && (version2 = String(version2));
        let opt;
        switch (version2) {
          case "1.1":
            this.directives ? this.directives.yaml.version = "1.1" : this.directives = new directives.Directives({ version: "1.1" }), opt = { merge: !0, resolveKnownTags: !1, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            this.directives ? this.directives.yaml.version = version2 : this.directives = new directives.Directives({ version: version2 }), opt = { merge: !1, resolveKnownTags: !0, schema: "core" };
            break;
          case null:
            this.directives && delete this.directives, opt = null;
            break;
          default: {
            let sv = JSON.stringify(version2);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error("With a null YAML version, the { schema: Schema } option is required");
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        let ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === !0,
          mapKeyWarned: !1,
          maxAliasCount: typeof maxAliasCount == "number" ? maxAliasCount : 100
        }, res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor == "function")
          for (let { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver == "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: !0, jsonArg, mapAsMap: !1, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          let s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity.isCollection(contents))
        return !0;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports2.Document = Document;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/errors.js
var require_errors = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/errors.js"(exports2) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name, pos, code, message) {
        super(), this.name = name, this.code = code, this.message = message, this.pos = pos;
      }
    }, YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    }, YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    }, prettifyError = (src, lc) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      let { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1, lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        let trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart), ci -= trimStart - 1;
      }
      if (lineStr.length > 80 && (lineStr = lineStr.substring(0, 79) + "\u2026"), line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        prev.length > 80 && (prev = prev.substring(0, 79) + `\u2026
`), lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1, end = error.linePos[1];
        end && end.line === line && end.col > col && (count = Math.max(1, Math.min(end.col - col, 80 - ci)));
        let pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports2.YAMLError = YAMLError;
    exports2.YAMLParseError = YAMLParseError;
    exports2.YAMLWarning = YAMLWarning;
    exports2.prettifyError = prettifyError;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/resolve-props.js"(exports2) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
      let spaceBefore = !1, atNewline = startOnNewline, hasSpace = startOnNewline, comment = "", commentSep = "", hasNewline = !1, hasNewlineAfterProp = !1, reqSpace = !1, anchor = null, tag = null, comma = null, found = null, start = null;
      for (let token of tokens)
        switch (reqSpace && (token.type !== "space" && token.type !== "newline" && token.type !== "comma" && onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), reqSpace = !1), token.type) {
          case "space":
            !flow && atNewline && indicator !== "doc-start" && token.source[0] === "	" && onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), hasSpace = !0;
            break;
          case "comment": {
            hasSpace || onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            let cb = token.source.substring(1) || " ";
            comment ? comment += commentSep + cb : comment = cb, commentSep = "", atNewline = !1;
            break;
          }
          case "newline":
            atNewline ? comment ? comment += token.source : spaceBefore = !0 : commentSep += token.source, atNewline = !0, hasNewline = !0, (anchor || tag) && (hasNewlineAfterProp = !0), hasSpace = !0;
            break;
          case "anchor":
            anchor && onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), token.source.endsWith(":") && onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), anchor = token, start === null && (start = token.offset), atNewline = !1, hasSpace = !1, reqSpace = !0;
            break;
          case "tag": {
            tag && onError(token, "MULTIPLE_TAGS", "A node can have at most one tag"), tag = token, start === null && (start = token.offset), atNewline = !1, hasSpace = !1, reqSpace = !0;
            break;
          }
          case indicator:
            (anchor || tag) && onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`), found && onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`), found = token, atNewline = !1, hasSpace = !1;
            break;
          case "comma":
            if (flow) {
              comma && onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`), comma = token, atNewline = !1, hasSpace = !1;
              break;
            }
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`), atNewline = !1, hasSpace = !1;
        }
      let last = tokens[tokens.length - 1], end = last ? last.offset + last.source.length : offset;
      return reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "") && onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        hasNewlineAfterProp,
        anchor,
        tag,
        end,
        start: start ?? end
      };
    }
    exports2.resolveProps = resolveProps;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/util-contains-newline.js"(exports2) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes(`
`))
            return !0;
          if (key.end) {
            for (let st of key.end)
              if (st.type === "newline")
                return !0;
          }
          return !1;
        case "flow-collection":
          for (let it of key.items) {
            for (let st of it.start)
              if (st.type === "newline")
                return !0;
            if (it.sep) {
              for (let st of it.sep)
                if (st.type === "newline")
                  return !0;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return !0;
          }
          return !1;
        default:
          return !0;
      }
    }
    exports2.containsNewline = containsNewline;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports2) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent, fc, onError) {
      if ((fc == null ? void 0 : fc.type) === "flow-collection") {
        let end = fc.end[0];
        end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc) && onError(end, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
      }
    }
    exports2.flowIndentCheck = flowIndentCheck;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/util-map-includes.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function mapIncludes(ctx, items, search) {
      let { uniqueKeys } = ctx.options;
      if (uniqueKeys === !1)
        return !1;
      let isEqual = typeof uniqueKeys == "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports2.mapIncludes = mapIncludes;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/resolve-block-map.js"(exports2) {
    "use strict";
    var Pair = require_Pair(), YAMLMap = require_YAMLMap(), resolveProps = require_resolve_props(), utilContainsNewline = require_util_contains_newline(), utilFlowIndentCheck = require_util_flow_indent_check(), utilMapIncludes = require_util_map_includes(), startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
      var _a2;
      let NodeClass = (tag == null ? void 0 : tag.nodeClass) ?? YAMLMap.YAMLMap, map = new NodeClass(ctx.schema);
      ctx.atRoot && (ctx.atRoot = !1);
      let offset = bm.offset, commentEnd = null;
      for (let collItem of bm.items) {
        let { start, key, sep: sep2, value } = collItem, keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? (sep2 == null ? void 0 : sep2[0]),
          offset,
          onError,
          startOnNewline: !0
        }), implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key && (key.type === "block-seq" ? onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in key && key.indent !== bm.indent && onError(offset, "BAD_INDENT", startColMsg)), !keyProps.anchor && !keyProps.tag && !sep2) {
            commentEnd = keyProps.end, keyProps.comment && (map.comment ? map.comment += `
` + keyProps.comment : map.comment = keyProps.comment);
            continue;
          }
          (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) && onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        } else
          ((_a2 = keyProps.found) == null ? void 0 : _a2.indent) !== bm.indent && onError(offset, "BAD_INDENT", startColMsg);
        let keyStart = keyProps.end, keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError), utilMapIncludes.mapIncludes(ctx, map.items, keyNode) && onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        let valueProps = resolveProps.resolveProps(sep2 ?? [], {
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          startOnNewline: !key || key.type === "block-scalar"
        });
        if (offset = valueProps.end, valueProps.found) {
          implicitKey && ((value == null ? void 0 : value.type) === "block-map" && !valueProps.hasNewline && onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), ctx.options.strict && keyProps.start < valueProps.found.offset - 1024 && onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
          let valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep2, null, valueProps, onError);
          ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError), offset = valueNode.range[2];
          let pair = new Pair.Pair(keyNode, valueNode);
          ctx.options.keepSourceTokens && (pair.srcToken = collItem), map.items.push(pair);
        } else {
          implicitKey && onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), valueProps.comment && (keyNode.comment ? keyNode.comment += `
` + valueProps.comment : keyNode.comment = valueProps.comment);
          let pair = new Pair.Pair(keyNode);
          ctx.options.keepSourceTokens && (pair.srcToken = collItem), map.items.push(pair);
        }
      }
      return commentEnd && commentEnd < offset && onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content"), map.range = [bm.offset, offset, commentEnd ?? offset], map;
    }
    exports2.resolveBlockMap = resolveBlockMap;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/resolve-block-seq.js"(exports2) {
    "use strict";
    var YAMLSeq = require_YAMLSeq(), resolveProps = require_resolve_props(), utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
      let NodeClass = (tag == null ? void 0 : tag.nodeClass) ?? YAMLSeq.YAMLSeq, seq = new NodeClass(ctx.schema);
      ctx.atRoot && (ctx.atRoot = !1);
      let offset = bs.offset, commentEnd = null;
      for (let { start, value } of bs.items) {
        let props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value,
          offset,
          onError,
          startOnNewline: !0
        });
        if (!props.found)
          if (props.anchor || props.tag || value)
            value && value.type === "block-seq" ? onError(props.end, "BAD_INDENT", "All sequence items must start at the same column") : onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          else {
            commentEnd = props.end, props.comment && (seq.comment = props.comment);
            continue;
          }
        let node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError), offset = node.range[2], seq.items.push(node);
      }
      return seq.range = [bs.offset, offset, commentEnd ?? offset], seq;
    }
    exports2.resolveBlockSeq = resolveBlockSeq;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/resolve-end.js"(exports2) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment = "";
      if (end) {
        let hasSpace = !1, sep2 = "";
        for (let token of end) {
          let { source, type } = token;
          switch (type) {
            case "space":
              hasSpace = !0;
              break;
            case "comment": {
              reqSpace && !hasSpace && onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              let cb = source.substring(1) || " ";
              comment ? comment += sep2 + cb : comment = cb, sep2 = "";
              break;
            }
            case "newline":
              comment && (sep2 += source), hasSpace = !0;
              break;
            default:
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }
    exports2.resolveEnd = resolveEnd;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports2) {
    "use strict";
    var identity = require_identity(), Pair = require_Pair(), YAMLMap = require_YAMLMap(), YAMLSeq = require_YAMLSeq(), resolveEnd = require_resolve_end(), resolveProps = require_resolve_props(), utilContainsNewline = require_util_contains_newline(), utilMapIncludes = require_util_map_includes(), blockMsg = "Block collections are not allowed within flow collections", isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
      let isMap = fc.start.source === "{", fcName = isMap ? "flow map" : "flow sequence", NodeClass = (tag == null ? void 0 : tag.nodeClass) ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq), coll = new NodeClass(ctx.schema);
      coll.flow = !0;
      let atRoot = ctx.atRoot;
      atRoot && (ctx.atRoot = !1);
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        let collItem = fc.items[i], { start, key, sep: sep2, value } = collItem, props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? (sep2 == null ? void 0 : sep2[0]),
          offset,
          onError,
          startOnNewline: !1
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep2 && !value) {
            i === 0 && props.comma ? onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`) : i < fc.items.length - 1 && onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`), props.comment && (coll.comment ? coll.comment += `
` + props.comment : coll.comment = props.comment), offset = props.end;
            continue;
          }
          !isMap && ctx.options.strict && utilContainsNewline.containsNewline(key) && onError(
            key,
            // checked by containsNewline()
            "MULTILINE_IMPLICIT_KEY",
            "Implicit keys of flow sequence pairs need to be on a single line"
          );
        }
        if (i === 0)
          props.comma && onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (props.comma || onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`), props.comment) {
          let prevItemComment = "";
          loop:
            for (let st of start)
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            identity.isPair(prev) && (prev = prev.value ?? prev.key), prev.comment ? prev.comment += `
` + prevItemComment : prev.comment = prevItemComment, props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
        if (!isMap && !sep2 && !props.found) {
          let valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep2, null, props, onError);
          coll.items.push(valueNode), offset = valueNode.range[2], isBlock(value) && onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          let keyStart = props.end, keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          isBlock(key) && onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          let valueProps = resolveProps.resolveProps(sep2 ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            startOnNewline: !1
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep2)
                for (let st of sep2) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              props.start < valueProps.found.offset - 1024 && onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else
            value && ("source" in value && value.source && value.source[0] === ":" ? onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`) : onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`));
          let valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep2, null, valueProps, onError) : null;
          valueNode ? isBlock(value) && onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg) : valueProps.comment && (keyNode.comment ? keyNode.comment += `
` + valueProps.comment : keyNode.comment = valueProps.comment);
          let pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens && (pair.srcToken = collItem), isMap) {
            let map = coll;
            utilMapIncludes.mapIncludes(ctx, map.items, keyNode) && onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique"), map.items.push(pair);
          } else {
            let map = new YAMLMap.YAMLMap(ctx.schema);
            map.flow = !0, map.items.push(pair), coll.items.push(map);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      let expectedEnd = isMap ? "}" : "]", [ce, ...ee] = fc.end, cePos = offset;
      if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        let name = fcName[0].toUpperCase() + fcName.substring(1), msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg), ce && ce.source.length !== 1 && ee.unshift(ce);
      }
      if (ee.length > 0) {
        let end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        end.comment && (coll.comment ? coll.comment += `
` + end.comment : coll.comment = end.comment), coll.range = [fc.offset, cePos, end.offset];
      } else
        coll.range = [fc.offset, cePos, cePos];
      return coll;
    }
    exports2.resolveFlowCollection = resolveFlowCollection;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/compose-collection.js"(exports2) {
    "use strict";
    var identity = require_identity(), Scalar = require_Scalar(), YAMLMap = require_YAMLMap(), YAMLSeq = require_YAMLSeq(), resolveBlockMap = require_resolve_block_map(), resolveBlockSeq = require_resolve_block_seq(), resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
      let coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag), Coll = coll.constructor;
      return tagName === "!" || tagName === Coll.tagName ? (coll.tag = Coll.tagName, coll) : (tagName && (coll.tag = tagName), coll);
    }
    function composeCollection(CN, ctx, token, tagToken, onError) {
      var _a2;
      let tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null, expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq" || !expType)
        return resolveCollection(CN, ctx, token, onError, tagName);
      let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
      if (!tag) {
        let kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType)
          ctx.schema.tags.push(Object.assign({}, kt, { default: !1 })), tag = kt;
        else
          return kt != null && kt.collection ? onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, !0) : onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, !0), resolveCollection(CN, ctx, token, onError, tagName);
      }
      let coll = resolveCollection(CN, ctx, token, onError, tagName, tag), res = ((_a2 = tag.resolve) == null ? void 0 : _a2.call(tag, coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options)) ?? coll, node = identity.isNode(res) ? res : new Scalar.Scalar(res);
      return node.range = coll.range, node.tag = tagName, tag != null && tag.format && (node.format = tag.format), node;
    }
    exports2.composeCollection = composeCollection;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(scalar, strict, onError) {
      let start = scalar.offset, header = parseBlockScalarHeader(scalar, strict, onError);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      let type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL, lines = scalar.source ? splitLines(scalar.source) : [], chompStart = lines.length;
      for (let i = lines.length - 1; i >= 0; --i) {
        let content = lines[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        let value2 = header.chomp === "+" && lines.length > 0 ? `
`.repeat(Math.max(1, lines.length - 1)) : "", end2 = start + header.length;
        return scalar.source && (end2 += scalar.source.length), { value: value2, type, comment: header.comment, range: [start, end2, end2] };
      }
      let trimIndent = scalar.indent + header.indent, offset = scalar.offset + header.length, contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        if (content === "" || content === "\r")
          header.indent === 0 && indent.length > trimIndent && (trimIndent = indent.length);
        else {
          indent.length < trimIndent && onError(offset + indent.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), header.indent === 0 && (trimIndent = indent.length), contentStart = i;
          break;
        }
        offset += indent.length + content.length + 1;
      }
      for (let i = lines.length - 1; i >= chompStart; --i)
        lines[i][0].length > trimIndent && (chompStart = i + 1);
      let value = "", sep2 = "", prevMoreIndented = !1;
      for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + `
`;
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        let crlf = content[content.length - 1] === "\r";
        if (crlf && (content = content.slice(0, -1)), content && indent.length < trimIndent) {
          let message = `Block scalar lines must not be less indented than their ${header.indent ? "explicit indentation indicator" : "first line"}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message), indent = "";
        }
        type === Scalar.Scalar.BLOCK_LITERAL ? (value += sep2 + indent.slice(trimIndent) + content, sep2 = `
`) : indent.length > trimIndent || content[0] === "	" ? (sep2 === " " ? sep2 = `
` : !prevMoreIndented && sep2 === `
` && (sep2 = `

`), value += sep2 + indent.slice(trimIndent) + content, sep2 = `
`, prevMoreIndented = !0) : content === "" ? sep2 === `
` ? value += `
` : sep2 = `
` : (value += sep2 + content, sep2 = " ", prevMoreIndented = !1);
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines.length; ++i)
            value += `
` + lines[i][0].slice(trimIndent);
          value[value.length - 1] !== `
` && (value += `
`);
          break;
        default:
          value += `
`;
      }
      let end = start + header.length + scalar.source.length;
      return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      if (props[0].type !== "block-scalar-header")
        return onError(props[0], "IMPOSSIBLE", "Block scalar header not found"), null;
      let { source } = props[0], mode = source[0], indent = 0, chomp = "", error = -1;
      for (let i = 1; i < source.length; ++i) {
        let ch = source[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          let n = Number(ch);
          !indent && n ? indent = n : error === -1 && (error = offset + i);
        }
      }
      error !== -1 && onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
      let hasSpace = !1, comment = "", length = source.length;
      for (let i = 1; i < props.length; ++i) {
        let token = props[i];
        switch (token.type) {
          case "space":
            hasSpace = !0;
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            strict && !hasSpace && onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), length += token.source.length, comment = token.source.substring(1);
            break;
          case "error":
            onError(token, "UNEXPECTED_TOKEN", token.message), length += token.source.length;
            break;
          default: {
            let message = `Unexpected token in block scalar header: ${token.type}`;
            onError(token, "UNEXPECTED_TOKEN", message);
            let ts = token.source;
            ts && typeof ts == "string" && (length += ts.length);
          }
        }
      }
      return { mode, indent, chomp, comment, length };
    }
    function splitLines(source) {
      let split = source.split(/\n( *)/), first = split[0], m = first.match(/^( *)/), lines = [m != null && m[1] ? [m[1], first.slice(m[1].length)] : ["", first]];
      for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
      return lines;
    }
    exports2.resolveBlockScalar = resolveBlockScalar;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar(), resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      let { offset, type, source, end } = scalar, _type, value, _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN, value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE, value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE, value = doubleQuotedValue(source, _onError);
          break;
        default:
          return onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`), {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source.length, offset + source.length]
          };
      }
      let valueEnd = offset + source.length, re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source, onError) {
      let badChar = "";
      switch (source[0]) {
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      return badChar && onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`), foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      return (source[source.length - 1] !== "'" || source.length === 1) && onError(source.length, "MISSING_CHAR", "Missing closing 'quote"), foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      let first, line;
      try {
        first = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), line = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
      } catch {
        first = /(.*?)[ \t]*\r?\n/sy, line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match2 = first.exec(source);
      if (!match2)
        return source;
      let res = match2[1], sep2 = " ", pos = first.lastIndex;
      for (line.lastIndex = pos; match2 = line.exec(source); )
        match2[1] === "" ? sep2 === `
` ? res += sep2 : sep2 = `
` : (res += sep2 + match2[1], sep2 = " "), pos = line.lastIndex;
      let last = /[ \t]*(.*)/sy;
      return last.lastIndex = pos, match2 = last.exec(source), res + sep2 + ((match2 == null ? void 0 : match2[1]) ?? "");
    }
    function doubleQuotedValue(source, onError) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
        let ch = source[i];
        if (!(ch === "\r" && source[i + 1] === `
`))
          if (ch === `
`) {
            let { fold, offset } = foldNewline(source, i);
            res += fold, i = offset;
          } else if (ch === "\\") {
            let next = source[++i], cc = escapeCodes[next];
            if (cc)
              res += cc;
            else if (next === `
`)
              for (next = source[i + 1]; next === " " || next === "	"; )
                next = source[++i + 1];
            else if (next === "\r" && source[i + 1] === `
`)
              for (next = source[++i + 1]; next === " " || next === "	"; )
                next = source[++i + 1];
            else if (next === "x" || next === "u" || next === "U") {
              let length = { x: 2, u: 4, U: 8 }[next];
              res += parseCharCode(source, i + 1, length, onError), i += length;
            } else {
              let raw = source.substr(i - 1, 2);
              onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`), res += raw;
            }
          } else if (ch === " " || ch === "	") {
            let wsStart = i, next = source[i + 1];
            for (; next === " " || next === "	"; )
              next = source[++i + 1];
            next !== `
` && !(next === "\r" && source[i + 2] === `
`) && (res += i > wsStart ? source.slice(wsStart, i + 1) : ch);
          } else
            res += ch;
      }
      return (source[source.length - 1] !== '"' || source.length === 1) && onError(source.length, "MISSING_CHAR", 'Missing closing "quote'), res;
    }
    function foldNewline(source, offset) {
      let fold = "", ch = source[offset + 1];
      for (; (ch === " " || ch === "	" || ch === `
` || ch === "\r") && !(ch === "\r" && source[offset + 2] !== `
`); )
        ch === `
` && (fold += `
`), offset += 1, ch = source[offset + 1];
      return fold || (fold = " "), { fold, offset };
    }
    var escapeCodes = {
      0: "\0",
      a: "\x07",
      b: "\b",
      e: "\x1B",
      f: "\f",
      n: `
`,
      r: "\r",
      t: "	",
      v: "\v",
      N: "\x85",
      _: "\xA0",
      L: "\u2028",
      P: "\u2029",
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError) {
      let cc = source.substr(offset, length), code = cc.length === length && /^[0-9a-fA-F]+$/.test(cc) ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        let raw = source.substr(offset - 2, length + 2);
        return onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`), raw;
      }
      return String.fromCodePoint(code);
    }
    exports2.resolveFlowScalar = resolveFlowScalar;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/compose-scalar.js"(exports2) {
    "use strict";
    var identity = require_identity(), Scalar = require_Scalar(), resolveBlockScalar = require_resolve_block_scalar(), resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError) {
      let { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError), tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null, tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[identity.SCALAR], scalar;
      try {
        let res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        let msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), scalar = new Scalar.Scalar(value);
      }
      return scalar.range = range, scalar.source = value, type && (scalar.type = type), tagName && (scalar.tag = tagName), tag.format && (scalar.format = tag.format), comment && (scalar.comment = comment), scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
      var _a2;
      if (tagName === "!")
        return schema[identity.SCALAR];
      let matchWithTest = [];
      for (let tag of schema.tags)
        if (!tag.collection && tag.tag === tagName)
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
      for (let tag of matchWithTest)
        if ((_a2 = tag.test) != null && _a2.test(value))
          return tag;
      let kt = schema.knownTags[tagName];
      return kt && !kt.collection ? (schema.tags.push(Object.assign({}, kt, { default: !1, test: void 0 })), kt) : (onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str"), schema[identity.SCALAR]);
    }
    function findScalarTagByTest({ directives, schema }, value, token, onError) {
      let tag = schema.tags.find((tag2) => {
        var _a2;
        return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
      }) || schema[identity.SCALAR];
      if (schema.compat) {
        let compat = schema.compat.find((tag2) => {
          var _a2;
          return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
        }) ?? schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          let ts = directives.tagString(tag.tag), cs = directives.tagString(compat.tag), msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token, "TAG_RESOLVE_FAILED", msg, !0);
        }
      }
      return tag;
    }
    exports2.composeScalar = composeScalar;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports2) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        pos === null && (pos = before.length);
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          for (st = before[++i]; (st == null ? void 0 : st.type) === "space"; )
            offset += st.source.length, st = before[++i];
          break;
        }
      }
      return offset;
    }
    exports2.emptyScalarPosition = emptyScalarPosition;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/compose-node.js"(exports2) {
    "use strict";
    var Alias = require_Alias(), composeCollection = require_compose_collection(), composeScalar = require_compose_scalar(), resolveEnd = require_resolve_end(), utilEmptyScalarPosition = require_util_empty_scalar_position(), CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError) {
      let { spaceBefore, comment, anchor, tag } = props, node, isSrcToken = !0;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError), (anchor || tag) && onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError), anchor && (node.anchor = anchor.source.substring(1));
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, tag, onError), anchor && (node.anchor = anchor.source.substring(1));
          break;
        default: {
          let message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
          onError(token, "UNEXPECTED_TOKEN", message), node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError), isSrcToken = !1;
        }
      }
      return anchor && node.anchor === "" && onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string"), spaceBefore && (node.spaceBefore = !0), comment && (token.type === "scalar" && token.source === "" ? node.comment = comment : node.commentBefore = comment), ctx.options.keepSourceTokens && isSrcToken && (node.srcToken = token), node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
      let token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      }, node = composeScalar.composeScalar(ctx, token, tag, onError);
      return anchor && (node.anchor = anchor.source.substring(1), node.anchor === "" && onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string")), spaceBefore && (node.spaceBefore = !0), comment && (node.comment = comment, node.range[2] = end), node;
    }
    function composeAlias({ options }, { offset, source, end }, onError) {
      let alias = new Alias.Alias(source.substring(1));
      alias.source === "" && onError(offset, "BAD_ALIAS", "Alias cannot be an empty string"), alias.source.endsWith(":") && onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
      let valueEnd = offset + source.length, re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      return alias.range = [offset, valueEnd, re.offset], re.comment && (alias.comment = re.comment), alias;
    }
    exports2.composeEmptyNode = composeEmptyNode;
    exports2.composeNode = composeNode;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/compose-doc.js"(exports2) {
    "use strict";
    var Document = require_Document(), composeNode = require_compose_node(), resolveEnd = require_resolve_end(), resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value, end }, onError) {
      let opts = Object.assign({ _directives: directives }, options), doc = new Document.Document(void 0, opts), ctx = {
        atRoot: !0,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      }, props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? (end == null ? void 0 : end[0]),
        offset,
        onError,
        startOnNewline: !0
      });
      props.found && (doc.directives.docStart = !0, value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline && onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      let contentEnd = doc.contents.range[2], re = resolveEnd.resolveEnd(end, contentEnd, !1, onError);
      return re.comment && (doc.comment = re.comment), doc.range = [offset, contentEnd, re.offset], doc;
    }
    exports2.composeDoc = composeDoc;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/compose/composer.js"(exports2) {
    "use strict";
    var directives = require_directives(), Document = require_Document(), errors = require_errors(), identity = require_identity(), composeDoc = require_compose_doc(), resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src == "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      let { offset, source } = src;
      return [offset, offset + (typeof source == "string" ? source.length : 1)];
    }
    function parsePrelude(prelude) {
      var _a2;
      let comment = "", atComment = !1, afterEmptyLine = !1;
      for (let i = 0; i < prelude.length; ++i) {
        let source = prelude[i];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? `

` : `
`) + (source.substring(1) || " "), atComment = !0, afterEmptyLine = !1;
            break;
          case "%":
            ((_a2 = prelude[i + 1]) == null ? void 0 : _a2[0]) !== "#" && (i += 1), atComment = !1;
            break;
          default:
            atComment || (afterEmptyLine = !0), atComment = !1;
        }
      }
      return { comment, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (source, code, message, warning) => {
          let pos = getErrorPos(source);
          warning ? this.warnings.push(new errors.YAMLWarning(pos, code, message)) : this.errors.push(new errors.YAMLParseError(pos, code, message));
        }, this.directives = new directives.Directives({ version: options.version || "1.2" }), this.options = options;
      }
      decorate(doc, afterDoc) {
        let { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          let dc = doc.contents;
          if (afterDoc)
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          else if (afterEmptyLine || doc.directives.docStart || !dc)
            doc.commentBefore = comment;
          else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            identity.isPair(it) && (it = it.key);
            let cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            let cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        afterDoc ? (Array.prototype.push.apply(doc.errors, this.errors), Array.prototype.push.apply(doc.warnings, this.warnings)) : (doc.errors = this.errors, doc.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = !1, endOffset = -1) {
        for (let token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        switch (process.env.LOG_STREAM && console.dir(token, { depth: null }), token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              let pos = getErrorPos(token);
              pos[0] += offset, this.onError(pos, "BAD_DIRECTIVE", message, warning);
            }), this.prelude.push(token.source), this.atDirectives = !0;
            break;
          case "document": {
            let doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            this.atDirectives && !doc.directives.docStart && this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(doc, !1), this.doc && (yield this.doc), this.doc = doc, this.atDirectives = !1;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            let msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message, error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            this.atDirectives || !this.doc ? this.errors.push(error) : this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              let msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = !0;
            let end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            if (this.decorate(this.doc, !0), end.comment) {
              let dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = !1, endOffset = -1) {
        if (this.doc)
          this.decorate(this.doc, !0), yield this.doc, this.doc = null;
        else if (forceDoc) {
          let opts = Object.assign({ _directives: this.directives }, this.options), doc = new Document.Document(void 0, opts);
          this.atDirectives && this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line"), doc.range = [0, endOffset, endOffset], this.decorate(doc, !1), yield doc;
        }
      }
    };
    exports2.Composer = Composer;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/parse/cst-scalar.js"(exports2) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar(), resolveFlowScalar = require_resolve_flow_scalar(), errors = require_errors(), stringifyString = require_stringifyString();
    function resolveAsScalar(token, strict = !0, onError) {
      if (token) {
        let _onError = (pos, code, message) => {
          let offset = typeof pos == "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError)
            onError(offset, code, message);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value, context) {
      let { implicitKey = !1, indent, inFlow = !1, offset = -1, type = "PLAIN" } = context, source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: !0, lineWidth: -1 }
      }), end = context.end ?? [
        { type: "newline", offset: -1, indent, source: `
` }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          let he = source.indexOf(`
`), head = source.substring(0, he), body = source.substring(he + 1) + `
`, props = [
            { type: "block-scalar-header", offset, indent, source: head }
          ];
          return addEndtoBlockProps(props, end) || props.push({ type: "newline", offset: -1, indent, source: `
` }), { type: "block-scalar", offset, indent, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent, source, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent, source, end };
        default:
          return { type: "scalar", offset, indent, source, end };
      }
    }
    function setScalarValue(token, value, context = {}) {
      let { afterKey = !1, implicitKey = !1, inFlow = !1, type } = context, indent = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent == "number" && (indent += 2), !type)
        switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            let header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      let source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: !0, lineWidth: -1 }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      let he = source.indexOf(`
`), head = source.substring(0, he), body = source.substring(he + 1) + `
`;
      if (token.type === "block-scalar") {
        let header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head, token.source = body;
      } else {
        let { offset } = token, indent = "indent" in token ? token.indent : -1, props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        addEndtoBlockProps(props, "end" in token ? token.end : void 0) || props.push({ type: "newline", offset: -1, indent, source: `
` });
        for (let key of Object.keys(token))
          key !== "type" && key !== "offset" && delete token[key];
        Object.assign(token, { type: "block-scalar", indent, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end)
        for (let st of end)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              return props.push(st), !0;
          }
      return !1;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type, token.source = source;
          break;
        case "block-scalar": {
          let end = token.props.slice(1), oa = source.length;
          token.props[0].type === "block-scalar-header" && (oa -= token.props[0].source.length);
          for (let tok of end)
            tok.offset += oa;
          delete token.props, Object.assign(token, { type, source, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          let nl = { type: "newline", offset: token.offset + source.length, indent: token.indent, source: `
` };
          delete token.items, Object.assign(token, { type, source, end: [nl] });
          break;
        }
        default: {
          let indent = "indent" in token ? token.indent : -1, end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (let key of Object.keys(token))
            key !== "type" && key !== "offset" && delete token[key];
          Object.assign(token, { type, indent, source, end });
        }
      }
    }
    exports2.createScalarToken = createScalarToken;
    exports2.resolveAsScalar = resolveAsScalar;
    exports2.setScalarValue = setScalarValue;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/parse/cst-stringify.js"(exports2) {
    "use strict";
    var stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (let tok of token.props)
            res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (let item of token.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (let item of token.items)
            res += stringifyItem(item);
          for (let st of token.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end)
            for (let st of token.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end)
            for (let st of token.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep: sep2, value }) {
      let res = "";
      for (let st of start)
        res += st.source;
      if (key && (res += stringifyToken(key)), sep2)
        for (let st of sep2)
          res += st.source;
      return value && (res += stringifyToken(value)), res;
    }
    exports2.stringify = stringify;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/parse/cst-visit.js"(exports2) {
    "use strict";
    var BREAK = Symbol("break visit"), SKIP = Symbol("skip children"), REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      "type" in cst && cst.type === "document" && (cst = { start: cst.start, value: cst.value }), _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path6) => {
      let item = cst;
      for (let [field, index] of path6) {
        let tok = item == null ? void 0 : item[field];
        if (tok && "items" in tok)
          item = tok.items[index];
        else
          return;
      }
      return item;
    };
    visit.parentCollection = (cst, path6) => {
      let parent = visit.itemAtPath(cst, path6.slice(0, -1)), field = path6[path6.length - 1][0], coll = parent == null ? void 0 : parent[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path6, item, visitor) {
      let ctrl = visitor(item, path6);
      if (typeof ctrl == "symbol")
        return ctrl;
      for (let field of ["key", "value"]) {
        let token = item[field];
        if (token && "items" in token) {
          for (let i = 0; i < token.items.length; ++i) {
            let ci = _visit(Object.freeze(path6.concat([[field, i]])), token.items[i], visitor);
            if (typeof ci == "number")
              i = ci - 1;
            else {
              if (ci === BREAK)
                return BREAK;
              ci === REMOVE && (token.items.splice(i, 1), i -= 1);
            }
          }
          typeof ctrl == "function" && field === "key" && (ctrl = ctrl(item, path6));
        }
      }
      return typeof ctrl == "function" ? ctrl(item, path6) : ctrl;
    }
    exports2.visit = visit;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/parse/cst.js"(exports2) {
    "use strict";
    var cstScalar = require_cst_scalar(), cstStringify = require_cst_stringify(), cstVisit = require_cst_visit(), BOM = "\uFEFF", DOCUMENT = "", FLOW_END = "", SCALAR = "", isCollection = (token) => !!token && "items" in token, isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case `
`:
        case `\r
`:
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports2.createScalarToken = cstScalar.createScalarToken;
    exports2.resolveAsScalar = cstScalar.resolveAsScalar;
    exports2.setScalarValue = cstScalar.setScalarValue;
    exports2.stringify = cstStringify.stringify;
    exports2.visit = cstVisit.visit;
    exports2.BOM = BOM;
    exports2.DOCUMENT = DOCUMENT;
    exports2.FLOW_END = FLOW_END;
    exports2.SCALAR = SCALAR;
    exports2.isCollection = isCollection;
    exports2.isScalar = isScalar;
    exports2.prettyToken = prettyToken;
    exports2.tokenType = tokenType;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/parse/lexer.js"(exports2) {
    "use strict";
    var cst = require_cst();
    function isEmpty(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case `
`:
        case "\r":
        case "	":
          return !0;
        default:
          return !1;
      }
    }
    var hexDigits = "0123456789ABCDEFabcdef".split(""), tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split(""), invalidFlowScalarChars = ",[]{}".split(""), invalidAnchorChars = ` ,[]{}
\r	`.split(""), isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch), Lexer = class {
      constructor() {
        this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = !1) {
        source && (this.buffer = this.buffer ? this.buffer + source : source, this.lineEndPos = null), this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        for (; next && (incomplete || this.hasChars(1)); )
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos, ch = this.buffer[i];
        for (; ch === " " || ch === "	"; )
          ch = this.buffer[++i];
        return !ch || ch === "#" || ch === `
` ? !0 : ch === "\r" ? this.buffer[i + 1] === `
` : !1;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          for (; ch === " "; )
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            let next = this.buffer[indent + offset + 1];
            if (next === `
` || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === `
` || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          let dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        return (typeof end != "number" || end !== -1 && end < this.pos) && (end = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = end), end === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[end - 1] === "\r" && (end -= 1), this.buffer.substring(this.pos, end));
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = state, null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === cst.BOM && (yield* this.pushCount(1), line = line.substring(1)), line[0] === "%") {
          let dirEnd = line.length, cs = line.indexOf("#");
          if (cs !== -1) {
            let ch = line[cs - 1];
            (ch === " " || ch === "	") && (dirEnd = cs - 1);
          }
          for (; ; ) {
            let ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          let n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(!0));
          return yield* this.pushCount(line.length - n), this.pushNewline(), "stream";
        }
        if (this.atLineEnd()) {
          let sp = yield* this.pushSpaces(!0);
          return yield* this.pushCount(line.length - sp), yield* this.pushNewline(), "stream";
        }
        return yield cst.DOCUMENT, yield* this.parseLineStart();
      }
      *parseLineStart() {
        let ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          let s = this.peek(3);
          if (s === "---" && isEmpty(this.charAt(3)))
            return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, "doc";
          if (s === "..." && isEmpty(this.charAt(3)))
            return yield* this.pushCount(3), "stream";
        }
        return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !isEmpty(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        let [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          let n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
          return this.indentNext = this.indentValue + 1, this.indentValue += n, yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(!0);
        let line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          case void 0:
            return yield* this.pushNewline(), yield* this.parseLineStart();
          case "{":
          case "[":
            return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";
          case "}":
          case "]":
            return yield* this.pushCount(1), "doc";
          case "*":
            return yield* this.pushUntil(isNotAnchorChar), "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            return n += yield* this.parseBlockScalarHeader(), n += yield* this.pushSpaces(!0), yield* this.pushCount(line.length - n), yield* this.pushNewline(), yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp, indent = -1;
        do
          nl = yield* this.pushNewline(), nl > 0 ? (sp = yield* this.pushSpaces(!1), this.indentValue = indent = sp) : sp = 0, sp += yield* this.pushSpaces(!0);
        while (nl + sp > 0);
        let line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if ((indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) && !(indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}")))
          return this.flowLevel = 0, yield cst.FLOW_END, yield* this.parseLineStart();
        let n = 0;
        for (; line[n] === ","; )
          n += yield* this.pushCount(1), n += yield* this.pushSpaces(!0), this.flowKey = !1;
        switch (n += yield* this.pushIndicators(), line[n]) {
          case void 0:
            return "flow";
          case "#":
            return yield* this.pushCount(line.length - n), "flow";
          case "{":
          case "[":
            return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";
          case "}":
          case "]":
            return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
          case "*":
            return yield* this.pushUntil(isNotAnchorChar), "flow";
          case '"':
          case "'":
            return this.flowKey = !0, yield* this.parseQuotedScalar();
          case ":": {
            let next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",")
              return this.flowKey = !1, yield* this.pushCount(1), yield* this.pushSpaces(!0), "flow";
          }
          default:
            return this.flowKey = !1, yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        let quote2 = this.charAt(0), end = this.buffer.indexOf(quote2, this.pos + 1);
        if (quote2 === "'")
          for (; end !== -1 && this.buffer[end + 1] === "'"; )
            end = this.buffer.indexOf("'", end + 2);
        else
          for (; end !== -1; ) {
            let n = 0;
            for (; this.buffer[end - 1 - n] === "\\"; )
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        let qb = this.buffer.substring(0, end), nl = qb.indexOf(`
`, this.pos);
        if (nl !== -1) {
          for (; nl !== -1; ) {
            let cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf(`
`, cs);
          }
          nl !== -1 && (end = nl - (qb[nl - 1] === "\r" ? 2 : 1));
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        return yield* this.pushToIndex(end + 1, !1), this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1, this.blockScalarKeep = !1;
        let i = this.pos;
        for (; ; ) {
          let ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = !0;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1, indent = 0, ch;
        loop:
          for (let i = this.pos; ch = this.buffer[i]; ++i)
            switch (ch) {
              case " ":
                indent += 1;
                break;
              case `
`:
                nl = i, indent = 0;
                break;
              case "\r": {
                let next = this.buffer[i + 1];
                if (!next && !this.atEnd)
                  return this.setNext("block-scalar");
                if (next === `
`)
                  break;
              }
              default:
                break loop;
            }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          this.blockScalarIndent === -1 ? this.indentNext = indent : this.indentNext += this.blockScalarIndent;
          do {
            let cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf(`
`, cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        if (!this.blockScalarKeep)
          do {
            let i = nl - 1, ch2 = this.buffer[i];
            ch2 === "\r" && (ch2 = this.buffer[--i]);
            let lastChar = i;
            for (; ch2 === " " || ch2 === "	"; )
              ch2 = this.buffer[--i];
            if (ch2 === `
` && i >= this.pos && i + 1 + indent > lastChar)
              nl = i;
            else
              break;
          } while (!0);
        return yield cst.SCALAR, yield* this.pushToIndex(nl + 1, !0), yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        let inFlow = this.flowLevel > 0, end = this.pos - 1, i = this.pos - 1, ch;
        for (; ch = this.buffer[++i]; )
          if (ch === ":") {
            let next = this.buffer[i + 1];
            if (isEmpty(next) || inFlow && next === ",")
              break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r" && (next === `
` ? (i += 1, ch = `
`, next = this.buffer[i + 1]) : end = i), next === "#" || inFlow && invalidFlowScalarChars.includes(next))
              break;
            if (ch === `
`) {
              let cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && invalidFlowScalarChars.includes(ch))
              break;
            end = i;
          }
        return !ch && !this.atEnd ? this.setNext("plain-scalar") : (yield cst.SCALAR, yield* this.pushToIndex(end + 1, !0), inFlow ? "flow" : "doc");
      }
      *pushCount(n) {
        return n > 0 ? (yield this.buffer.substr(this.pos, n), this.pos += n, n) : 0;
      }
      *pushToIndex(i, allowEmpty) {
        let s = this.buffer.slice(this.pos, i);
        return s ? (yield s, this.pos += s.length, s.length) : (allowEmpty && (yield ""), 0);
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
          case "-":
          case "?":
          case ":": {
            let inFlow = this.flowLevel > 0, ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1))
              return inFlow ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2, ch = this.buffer[i];
          for (; !isEmpty(ch) && ch !== ">"; )
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, !1);
        } else {
          let i = this.pos + 1, ch = this.buffer[i];
          for (; ch; )
            if (tagChars.includes(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2]))
              ch = this.buffer[i += 3];
            else
              break;
          return yield* this.pushToIndex(i, !1);
        }
      }
      *pushNewline() {
        let ch = this.buffer[this.pos];
        return ch === `
` ? yield* this.pushCount(1) : ch === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1, ch;
        do
          ch = this.buffer[++i];
        while (ch === " " || allowTabs && ch === "	");
        let n = i - this.pos;
        return n > 0 && (yield this.buffer.substr(this.pos, n), this.pos = i), n;
      }
      *pushUntil(test) {
        let i = this.pos, ch = this.buffer[i];
        for (; !test(ch); )
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, !1);
      }
    };
    exports2.Lexer = Lexer;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/parse/line-counter.js"(exports2) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [], this.addNewLine = (offset) => this.lineStarts.push(offset), this.linePos = (offset) => {
          let low = 0, high = this.lineStarts.length;
          for (; low < high; ) {
            let mid = low + high >> 1;
            this.lineStarts[mid] < offset ? low = mid + 1 : high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          let start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports2.LineCounter = LineCounter;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/parse/parser.js"(exports2) {
    "use strict";
    var cst = require_cst(), lexer = require_lexer();
    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
          return !0;
      return !1;
    }
    function findNonEmptyIndex(list) {
      for (let i = 0; i < list.length; ++i)
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      return -1;
    }
    function isFlowToken(token) {
      switch (token == null ? void 0 : token.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return !0;
        default:
          return !1;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          let it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      var _a2;
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop:
        for (; --i >= 0; )
          switch (prev[i].type) {
            case "doc-start":
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
            case "newline":
              break loop;
          }
      for (; ((_a2 = prev[++i]) == null ? void 0 : _a2.type) === "space"; )
        ;
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start")
        for (let it of fc.items)
          it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind") && (it.key && (it.value = it.key), delete it.key, isFlowToken(it.value) ? it.value.end ? Array.prototype.push.apply(it.value.end, it.sep) : it.value.end = it.sep : Array.prototype.push.apply(it.start, it.sep), delete it.sep);
    }
    var Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, this.stack = [], this.source = "", this.type = "", this.lexer = new lexer.Lexer(), this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = !1) {
        this.onNewLine && this.offset === 0 && this.onNewLine(0);
        for (let lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        incomplete || (yield* this.end());
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        if (this.source = source, process.env.LOG_TOKENS && console.log("|", cst.prettyToken(source)), this.atScalar) {
          this.atScalar = !1, yield* this.step(), this.offset += source.length;
          return;
        }
        let type = cst.tokenType(source);
        if (type)
          if (type === "scalar")
            this.atNewLine = !1, this.atScalar = !0, this.type = "scalar";
          else {
            switch (this.type = type, yield* this.step(), type) {
              case "newline":
                this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + source.length);
                break;
              case "space":
                this.atNewLine && source[0] === " " && (this.indent += source.length);
                break;
              case "explicit-key-ind":
              case "map-value-ind":
              case "seq-item-ind":
                this.atNewLine && (this.indent += source.length);
                break;
              case "doc-mode":
              case "flow-error-end":
                return;
              default:
                this.atNewLine = !1;
            }
            this.offset += source.length;
          }
        else {
          let message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source }), this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        for (; this.stack.length > 0; )
          yield* this.pop();
      }
      get sourceToken() {
        return {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      *step() {
        let top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          for (; this.stack.length > 0; )
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error) {
        let token = error ?? this.stack.pop();
        if (!token)
          yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
        else if (this.stack.length === 0)
          yield token;
        else {
          let top = this.peek(1);
          switch (token.type === "block-scalar" ? token.indent = "indent" in top ? top.indent : 0 : token.type === "flow-collection" && top.type === "document" && (token.indent = 0), token.type === "flow-collection" && fixFlowSeqItems(token), top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              let it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] }), this.onKeyLine = !0;
                return;
              } else if (it.sep)
                it.value = token;
              else {
                Object.assign(it, { key: token, sep: [] }), this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
                return;
              }
              break;
            }
            case "block-seq": {
              let it = top.items[top.items.length - 1];
              it.value ? top.items.push({ start: [], value: token }) : it.value = token;
              break;
            }
            case "flow-collection": {
              let it = top.items[top.items.length - 1];
              !it || it.value ? top.items.push({ start: [], key: token, sep: [] }) : it.sep ? it.value = token : Object.assign(it, { key: token, sep: [] });
              return;
            }
            default:
              yield* this.pop(), yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            let last = token.items[token.items.length - 1];
            last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent)) && (top.type === "document" ? top.end = last.start : top.items.push({ start: last.start }), token.items.splice(-1, 1));
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            let doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            this.type === "doc-start" && doc.start.push(this.sourceToken), this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            findNonEmptyIndex(doc.start) !== -1 ? (yield* this.pop(), yield* this.step()) : doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        let bv = this.startBlockValue(doc);
        bv ? this.stack.push(bv) : yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          let prev = getPrevProps(this.peek(2)), start = getFirstKeyStartProps(prev), sep2;
          scalar.end ? (sep2 = scalar.end, sep2.push(this.sourceToken), delete scalar.end) : sep2 = [this.sourceToken];
          let map = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep: sep2 }]
          };
          this.onKeyLine = !0, this.stack[this.stack.length - 1] = map;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            if (scalar.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
              let nl = this.source.indexOf(`
`) + 1;
              for (; nl !== 0; )
                this.onNewLine(this.offset + nl), nl = this.source.indexOf(`
`, nl) + 1;
            }
            yield* this.pop();
            break;
          default:
            yield* this.pop(), yield* this.step();
        }
      }
      *blockMap(map) {
        var _a2;
        let it = map.items[map.items.length - 1];
        switch (this.type) {
          case "newline":
            if (this.onKeyLine = !1, it.value) {
              let end = "end" in it.value ? it.value.end : void 0, last = Array.isArray(end) ? end[end.length - 1] : void 0;
              (last == null ? void 0 : last.type) === "comment" ? end == null || end.push(this.sourceToken) : map.items.push({ start: [this.sourceToken] });
            } else
              it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              map.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else {
              if (this.atIndentedComment(it.start, map.indent)) {
                let prev = map.items[map.items.length - 2], end = (_a2 = prev == null ? void 0 : prev.value) == null ? void 0 : _a2.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start), end.push(this.sourceToken), map.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map.indent) {
          let atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep, start = [];
          if (atNextItem && it.sep && !it.value) {
            let nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              let st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  st.indent > map.indent && (nl.length = 0);
                  break;
                default:
                  nl.length = 0;
              }
            }
            nl.length >= 2 && (start = it.sep.splice(nl[1]));
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              atNextItem || it.value ? (start.push(this.sourceToken), map.items.push({ start }), this.onKeyLine = !0) : it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken);
              return;
            case "explicit-key-ind":
              !it.sep && !includesToken(it.start, "explicit-key-ind") ? it.start.push(this.sourceToken) : atNextItem || it.value ? (start.push(this.sourceToken), map.items.push({ start })) : this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken] }]
              }), this.onKeyLine = !0;
              return;
            case "map-value-ind":
              if (includesToken(it.start, "explicit-key-ind"))
                if (it.sep)
                  if (it.value)
                    map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                  else if (includesToken(it.sep, "map-value-ind"))
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start, key: null, sep: [this.sourceToken] }]
                    });
                  else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                    let start2 = getFirstKeyStartProps(it.start), key = it.key, sep2 = it.sep;
                    sep2.push(this.sourceToken), delete it.key, delete it.sep, this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key, sep: sep2 }]
                    });
                  } else
                    start.length > 0 ? it.sep = it.sep.concat(start, this.sourceToken) : it.sep.push(this.sourceToken);
                else if (includesToken(it.start, "newline"))
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                else {
                  let start2 = getFirstKeyStartProps(it.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                  });
                }
              else
                it.sep ? it.value || atNextItem ? map.items.push({ start, key: null, sep: [this.sourceToken] }) : includesToken(it.sep, "map-value-ind") ? this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                }) : it.sep.push(this.sourceToken) : Object.assign(it, { key: null, sep: [this.sourceToken] });
              this.onKeyLine = !0;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              let fs7 = this.flowScalar(this.type);
              atNextItem || it.value ? (map.items.push({ start, key: fs7, sep: [] }), this.onKeyLine = !0) : it.sep ? this.stack.push(fs7) : (Object.assign(it, { key: fs7, sep: [] }), this.onKeyLine = !0);
              return;
            }
            default: {
              let bv = this.startBlockValue(map);
              if (bv) {
                atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind") && map.items.push({ start }), this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop(), yield* this.step();
      }
      *blockSequence(seq) {
        var _a2;
        let it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              let end = "end" in it.value ? it.value.end : void 0, last = Array.isArray(end) ? end[end.length - 1] : void 0;
              (last == null ? void 0 : last.type) === "comment" ? end == null || end.push(this.sourceToken) : seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                let prev = seq.items[seq.items.length - 2], end = (_a2 = prev == null ? void 0 : prev.value) == null ? void 0 : _a2.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start), end.push(this.sourceToken), seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            it.value || includesToken(it.start, "seq-item-ind") ? seq.items.push({ start: [this.sourceToken] }) : it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          let bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop(), yield* this.step();
      }
      *flowCollection(fc) {
        let it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do
            yield* this.pop(), top = this.peek(1);
          while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              !it || it.sep ? fc.items.push({ start: [this.sourceToken] }) : it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              !it || it.value ? fc.items.push({ start: [], key: null, sep: [this.sourceToken] }) : it.sep ? it.sep.push(this.sourceToken) : Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              !it || it.value ? fc.items.push({ start: [this.sourceToken] }) : it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              let fs7 = this.flowScalar(this.type);
              !it || it.value ? fc.items.push({ start: [], key: fs7, sep: [] }) : it.sep ? this.stack.push(fs7) : Object.assign(it, { key: fs7, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          let bv = this.startBlockValue(fc);
          bv ? this.stack.push(bv) : (yield* this.pop(), yield* this.step());
        } else {
          let parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep))
            yield* this.pop(), yield* this.step();
          else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            let prev = getPrevProps(parent), start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            let sep2 = fc.end.splice(1, fc.end.length);
            sep2.push(this.sourceToken);
            let map = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep: sep2 }]
            };
            this.onKeyLine = !0, this.stack[this.stack.length - 1] = map;
          } else
            yield* this.lineEnd(fc);
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf(`
`) + 1;
          for (; nl !== 0; )
            this.onNewLine(this.offset + nl), nl = this.source.indexOf(`
`, nl) + 1;
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = !0;
            let prev = getPrevProps(parent), start = getFirstKeyStartProps(prev);
            return start.push(this.sourceToken), {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = !0;
            let prev = getPrevProps(parent), start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        return this.type !== "comment" || this.indent <= indent ? !1 : start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        this.type !== "doc-mode" && (docEnd.end ? docEnd.end.push(this.sourceToken) : docEnd.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop(), yield* this.step();
            break;
          case "newline":
            this.onKeyLine = !1;
          case "space":
          case "comment":
          default:
            token.end ? token.end.push(this.sourceToken) : token.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
        }
      }
    };
    exports2.Parser = Parser;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/public-api.js"(exports2) {
    "use strict";
    var composer = require_composer(), Document = require_Document(), errors = require_errors(), log2 = require_log(), lineCounter = require_line_counter(), parser = require_parser();
    function parseOptions(options) {
      let prettyErrors = options.prettyErrors !== !1;
      return { lineCounter: options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null, prettyErrors };
    }
    function parseAllDocuments(source, options = {}) {
      let { lineCounter: lineCounter2, prettyErrors } = parseOptions(options), parser$1 = new parser.Parser(lineCounter2 == null ? void 0 : lineCounter2.addNewLine), composer$1 = new composer.Composer(options), docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter2)
        for (let doc of docs)
          doc.errors.forEach(errors.prettifyError(source, lineCounter2)), doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      return docs.length > 0 ? docs : Object.assign([], { empty: !0 }, composer$1.streamInfo());
    }
    function parseDocument(source, options = {}) {
      let { lineCounter: lineCounter2, prettyErrors } = parseOptions(options), parser$1 = new parser.Parser(lineCounter2 == null ? void 0 : lineCounter2.addNewLine), composer$1 = new composer.Composer(options), doc = null;
      for (let _doc of composer$1.compose(parser$1.parse(source), !0, source.length))
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      return prettyErrors && lineCounter2 && (doc.errors.forEach(errors.prettifyError(source, lineCounter2)), doc.warnings.forEach(errors.prettifyError(source, lineCounter2))), doc;
    }
    function parse6(src, reviver, options) {
      let _reviver;
      typeof reviver == "function" ? _reviver = reviver : options === void 0 && reviver && typeof reviver == "object" && (options = reviver);
      let doc = parseDocument(src, options);
      if (!doc)
        return null;
      if (doc.warnings.forEach((warning) => log2.warn(doc.options.logLevel, warning)), doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify(value, replacer, options) {
      let _replacer = null;
      if (typeof replacer == "function" || Array.isArray(replacer) ? _replacer = replacer : options === void 0 && replacer && (options = replacer), typeof options == "string" && (options = options.length), typeof options == "number") {
        let indent = Math.round(options);
        options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
      }
      if (value === void 0) {
        let { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return;
      }
      return new Document.Document(value, _replacer, options).toString(options);
    }
    exports2.parse = parse6;
    exports2.parseAllDocuments = parseAllDocuments;
    exports2.parseDocument = parseDocument;
    exports2.stringify = stringify;
  }
});

// ../../node_modules/zx/node_modules/yaml/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/zx/node_modules/yaml/dist/index.js"(exports2) {
    "use strict";
    var composer = require_composer(), Document = require_Document(), Schema = require_Schema(), errors = require_errors(), Alias = require_Alias(), identity = require_identity(), Pair = require_Pair(), Scalar = require_Scalar(), YAMLMap = require_YAMLMap(), YAMLSeq = require_YAMLSeq(), cst = require_cst(), lexer = require_lexer(), lineCounter = require_line_counter(), parser = require_parser(), publicApi = require_public_api(), visit = require_visit();
    exports2.Composer = composer.Composer;
    exports2.Document = Document.Document;
    exports2.Schema = Schema.Schema;
    exports2.YAMLError = errors.YAMLError;
    exports2.YAMLParseError = errors.YAMLParseError;
    exports2.YAMLWarning = errors.YAMLWarning;
    exports2.Alias = Alias.Alias;
    exports2.isAlias = identity.isAlias;
    exports2.isCollection = identity.isCollection;
    exports2.isDocument = identity.isDocument;
    exports2.isMap = identity.isMap;
    exports2.isNode = identity.isNode;
    exports2.isPair = identity.isPair;
    exports2.isScalar = identity.isScalar;
    exports2.isSeq = identity.isSeq;
    exports2.Pair = Pair.Pair;
    exports2.Scalar = Scalar.Scalar;
    exports2.YAMLMap = YAMLMap.YAMLMap;
    exports2.YAMLSeq = YAMLSeq.YAMLSeq;
    exports2.CST = cst;
    exports2.Lexer = lexer.Lexer;
    exports2.LineCounter = lineCounter.LineCounter;
    exports2.Parser = parser.Parser;
    exports2.parse = publicApi.parse;
    exports2.parseAllDocuments = publicApi.parseAllDocuments;
    exports2.parseDocument = publicApi.parseDocument;
    exports2.stringify = publicApi.stringify;
    exports2.visit = visit.visit;
    exports2.visitAsync = visit.visitAsync;
  }
});

// ../../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      a instanceof RegExp && (a = maybeMatch(a, str)), b instanceof RegExp && (b = maybeMatch(b, str));
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result, ai = str.indexOf(a), bi = str.indexOf(b, ai + 1), i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b)
          return [ai, bi];
        for (begs = [], left = str.length; i >= 0 && !result; )
          i == ai ? (begs.push(i), ai = str.indexOf(a, i + 1)) : begs.length == 1 ? result = [begs.pop(), bi] : (beg = begs.pop(), beg < left && (left = beg, right = bi), bi = str.indexOf(b, i + 1)), i = ai < bi && ai >= 0 ? ai : bi;
        begs.length && (result = [left, right]);
      }
      return result;
    }
  }
});

// ../../node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../node_modules/brace-expansion/index.js"(exports2, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0", escOpen = "\0OPEN" + Math.random() + "\0", escClose = "\0CLOSE" + Math.random() + "\0", escComma = "\0COMMA" + Math.random() + "\0", escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [], m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre, body = m.body, post = m.post, p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      return post.length && (p[p.length - 1] += postParts.shift(), p.push.apply(p, postParts)), parts.push.apply(parts, p), parts;
    }
    function expandTop(str) {
      return str ? (str.substr(0, 2) === "{}" && (str = "\\{\\}" + str.substr(2)), expand2(escapeBraces(str), !0).map(unescapeBraces)) : [];
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str, isTop) {
      var expansions = [], m = balanced("{", "}", str);
      if (!m)
        return [str];
      var pre = m.pre, post = m.post.length ? expand2(m.post, !1) : [""];
      if (/\$$/.test(m.pre))
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body), isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body), isSequence = isNumericSequence || isAlphaSequence, isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions)
          return m.post.match(/,.*\}/) ? (str = m.pre + "{" + m.body + escClose + m.post, expand2(str)) : [str];
        var n;
        if (isSequence)
          n = m.body.split(/\.\./);
        else if (n = parseCommaParts(m.body), n.length === 1 && (n = expand2(n[0], !1).map(embrace), n.length === 1))
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        var N;
        if (isSequence) {
          var x = numeric(n[0]), y = numeric(n[1]), width = Math.max(n[0].length, n[1].length), incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1, test = lte, reverse = y < x;
          reverse && (incr *= -1, test = gte);
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence)
              c = String.fromCharCode(i), c === "\\" && (c = "");
            else if (c = String(i), pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                i < 0 ? c = "-" + z + c.slice(1) : c = z + c;
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++)
            N.push.apply(N, expand2(n[j], !1));
        }
        for (var j = 0; j < N.length; j++)
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            (!isTop || isSequence || expansion) && expansions.push(expansion);
          }
      }
      return expansions;
    }
  }
});

// ../../node_modules/builtins/builtins.json
var require_builtins = __commonJS({
  "../../node_modules/builtins/builtins.json"(exports2, module2) {
    module2.exports = [
      "assert",
      "buffer",
      "child_process",
      "cluster",
      "console",
      "constants",
      "crypto",
      "dgram",
      "dns",
      "domain",
      "events",
      "fs",
      "http",
      "https",
      "module",
      "net",
      "os",
      "path",
      "process",
      "punycode",
      "querystring",
      "readline",
      "repl",
      "stream",
      "string_decoder",
      "timers",
      "tls",
      "tty",
      "url",
      "util",
      "v8",
      "vm",
      "zlib"
    ];
  }
});

// ../../node_modules/validate-npm-package-name/index.js
var require_validate_npm_package_name = __commonJS({
  "../../node_modules/validate-npm-package-name/index.js"(exports2, module2) {
    "use strict";
    var scopedPackagePattern = new RegExp("^(?:@([^/]+?)[/])?([^/]+?)$"), builtins = require_builtins(), blacklist = [
      "node_modules",
      "favicon.ico"
    ], validate = module2.exports = function(name) {
      var warnings = [], errors = [];
      if (name === null)
        return errors.push("name cannot be null"), done(warnings, errors);
      if (name === void 0)
        return errors.push("name cannot be undefined"), done(warnings, errors);
      if (typeof name != "string")
        return errors.push("name must be a string"), done(warnings, errors);
      if (name.length || errors.push("name length must be greater than zero"), name.match(/^\./) && errors.push("name cannot start with a period"), name.match(/^_/) && errors.push("name cannot start with an underscore"), name.trim() !== name && errors.push("name cannot contain leading or trailing spaces"), blacklist.forEach(function(blacklistedName) {
        name.toLowerCase() === blacklistedName && errors.push(blacklistedName + " is a blacklisted name");
      }), builtins.forEach(function(builtin) {
        name.toLowerCase() === builtin && warnings.push(builtin + " is a core module name");
      }), name.length > 214 && warnings.push("name can no longer contain more than 214 characters"), name.toLowerCase() !== name && warnings.push("name can no longer contain capital letters"), /[~'!()*]/.test(name.split("/").slice(-1)[0]) && warnings.push(`name can no longer contain special characters ("~'!()*")`), encodeURIComponent(name) !== name) {
        var nameMatch = name.match(scopedPackagePattern);
        if (nameMatch) {
          var user = nameMatch[1], pkg = nameMatch[2];
          if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg)
            return done(warnings, errors);
        }
        errors.push("name can only contain URL-friendly characters");
      }
      return done(warnings, errors);
    };
    validate.scopedPackagePattern = scopedPackagePattern;
    var done = function(warnings, errors) {
      var result = {
        validForNewPackages: errors.length === 0 && warnings.length === 0,
        validForOldPackages: errors.length === 0,
        warnings,
        errors
      };
      return result.warnings.length || delete result.warnings, result.errors.length || delete result.errors, result;
    };
  }
});

// ../../node_modules/@expo/package-manager/build/PackageManager.js
var require_PackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/PackageManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/which/which.js
var require_which2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/which/which.js"(exports2, module2) {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", path6 = require("path"), COLON = isWindows ? ";" : ":", isexe = require_isexe(), getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" }), getPathInfo = (cmd, opt) => {
      let colon = opt.colon || COLON, pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ], pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", pathExt = isWindows ? pathExtExe.split(colon) : [""];
      return isWindows && cmd.indexOf(".") !== -1 && pathExt[0] !== "" && pathExt.unshift(""), {
        pathEnv,
        pathExt,
        pathExtExe
      };
    }, which2 = (cmd, opt, cb) => {
      typeof opt == "function" && (cb = opt, opt = {}), opt || (opt = {});
      let { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [], step = (i) => new Promise((resolve7, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve7(found) : reject(getNotFoundError(cmd));
        let ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path6.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve7(subStep(p, i, 0));
      }), subStep = (p, i, ii) => new Promise((resolve7, reject) => {
        if (ii === pathExt.length)
          return resolve7(step(i + 1));
        let ext2 = pathExt[ii];
        isexe(p + ext2, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is)
            if (opt.all)
              found.push(p + ext2);
            else
              return resolve7(p + ext2);
          return resolve7(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    }, whichSync = (cmd, opt) => {
      opt = opt || {};
      let { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        let ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path6.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          let cur = p + pathExt[j];
          try {
            if (isexe.sync(cur, { pathExt: pathExtExe }))
              if (opt.all)
                found.push(cur);
              else
                return cur;
          } catch {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/path-key/index.js
var require_path_key3 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/path-key/index.js"(exports2, module2) {
    "use strict";
    var pathKey = (options = {}) => {
      let environment = options.env || process.env;
      return (options.platform || process.platform) !== "win32" ? "PATH" : Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey;
    module2.exports.default = pathKey;
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), which2 = require_which2(), getPathKey = require_path_key3();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      let env2 = parsed.options.env || process.env, cwd2 = process.cwd(), hasCustomCwd = parsed.options.cwd != null, shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd)
        try {
          process.chdir(parsed.options.cwd);
        } catch {
        }
      let resolved;
      try {
        resolved = which2.sync(parsed.command, {
          path: env2[getPathKey({ env: env2 })],
          pathExt: withoutPathExt ? path6.delimiter : void 0
        });
      } catch {
      } finally {
        shouldSwitchCwd && process.chdir(cwd2);
      }
      return resolved && (resolved = path6.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved)), resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, !0);
    }
    module2.exports = resolveCommand;
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/util/escape.js
var require_escape2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      return arg = arg.replace(metaCharsRegExp, "^$1"), arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      return arg = `${arg}`, arg = arg.replace(/(\\*)"/g, '$1$1\\"'), arg = arg.replace(/(\\*)$/, "$1$1"), arg = `"${arg}"`, arg = arg.replace(metaCharsRegExp, "^$1"), doubleEscapeMetaChars && (arg = arg.replace(metaCharsRegExp, "^$1")), arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/shebang-regex/index.js
var require_shebang_regex2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/shebang-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /^#!(.*)/;
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/shebang-command/index.js
var require_shebang_command2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/shebang-command/index.js"(exports2, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex2();
    module2.exports = (string = "") => {
      let match2 = string.match(shebangRegex);
      if (!match2)
        return null;
      let [path6, argument] = match2[0].replace(/#! ?/, "").split(" "), binary = path6.split("/").pop();
      return binary === "env" ? argument : argument ? `${binary} ${argument}` : binary;
    };
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
    "use strict";
    var fs7 = require("fs"), shebangCommand = require_shebang_command2();
    function readShebang(command) {
      let buffer = Buffer.alloc(150), fd;
      try {
        fd = fs7.openSync(command, "r"), fs7.readSync(fd, buffer, 0, 150, 0), fs7.closeSync(fd);
      } catch {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/parse.js
var require_parse4 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), resolveCommand = require_resolveCommand2(), escape2 = require_escape2(), readShebang = require_readShebang2(), isWin = process.platform === "win32", isExecutableRegExp = /\.(?:com|exe)$/i, isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      let shebang = parsed.file && readShebang(parsed.file);
      return shebang ? (parsed.args.unshift(parsed.file), parsed.command = shebang, resolveCommand(parsed)) : parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin)
        return parsed;
      let commandFile = detectShebang(parsed), needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        let needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path6.normalize(parsed.command), parsed.command = escape2.command(parsed.command), parsed.args = parsed.args.map((arg) => escape2.argument(arg, needsDoubleEscapeMetaChars));
        let shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`], parsed.command = process.env.comspec || "cmd.exe", parsed.options.windowsVerbatimArguments = !0;
      }
      return parsed;
    }
    function parse6(command, args, options) {
      args && !Array.isArray(args) && (options = args, args = null), args = args ? args.slice(0) : [], options = Object.assign({}, options);
      let parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse6;
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/enoent.js
var require_enoent2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin)
        return;
      let originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          let err = verifyENOENT(arg1, parsed, "spawn");
          if (err)
            return originalEmit.call(cp, "error", err);
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawn") : null;
    }
    function verifyENOENTSync(status, parsed) {
      return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawnSync") : null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// ../../node_modules/@expo/spawn-async/node_modules/cross-spawn/index.js
var require_cross_spawn2 = __commonJS({
  "../../node_modules/@expo/spawn-async/node_modules/cross-spawn/index.js"(exports2, module2) {
    "use strict";
    var cp = require("child_process"), parse6 = require_parse4(), enoent = require_enoent2();
    function spawn2(command, args, options) {
      let parsed = parse6(command, args, options), spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      return enoent.hookChildProcess(spawned, parsed), spawned;
    }
    function spawnSync(command, args, options) {
      let parsed = parse6(command, args, options), result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      return result.error = result.error || enoent.verifyENOENTSync(result.status, parsed), result;
    }
    module2.exports = spawn2;
    module2.exports.spawn = spawn2;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse6;
    module2.exports._enoent = enoent;
  }
});

// ../../node_modules/@expo/spawn-async/build/spawnAsync.js
var require_spawnAsync = __commonJS({
  "../../node_modules/@expo/spawn-async/build/spawnAsync.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    }, cross_spawn_1 = __importDefault(require_cross_spawn2());
    function spawnAsync(command, args, options = {}) {
      let stubError = new Error(), callerStack = stubError.stack ? stubError.stack.replace(/^.*/, "    ...") : null, child, promise = new Promise((resolve7, reject) => {
        let { ignoreStdio, ...nodeOptions } = options;
        child = (0, cross_spawn_1.default)(command, args, nodeOptions);
        let stdout = "", stderr = "";
        ignoreStdio || (child.stdout && child.stdout.on("data", (data) => {
          stdout += data;
        }), child.stderr && child.stderr.on("data", (data) => {
          stderr += data;
        }));
        let completionListener = (code, signal) => {
          child.removeListener("error", errorListener);
          let result = {
            pid: child.pid,
            output: [stdout, stderr],
            stdout,
            stderr,
            status: code,
            signal
          };
          if (code !== 0) {
            let argumentString = args && args.length > 0 ? ` ${args.join(" ")}` : "", error = signal ? new Error(`${command}${argumentString} exited with signal: ${signal}`) : new Error(`${command}${argumentString} exited with non-zero code: ${code}`);
            error.stack && callerStack && (error.stack += `
${callerStack}`), Object.assign(error, result), reject(error);
          } else
            resolve7(result);
        }, errorListener = (error) => {
          ignoreStdio ? child.removeListener("exit", completionListener) : child.removeListener("close", completionListener), Object.assign(error, {
            pid: child.pid,
            output: [stdout, stderr],
            stdout,
            stderr,
            status: null,
            signal: null
          }), reject(error);
        };
        ignoreStdio ? child.once("exit", completionListener) : child.once("close", completionListener), child.once("error", errorListener);
      });
      return promise.child = child, promise;
    }
    module2.exports = spawnAsync;
  }
});

// ../../node_modules/sudo-prompt/index.js
var require_sudo_prompt = __commonJS({
  "../../node_modules/sudo-prompt/index.js"(exports2, module2) {
    var Node = {
      child: require("child_process"),
      crypto: require("crypto"),
      fs: require("fs"),
      os: require("os"),
      path: require("path"),
      process,
      util: require("util")
    };
    function Attempt(instance, end) {
      var platform = Node.process.platform;
      if (platform === "darwin")
        return Mac(instance, end);
      if (platform === "linux")
        return Linux(instance, end);
      if (platform === "win32")
        return Windows(instance, end);
      end(new Error("Platform not yet supported."));
    }
    function EscapeDoubleQuotes(string) {
      if (typeof string != "string")
        throw new Error("Expected a string.");
      return string.replace(/"/g, '\\"');
    }
    function Exec() {
      if (arguments.length < 1 || arguments.length > 3)
        throw new Error("Wrong number of arguments.");
      var command = arguments[0], options = {}, end = function() {
      };
      if (typeof command != "string")
        throw new Error("Command should be a string.");
      if (arguments.length === 2)
        if (Node.util.isObject(arguments[1]))
          options = arguments[1];
        else if (Node.util.isFunction(arguments[1]))
          end = arguments[1];
        else
          throw new Error("Expected options or callback.");
      else if (arguments.length === 3) {
        if (Node.util.isObject(arguments[1]))
          options = arguments[1];
        else
          throw new Error("Expected options to be an object.");
        if (Node.util.isFunction(arguments[2]))
          end = arguments[2];
        else
          throw new Error("Expected callback to be a function.");
      }
      if (/^sudo/i.test(command))
        return end(new Error('Command should not be prefixed with "sudo".'));
      if (typeof options.name > "u") {
        var title = Node.process.title;
        if (ValidName(title))
          options.name = title;
        else
          return end(new Error("process.title cannot be used as a valid name."));
      } else if (!ValidName(options.name)) {
        var error = "";
        return error += "options.name must be alphanumeric only ", error += "(spaces are allowed) and <= 70 characters.", end(new Error(error));
      }
      if (typeof options.icns < "u") {
        if (typeof options.icns != "string")
          return end(new Error("options.icns must be a string if provided."));
        if (options.icns.trim().length === 0)
          return end(new Error("options.icns must not be empty if provided."));
      }
      if (typeof options.env < "u") {
        if (typeof options.env != "object")
          return end(new Error("options.env must be an object if provided."));
        if (Object.keys(options.env).length === 0)
          return end(new Error("options.env must not be empty if provided."));
        for (var key in options.env) {
          var value = options.env[key];
          if (typeof key != "string" || typeof value != "string")
            return end(
              new Error("options.env environment variables must be strings.")
            );
          if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key))
            return end(
              new Error(
                "options.env has an invalid environment variable name: " + JSON.stringify(key)
              )
            );
          if (/[\r\n]/.test(value))
            return end(
              new Error(
                "options.env has an invalid environment variable value: " + JSON.stringify(value)
              )
            );
        }
      }
      var platform = Node.process.platform;
      if (platform !== "darwin" && platform !== "linux" && platform !== "win32")
        return end(new Error("Platform not yet supported."));
      var instance = {
        command,
        options,
        uuid: void 0,
        path: void 0
      };
      Attempt(instance, end);
    }
    function Linux(instance, end) {
      LinuxBinary(
        instance,
        function(error, binary) {
          if (error)
            return end(error);
          var command = [];
          command.push('cd "' + EscapeDoubleQuotes(Node.process.cwd()) + '";');
          for (var key in instance.options.env) {
            var value = instance.options.env[key];
            command.push("export " + key + '="' + EscapeDoubleQuotes(value) + '";');
          }
          command.push('"' + EscapeDoubleQuotes(binary) + '"'), /kdesudo/i.test(binary) ? (command.push(
            "--comment",
            '"' + instance.options.name + ' wants to make changes. Enter your password to allow this."'
          ), command.push("-d"), command.push("--")) : /pkexec/i.test(binary) && command.push("--disable-internal-agent");
          var magic = `SUDOPROMPT
`;
          command.push(
            '/bin/bash -c "echo ' + EscapeDoubleQuotes(magic.trim()) + "; " + EscapeDoubleQuotes(instance.command) + '"'
          ), command = command.join(" "), Node.child.exec(
            command,
            { encoding: "utf-8", maxBuffer: MAX_BUFFER },
            function(error2, stdout, stderr) {
              var elevated = stdout && stdout.slice(0, magic.length) === magic;
              elevated && (stdout = stdout.slice(magic.length)), error2 && !elevated && (/No authentication agent found/.test(stderr) ? error2.message = NO_POLKIT_AGENT : error2.message = PERMISSION_DENIED), end(error2, stdout, stderr);
            }
          );
        }
      );
    }
    function LinuxBinary(instance, end) {
      var index = 0, paths = ["/usr/bin/kdesudo", "/usr/bin/pkexec"];
      function test() {
        if (index === paths.length)
          return end(new Error("Unable to find pkexec or kdesudo."));
        var path6 = paths[index++];
        Node.fs.stat(
          path6,
          function(error) {
            if (error) {
              if (error.code === "ENOTDIR" || error.code === "ENOENT")
                return test();
              end(error);
            } else
              end(void 0, path6);
          }
        );
      }
      test();
    }
    function Mac(instance, callback) {
      var temp = Node.os.tmpdir();
      if (!temp)
        return callback(new Error("os.tmpdir() not defined."));
      var user = Node.process.env.USER;
      if (!user)
        return callback(new Error("env['USER'] not defined."));
      UUID(
        instance,
        function(error, uuid) {
          if (error)
            return callback(error);
          instance.uuid = uuid, instance.path = Node.path.join(
            temp,
            instance.uuid,
            instance.options.name + ".app"
          );
          function end(error2, stdout, stderr) {
            Remove(
              Node.path.dirname(instance.path),
              function(errorRemove) {
                if (error2)
                  return callback(error2);
                if (errorRemove)
                  return callback(errorRemove);
                callback(void 0, stdout, stderr);
              }
            );
          }
          MacApplet(
            instance,
            function(error2, stdout, stderr) {
              if (error2)
                return end(error2, stdout, stderr);
              MacIcon(
                instance,
                function(error3) {
                  if (error3)
                    return end(error3);
                  MacPropertyList(
                    instance,
                    function(error4, stdout2, stderr2) {
                      if (error4)
                        return end(error4, stdout2, stderr2);
                      MacCommand(
                        instance,
                        function(error5) {
                          if (error5)
                            return end(error5);
                          MacOpen(
                            instance,
                            function(error6, stdout3, stderr3) {
                              if (error6)
                                return end(error6, stdout3, stderr3);
                              MacResult(instance, end);
                            }
                          );
                        }
                      );
                    }
                  );
                }
              );
            }
          );
        }
      );
    }
    function MacApplet(instance, end) {
      var parent = Node.path.dirname(instance.path);
      Node.fs.mkdir(
        parent,
        function(error) {
          if (error)
            return end(error);
          var zip = Node.path.join(parent, "sudo-prompt-applet.zip");
          Node.fs.writeFile(
            zip,
            APPLET,
            "base64",
            function(error2) {
              if (error2)
                return end(error2);
              var command = [];
              command.push("/usr/bin/unzip"), command.push("-o"), command.push('"' + EscapeDoubleQuotes(zip) + '"'), command.push('-d "' + EscapeDoubleQuotes(instance.path) + '"'), command = command.join(" "), Node.child.exec(command, { encoding: "utf-8" }, end);
            }
          );
        }
      );
    }
    function MacCommand(instance, end) {
      var path6 = Node.path.join(
        instance.path,
        "Contents",
        "MacOS",
        "sudo-prompt-command"
      ), script = [];
      script.push('cd "' + EscapeDoubleQuotes(Node.process.cwd()) + '"');
      for (var key in instance.options.env) {
        var value = instance.options.env[key];
        script.push("export " + key + '="' + EscapeDoubleQuotes(value) + '"');
      }
      script.push(instance.command), script = script.join(`
`), Node.fs.writeFile(path6, script, "utf-8", end);
    }
    function MacIcon(instance, end) {
      if (!instance.options.icns)
        return end();
      Node.fs.readFile(
        instance.options.icns,
        function(error, buffer) {
          if (error)
            return end(error);
          var icns = Node.path.join(
            instance.path,
            "Contents",
            "Resources",
            "applet.icns"
          );
          Node.fs.writeFile(icns, buffer, end);
        }
      );
    }
    function MacOpen(instance, end) {
      var binary = Node.path.join(instance.path, "Contents", "MacOS", "applet"), options = {
        cwd: Node.path.dirname(binary),
        encoding: "utf-8"
      };
      Node.child.exec("./" + Node.path.basename(binary), options, end);
    }
    function MacPropertyList(instance, end) {
      var plist = Node.path.join(instance.path, "Contents", "Info.plist"), path6 = EscapeDoubleQuotes(plist), key = EscapeDoubleQuotes("CFBundleName"), value = instance.options.name + " Password Prompt";
      if (/'/.test(value))
        return end(new Error("Value should not contain single quotes."));
      var command = [];
      command.push("/usr/bin/defaults"), command.push("write"), command.push('"' + path6 + '"'), command.push('"' + key + '"'), command.push("'" + value + "'"), command = command.join(" "), Node.child.exec(command, { encoding: "utf-8" }, end);
    }
    function MacResult(instance, end) {
      var cwd2 = Node.path.join(instance.path, "Contents", "MacOS");
      Node.fs.readFile(
        Node.path.join(cwd2, "code"),
        "utf-8",
        function(error, code) {
          if (error) {
            if (error.code === "ENOENT")
              return end(new Error(PERMISSION_DENIED));
            end(error);
          } else
            Node.fs.readFile(
              Node.path.join(cwd2, "stdout"),
              "utf-8",
              function(error2, stdout) {
                if (error2)
                  return end(error2);
                Node.fs.readFile(
                  Node.path.join(cwd2, "stderr"),
                  "utf-8",
                  function(error3, stderr) {
                    if (error3)
                      return end(error3);
                    code = parseInt(code.trim(), 10), code === 0 ? end(void 0, stdout, stderr) : (error3 = new Error(
                      "Command failed: " + instance.command + `
` + stderr
                    ), error3.code = code, end(error3, stdout, stderr));
                  }
                );
              }
            );
        }
      );
    }
    function Remove(path6, end) {
      if (typeof path6 != "string" || !path6.trim())
        return end(new Error("Argument path not defined."));
      var command = [];
      if (Node.process.platform === "win32") {
        if (/"/.test(path6))
          return end(new Error("Argument path cannot contain double-quotes."));
        command.push('rmdir /s /q "' + path6 + '"');
      } else
        command.push("/bin/rm"), command.push("-rf"), command.push('"' + EscapeDoubleQuotes(Node.path.normalize(path6)) + '"');
      command = command.join(" "), Node.child.exec(command, { encoding: "utf-8" }, end);
    }
    function UUID(instance, end) {
      Node.crypto.randomBytes(
        256,
        function(error, random) {
          error && (random = Date.now() + "" + Math.random());
          var hash = Node.crypto.createHash("SHA256");
          hash.update("sudo-prompt-3"), hash.update(instance.options.name), hash.update(instance.command), hash.update(random);
          var uuid = hash.digest("hex").slice(-32);
          if (!uuid || typeof uuid != "string" || uuid.length !== 32)
            return end(new Error("Expected a valid UUID."));
          end(void 0, uuid);
        }
      );
    }
    function ValidName(string) {
      return !(!/^[a-z0-9 ]+$/i.test(string) || string.trim().length === 0 || string.length > 70);
    }
    function Windows(instance, callback) {
      var temp = Node.os.tmpdir();
      if (!temp)
        return callback(new Error("os.tmpdir() not defined."));
      UUID(
        instance,
        function(error, uuid) {
          if (error)
            return callback(error);
          if (instance.uuid = uuid, instance.path = Node.path.join(temp, instance.uuid), /"/.test(instance.path))
            return callback(
              new Error("instance.path cannot contain double-quotes.")
            );
          instance.pathElevate = Node.path.join(instance.path, "elevate.vbs"), instance.pathExecute = Node.path.join(instance.path, "execute.bat"), instance.pathCommand = Node.path.join(instance.path, "command.bat"), instance.pathStdout = Node.path.join(instance.path, "stdout"), instance.pathStderr = Node.path.join(instance.path, "stderr"), instance.pathStatus = Node.path.join(instance.path, "status"), Node.fs.mkdir(
            instance.path,
            function(error2) {
              if (error2)
                return callback(error2);
              function end(error3, stdout, stderr) {
                Remove(
                  instance.path,
                  function(errorRemove) {
                    if (error3)
                      return callback(error3);
                    if (errorRemove)
                      return callback(errorRemove);
                    callback(void 0, stdout, stderr);
                  }
                );
              }
              WindowsWriteExecuteScript(
                instance,
                function(error3) {
                  if (error3)
                    return end(error3);
                  WindowsWriteCommandScript(
                    instance,
                    function(error4) {
                      if (error4)
                        return end(error4);
                      WindowsElevate(
                        instance,
                        function(error5, stdout, stderr) {
                          if (error5)
                            return end(error5, stdout, stderr);
                          WindowsWaitForStatus(
                            instance,
                            function(error6) {
                              if (error6)
                                return end(error6);
                              WindowsResult(instance, end);
                            }
                          );
                        }
                      );
                    }
                  );
                }
              );
            }
          );
        }
      );
    }
    function WindowsElevate(instance, end) {
      var command = [];
      command.push("powershell.exe"), command.push("Start-Process"), command.push("-FilePath"), command.push(`"'` + instance.pathExecute.replace(/'/g, "`'") + `'"`), command.push("-WindowStyle hidden"), command.push("-Verb runAs"), command = command.join(" ");
      var child = Node.child.exec(
        command,
        { encoding: "utf-8" },
        function(error, stdout, stderr) {
          if (error)
            return end(new Error(PERMISSION_DENIED), stdout, stderr);
          end();
        }
      );
      child.stdin.end();
    }
    function WindowsResult(instance, end) {
      Node.fs.readFile(
        instance.pathStatus,
        "utf-8",
        function(error, code) {
          if (error)
            return end(error);
          Node.fs.readFile(
            instance.pathStdout,
            "utf-8",
            function(error2, stdout) {
              if (error2)
                return end(error2);
              Node.fs.readFile(
                instance.pathStderr,
                "utf-8",
                function(error3, stderr) {
                  if (error3)
                    return end(error3);
                  code = parseInt(code.trim(), 10), code === 0 ? end(void 0, stdout, stderr) : (error3 = new Error(
                    "Command failed: " + instance.command + `\r
` + stderr
                  ), error3.code = code, end(error3, stdout, stderr));
                }
              );
            }
          );
        }
      );
    }
    function WindowsWaitForStatus(instance, end) {
      Node.fs.stat(
        instance.pathStatus,
        function(error, stats) {
          error && error.code === "ENOENT" || stats.size < 2 ? setTimeout(
            function() {
              Node.fs.stat(
                instance.pathStdout,
                function(error2) {
                  if (error2)
                    return end(new Error(PERMISSION_DENIED));
                  WindowsWaitForStatus(instance, end);
                }
              );
            },
            1e3
          ) : error ? end(error) : end();
        }
      );
    }
    function WindowsWriteCommandScript(instance, end) {
      var cwd2 = Node.process.cwd();
      if (/"/.test(cwd2))
        return end(new Error("process.cwd() cannot contain double-quotes."));
      var script = [];
      script.push("@echo off"), script.push("chcp 65001>nul"), script.push('cd /d "' + cwd2 + '"');
      for (var key in instance.options.env) {
        var value = instance.options.env[key];
        script.push("set " + key + "=" + value.replace(/([<>\\|&^])/g, "^$1"));
      }
      script.push(instance.command), script = script.join(`\r
`), Node.fs.writeFile(instance.pathCommand, script, "utf-8", end);
    }
    function WindowsWriteExecuteScript(instance, end) {
      var script = [];
      script.push("@echo off"), script.push(
        'call "' + instance.pathCommand + '" > "' + instance.pathStdout + '" 2> "' + instance.pathStderr + '"'
      ), script.push('(echo %ERRORLEVEL%) > "' + instance.pathStatus + '"'), script = script.join(`\r
`), Node.fs.writeFile(instance.pathExecute, script, "utf-8", end);
    }
    module2.exports.exec = Exec;
    var APPLET = "UEsDBAoAAAAAAO1YcEcAAAAAAAAAAAAAAAAJABwAQ29udGVudHMvVVQJAAPNnElWLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACACgeXBHlHaGqKEBAAC+AwAAEwAcAENvbnRlbnRzL0luZm8ucGxpc3RVVAkAA1zWSVYtkRBXdXgLAAEE9QEAAAQUAAAAfZNRb5swFIWfl1/BeA9OpSmqJkqVBCJFop1VyKQ9Ta59S6wa27NNCfv1M0naJWTsEXO+c8+9vo7v97UI3sBYruRdeBPNwgAkVYzL6i7cluvpbXifTOLP6bdV+QNngRbcugBvl/lmFYRThBZaC0AoLdMA55uiDLwHQtljGIQ75/RXhNq2jUiviqiqe6FF2CgNxnW5N5t6IGKOhb7M0f0ijj9lnLpk8il+hS5ZrZeNZAIWQqj2ge+B5YoSwX8T5xEbo17ktc40gIZQCm8glK5BuieovP5Dbp3xHSeZrHyCXYxO3wM+2wNtHHkWMAQP/bkxbkOVXPMxKuK0Dz6CMh+Wv3AwQ9gPM7INU1NtVK3Ha8sXlfoB+m6J6b4fRzv0mkezMf6R1Fe5MbG2VYYF+L+lMaGvpIKy01cOC4zzMazYKeNOQYuDYkjfjMcteCWJa8w/Zi2ugubFA5e8buqisw7qU81ltzB0xx3QC5/TFh7J/e385/zL+7+/wWbR/LwIOl/dvHiCXw03YFfEPJ9dwsWu5sV2kwnod3QoeLeL0eGdJJM/UEsDBAoAAAAAAHSBjkgAAAAAAAAAAAAAAAAPABwAQ29udGVudHMvTWFjT1MvVVQJAAMbpQ9XLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACABVHBdH7Dk4KTIIAADIYQAAFQAcAENvbnRlbnRzL01hY09TL2FwcGxldFVUCQADMiPZVVOlD1d1eAsAAQT1AQAABBQAAADtnG9sHEcVwGfti7M1/rONLNVtXHqpzsipis+pHOSWFOzEm25at3XrJI2ozbK+W/suuds79vaSuCKSpaOIxRy1+NSPRPAhlWj7AVRaQCWpTRz+CEo+RSKCCho4K67kVhUyAeV4b3fWt17fXZqKFgHvp8zO3/dmdmfPmtl5L7+8/uPXGWMNELZCaGRMgmjHIlxaBCibdcoGsewCljGCIAiCIAiCIAiCIP7r+M21d67zjb/zEaAdwr1bGHuWMQH2/2wAgqqODj0kf0F+8nGfoFRbJ8p9U0C5g/KRgwEZqZLGfrfwwJx+LP2kVWkelD9zJ2NfBr1nWt2xrhNisxWZ3Ex6MpNSc1Z+soqOO+5i7JMYt7vj9BC5jiZXBwirCT2V1c0qOgZAxwMYt9cbRyxnmUljusa9mKBjGON2tgG/PlXNGyeSRlxNGlOZKjpeBR0KxsFx+MB7VJy5GB46OOSrCLPKfEjrH3/gFry+4zOpuH8sm+VF5srW6ltVjZQ3HVnL3KRDDLsflMSADpyDyjuR0urp6AAdHRgHdOD9iOs6Ypl0OmPUupeecOW19OsQAmn3tzBy4LFH5OED3jz0MbYouM8D460BOdTXCaEF6tsgLkF8GeJPQBj16Rb4PTf5xl2NH4J8a5Vy1N3F3OcZzefMaCo5GeVTuJ2P4cUf/aH5qbbP73/utpfeevdbLzwfYfy+Q80woGan/1E+ljo/703g77IaOJY479t5rqFLDag9OjaTs/R0dCQ5aWrmTHS/qaX1ExnzWC66L2PqY7p5PBnTc71TXnn0sG7mkhkjFx3a0IL30e/rQxB+EXL68J4BBLe73r298DySk5tlGPtJY1BmOhZTc727PBH2Ke+ZhF35nTyP80oQBEEQBPFRcJTZVwpvrxZWpLmJkN0VKT4q2iORUGFBOPfnBuFX9nhELOG67f1D9pWxpw4XVrrmTklz+ZY5Wfwurm/t3ffi9cE+uM41vYbbj2fP5kNXt9sXiopwVRj6xhPlr160mttfuVi4Fs2vXv2rfc5u7UeZfxQ+y4pPh/JrpyUUBjmrofzmadGXKf0eui7KK/ZwJLQUiuRAe+mLUFQ+tFKUV3npd7AU9ytz8iqIiXYoUnoBsqdxDbXk3CXcRov9lYhoW5EQjBxb4NoSY9iQsvn5+QSuusrduAybL3eHIIIbLqyIS9CHlY3loB8rldVKuLfyOsE1+a6zhUVxYsFp3Amqz8tr7Lz8dza1JF8TmC3/syivYVtcfxcWOycWQDvuLcrdnc61y7mGnWsErgmsXDbK5TKkscnypJvGhsuH3TQ2X37YTaPQ8ucw7W6t1LR2TFfjekqb0SGTiedTOmz0klZSSyWf0U01pqVSufXGmThsjs20OpU3Yrjuxbnu4u+GP8b1LO6PcX2L4Q6+v8Q07u9aQFLy71Ckt54TIfjfNdzfDkMYhTAOIXHXh39vCYIgCIIgCIIgCIL4z3Nm+84/Ci1Nn8b0ryHsgbBX1rbgOXD7LZJzNtrC0/gFqYOn8csQ/GONguQchPXzcvy+9CBzvk84HxkO+tJH3bRz5Fb0pb/nS3/fl/6BL/2aL43faLzz3Wbmju8W5p6pttaoR9THjgyZ0zEeH2eqqmbNzLShpXVIpxOqflKP5S1dTehaXDeZqhvHk2bGYOo+LZXal0lnM4ZuWMPJXFazYgmmPp7VjWF9SsunrPVa1HpMn0lPm2r8hGZO3aea+nQyZ+mmmtNjFp5i4oG0lTChE+eDj2pm8lbSgDFoln4yCRp00zQyEDmZtBZLbGxnanHzgWh092d29e/uv+/f+DIQBEEQBEEQBEEQ/7P81rX/FxoZm/Xs/5UmtP8PO/W3M9fGvKoPAEfYXLQJ1HOpmk+AJx80OOb5m/URGG9z9c378rVs9F15tPXP1dS3wvVtC+Q9/H4DFX21fQcY9zvo9eXrj6++D0Af1zfqy9eyx3f16QnVMayufr+zXN+sL99YRx/O69er+RdIgXkNxJv9DfBTDIxLPa6Zudr6enz5euO6ke9Bj7TRzr0noK+JbczfyA9hgOvr9OX98t57XNFX3ydhlOsL+2T8+oK/ucrvNOCfEHbbXhAqeebLB/0V7oYp7+Pt8PsZWnl1+urRpAn7SUCcYBX/hkth95kd2cFYllX3bxB4+xCrzcCO6v4PbXzo1fwbEM/H4ds/f/nCgZH+8k+j0vNPv7Jlz7qPQ1PFx+FVPoZ76ozj42K87YP9/cT7xuf9UfpSeP0MsJvzp0A8/4g3w+78ef4R+F4QBEEQBPH/w1Gm2FeUwturytwpUSnmJfta4Q3h3J8aFeE9xf7d1ZBSOCcqhftZ/m+YKuG6wV4qaQzdGED0Z2jJ/zpa9ZcegjIF7fkVaIBrt11nJxYOOepXpPPyKjsvvytOLcnvCWxJfh87V+xTa0rx1Kpj0a8UFqWJhXL3fgHt9xXn+rCz7Bop3rkTEkNj5e7bIZ7HNRZb/ku5XE6g58HyZUzdj6mLjh1/Pbt7XMt5dvfvtLl1Fbv7BtbhrtyEPW6V038H1yE88yQTTkqC1LJVnIeaCNe7dr3sEPEe6lCb9LWGfa3efvNG8pe5fF8NeW8g3n7jCI+/xOOEVH19KvF9oudHH2n/YOtYgiAIgiAIgiAIgiA+fm69mx3aO8bYtkHn/xlwDq8nkwaavz9h9swzc+DWwRrm71A5CJVVjeChTtk26Fqwu0fxQjUL+9vqHVV/KC53OUd+bJxVfBkw7/gzCO5pr3dOK/g+WUQDeZlV/A2QRwJ5THjn1/xcd9BfhlT1KbgpVwLn+W2amGr2//8CUEsDBBQAAAAIAAVHj0ga7FYjfQEAAKoCAAAhABwAQ29udGVudHMvTWFjT1Mvc3Vkby1wcm9tcHQtc2NyaXB0VVQJAAOJkBBXipAQV3V4CwABBPUBAAAEFAAAAI1SO08cMRDu91cMHIKGxUB5xSGEUqTlFKWMvPYca+EXnjGXy6/PeNcg0qVay+PvObs5U5OLatI0DxvYIwNVm4BdQGIdMhxSkauJ8K1i7FOjvSdwB2A+/WJnXpEJdEGwjvTk0W6HhTW8WldgzKDedVF2Ug2tLn7svz3DDpTFdxWr93C/u7wbVKWyoDhVM/8XZAOPOXvcm+IyXxGcizeaUca0XJ1D0CfQnlEysE2VwbuII0br4gvdCMF37m9IoC39+oxTO2EpS8oZJdtRS0aIKY5/sCQoyLVEMMki6Ghl0BGN9SeuICkPIctXDHDDSB9oGEQi1yZWUAda8EZnIcR/eIOOVao+9TrbkpYFjLmkkHk0KYSGvdt12/e71cP6Hs2c4OJBemtsYusplVX+GLHQ7DKkQ098/ZF38dLEpRCeNUMlMW90BIseeQkWtuu2qKmIyDHCuqFuo1N11Ud/1Cf6CHb7Sfxld2ATklQoUGEDActfZ5326WU74G/HcDv8BVBLAwQKAAAAAADtWHBHqiAGewgAAAAIAAAAEAAcAENvbnRlbnRzL1BrZ0luZm9VVAkAA82cSVYqkRBXdXgLAAEE9QEAAAQUAAAAQVBQTGFwbHRQSwMECgAAAAAAm3lwRwAAAAAAAAAAAAAAABMAHABDb250ZW50cy9SZXNvdXJjZXMvVVQJAANW1klWLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACACAeXBHfrnysfYGAAAf3AAAHgAcAENvbnRlbnRzL1Jlc291cmNlcy9hcHBsZXQuaWNuc1VUCQADH9ZJVnGlD1d1eAsAAQT1AQAABBQAAADt3Xk81Hkcx/Hvb5yVo5bGsVlKbcpRRqFlGZGS5JikRBIdI0OZttMZloqiYwrVjD1UqJaUokTRubG72bZVjqR1VZNjp2XEGo9H+9gt+9h/9tHx8H7N4/fw5MHjYeaPz+P7+P7x/bL9griEPNBm+001J0S+ZbvL/NmKwzWHE0IUHebYuRFCEckjL9v/xSvk2EpCpBXZtrYuDra2Oi4hwSvZgSsIMU9MdPdePcZd1aqQu0p3fDkrcFrs+mPWihMU9y6clp5XEFFdbRrEczCtGtfkL3pWfvBGublJ4ct051kuocYtaaqll/IjdfR+V75vlTdl//AJVZU6elZ5f0S7NO3MaE2xMElhF+TUrHgW2nFYeGTrs/OrhDJN5zMX8ZJVKXrqSUM1Rj03bnf85/pJMXECNdl0D1ctfe/j82imziM2nllSa3t5q8+vP1f38k/k22uN1lmnvfz0b8dGxO+mnh91v7WB2tKdrG3d4vmJaHlTvjGzdMqWcw/9frnCtQpPZK9sMKi/Ey/jzgqIPzBy9/dlf9griI2/u+sjcApozWx6/NXytC+qBTlrhb69fE7J6tgOzpWjFSl8qxihr5dYf/qExoeupY6Ze/j2PfL1azhhZ8fU3eelJY+ylk16UJN6KmOU0M4r+75cZhH/mxNndowNb4wx7TCoN4yvMGu8ySq5l5W5t+xQyYbS/Ome7e0W0sXbC5aktl0LEXNYR9obH7dMT721dbNdT/eFzXNEYSH8GU+bQ5s6YniGcj3fHtgXPbo0Oj4i3d5G1Fjfm/Ng7kgpjQDNxw4RRnu+Vloy5ZE3J6OpwlFBzaxS25He2h3lJuizO70zJPLUYtks14RE5yrD8y2tXa5l5Wqh/NBY06yoiCLF08Nk9A5Ojbs43GmR1Ch/PaZsLf3e6uPRSrIM1ROqGjt80leqfdxYbNn+WV7K7ZKiy/t6r1/3ie46V5432T/Oahs9V7NnVzb9zoq2rFgvPxXrcAMzmvWnGjof/RpdsZThIEpex6DGbd5h6STaOyZXxV/YfW9u4KyllmZ3X15IMHHLSJtVPSOvULCsz2TyPC/WL9kGSme/1L01SSzjfbHnqk+OV7OBmevZeo3DBR7lXT5drT0MkX5PwDd1EQ0ebfkh1zy/L8ydd+VJ4CLuRndNjuwj+vMfU8q2l2l1rGtr8FC2D+fdSGk81eltuTjYSMk++4BMd0DXQo35iXbZndGdcXkGFyeG6b28evF22M2w22HlYSXetGSLW4cfFT00WqvN9bkqCujQ9KzdSt+snr+qmbcme+5Y3cDRn9BDLps+dPVltE9UkPeb6XovineiVUznTznyuZaSn/ZvR8VeRUYLqe3iHFqnU6+7+4LmtfsmaS0MdjIvslFJGG/rn7DPdMGLcx4d6eP2Oz92Y49kWbBUjudU2ijHnc7YIODQxD1aPx8PynVr+cmvJoy2+M5nQa2Kt0dvdPxp73LNU6aTeaktTfHH1L+8Pm/XalZcFcfzYxlhTefuzjRGobLKEqPZh8QKxUXWbU/ERvW78ghvTGTUNd0g9YqbcjUy5h0xVbn3S7SS54SOqKt88UR0qZuxKfxlZfODUm52o2HkGTOLw5dqhevvWjH7ssiqxAhKwA91d1nWG9w/GJIc7GwWbKKe/mAsGRqXBb87P10jH8/0LY6kpGQV1KcuAwAAeCt4LiVFWRJKs4DJ6p9GxGHWfLuTM5dt61/pzCCE7vLmSodGJM/ASqdzU2U3VjpY6WClg5XOICudUaI3VjocuWCsdAAAAAAAAAAAAAAAAD5o1Gmr054TSoqWxPvnfrLxVEIc29/cT5YmkmdgPzlCSz8a+8nYT8Z+MvaTB9lPZpJX+8lRktFyRdDF0m6IdcF2MgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8ddD8G5oJkUuQnAXwnvxLAAAAADDkEFURRckVE6rIv+Tb1078MiZEetubJ34RHckzcOIXd8uWTpz4hRO/cOIXTvwa5MQvoidZ5S8a9h8nfl1QVhipQ6jyyWeuvTaBGP3D5fwgE4gpeQYmUCZ7XQ0mECYQJhAm0GATyOfVmYOU4sAdNi+cOUpm/9cdNv2Di8kkFN3mYOtrg8sE14xicGFwYXDhmlEAAD5w/Os1o8bTcM0oVjpY6WClg2tGAQAAAAAAAAAAAAAAgL/wb9eMBpow+r817yN/fwnJf33P5g78nWofEZNXD3u95GdSkh3o135/aL2i3vl/gHf/7t59oDlnDSHS8gQhNGQL8uWs6P+iwPYLDuIOzARqyM+E9QOfA3PIfw4IIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhND70J9QSwMEFAAAAAgA7VhwR/dYplZAAAAAagEAAB4AHABDb250ZW50cy9SZXNvdXJjZXMvYXBwbGV0LnJzcmNVVAkAA82cSVZTpQ9XdXgLAAEE9QEAAAQUAAAAY2BgZGBgYFQBEiDsxjDygJQDPlkmEIEaRpJAQg8kLAMML8bi5OIqIFuouKA4A0jLMTD8/w+S5AdrB7PlBIAEAFBLAwQKAAAAAADtWHBHAAAAAAAAAAAAAAAAJAAcAENvbnRlbnRzL1Jlc291cmNlcy9kZXNjcmlwdGlvbi5ydGZkL1VUCQADzZxJVi2REFd1eAsAAQT1AQAABBQAAABQSwMEFAAAAAgA7VhwRzPLNU9TAAAAZgAAACsAHABDb250ZW50cy9SZXNvdXJjZXMvZGVzY3JpcHRpb24ucnRmZC9UWFQucnRmVVQJAAPNnElWU6UPV3V4CwABBPUBAAAEFAAAACWJOw6AIBAFe08DCBVX2QbWhZgQ1vCpCHcXtHkzkzegtCDB5Xp/g0+UyihARnb70kL/UbvffYpjQODcmk9zKXListxCoUsZA7EQ5S0+dVq085gvUEsDBAoAAAAAAIeBjkgAAAAAAAAAAAAAAAAbABwAQ29udGVudHMvUmVzb3VyY2VzL1NjcmlwdHMvVVQJAAM9pQ9XLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACAAJgI5ICl5liTUBAADMAQAAJAAcAENvbnRlbnRzL1Jlc291cmNlcy9TY3JpcHRzL21haW4uc2NwdFVUCQADcaIPV1OlD1d1eAsAAQT1AQAABBQAAAB9UMtOAkEQrNldd9dhH3Dz6NGYiPIJHjTxLCZeF9iDcXEJC0RvfoI/4sEfIvoHPEQEhbIHvOok01U16emu7vOkaF2dXu7XqrUTcyMATkxCwYKthCAUbmciAQ8O11yFcGBfbF/4jR24WmCvWjwUeXqfNutn13XyEeYYHkqKam+kghdJGfUCvwIfB6jiGAX6aCHHETroCrYFe6IKNEXfGOXChc0v7HKpBRzdSFrtELvbumKVC80F/FIjzwe9bj91uZRuXJuwAiLjNi7DlsxPaJSUAMrCFOeac3GfpINennQ6d/0sA4z7JxzKiVCCV+YHAs74LuuIONUi//4RIoC63czrIbYQS3PFicWJcTMTv1JHmocmROLJ45gjzfHvXJqjf7ZZ4RT+61uaBbDipGh2ZanBcjh8/gFQSwECHgMKAAAAAADtWHBHAAAAAAAAAAAAAAAACQAYAAAAAAAAABAA7UEAAAAAQ29udGVudHMvVVQFAAPNnElWdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAoHlwR5R2hqihAQAAvgMAABMAGAAAAAAAAQAAAKSBQwAAAENvbnRlbnRzL0luZm8ucGxpc3RVVAUAA1zWSVZ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAAB0gY5IAAAAAAAAAAAAAAAADwAYAAAAAAAAABAA7UExAgAAQ29udGVudHMvTWFjT1MvVVQFAAMbpQ9XdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAVRwXR+w5OCkyCAAAyGEAABUAGAAAAAAAAAAAAO2BegIAAENvbnRlbnRzL01hY09TL2FwcGxldFVUBQADMiPZVXV4CwABBPUBAAAEFAAAAFBLAQIeAxQAAAAIAAVHj0ga7FYjfQEAAKoCAAAhABgAAAAAAAEAAADtgfsKAABDb250ZW50cy9NYWNPUy9zdWRvLXByb21wdC1zY3JpcHRVVAUAA4mQEFd1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAADtWHBHqiAGewgAAAAIAAAAEAAYAAAAAAABAAAApIHTDAAAQ29udGVudHMvUGtnSW5mb1VUBQADzZxJVnV4CwABBPUBAAAEFAAAAFBLAQIeAwoAAAAAAJt5cEcAAAAAAAAAAAAAAAATABgAAAAAAAAAEADtQSUNAABDb250ZW50cy9SZXNvdXJjZXMvVVQFAANW1klWdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAgHlwR3658rH2BgAAH9wAAB4AGAAAAAAAAAAAAKSBcg0AAENvbnRlbnRzL1Jlc291cmNlcy9hcHBsZXQuaWNuc1VUBQADH9ZJVnV4CwABBPUBAAAEFAAAAFBLAQIeAxQAAAAIAO1YcEf3WKZWQAAAAGoBAAAeABgAAAAAAAAAAACkgcAUAABDb250ZW50cy9SZXNvdXJjZXMvYXBwbGV0LnJzcmNVVAUAA82cSVZ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAADtWHBHAAAAAAAAAAAAAAAAJAAYAAAAAAAAABAA7UFYFQAAQ29udGVudHMvUmVzb3VyY2VzL2Rlc2NyaXB0aW9uLnJ0ZmQvVVQFAAPNnElWdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgA7VhwRzPLNU9TAAAAZgAAACsAGAAAAAAAAQAAAKSBthUAAENvbnRlbnRzL1Jlc291cmNlcy9kZXNjcmlwdGlvbi5ydGZkL1RYVC5ydGZVVAUAA82cSVZ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAACHgY5IAAAAAAAAAAAAAAAAGwAYAAAAAAAAABAA7UFuFgAAQ29udGVudHMvUmVzb3VyY2VzL1NjcmlwdHMvVVQFAAM9pQ9XdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgACYCOSApeZYk1AQAAzAEAACQAGAAAAAAAAAAAAKSBwxYAAENvbnRlbnRzL1Jlc291cmNlcy9TY3JpcHRzL21haW4uc2NwdFVUBQADcaIPV3V4CwABBPUBAAAEFAAAAFBLBQYAAAAADQANANwEAABWGAAAAAA=", PERMISSION_DENIED = "User did not grant permission.", NO_POLKIT_AGENT = "No polkit authentication agent found.", MAX_BUFFER = 134217728;
  }
});

// ../../node_modules/@expo/package-manager/build/utils/spawn.js
var require_spawn = __commonJS({
  "../../node_modules/@expo/package-manager/build/utils/spawn.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.spawnSudoAsync = exports2.createPendingSpawnAsync = void 0;
    var spawn_async_1 = __importDefault(require_spawnAsync()), sudo_prompt_1 = __importDefault(require_sudo_prompt());
    function createPendingSpawnAsync(actionAsync, spawnAsync) {
      let childResolve, child = new Promise((resolve7, reject) => {
        childResolve = resolve7;
      }), pendingPromise = new Promise((spawnResolve, spawnReject) => {
        actionAsync().then((result) => {
          let spawnPromise = spawnAsync(result);
          childResolve(spawnPromise.child), spawnPromise.then(spawnResolve).catch(spawnReject);
        }).catch((error) => {
          childResolve(null), spawnReject(error);
        });
      });
      return pendingPromise.child = child, pendingPromise;
    }
    exports2.createPendingSpawnAsync = createPendingSpawnAsync;
    async function spawnSudoAsync(command, spawnOptions) {
      if (process.platform === "win32")
        return new Promise((resolve7, reject) => {
          sudo_prompt_1.default.exec(command.join(" "), { name: "pod install" }, (error) => {
            error && reject(error), resolve7();
          });
        });
      console.log("Your password might be needed to install CocoaPods CLI: https://guides.cocoapods.org/using/getting-started.html#installation"), await (0, spawn_async_1.default)("sudo", command, spawnOptions);
    }
    exports2.spawnSudoAsync = spawnSudoAsync;
  }
});

// ../../node_modules/@expo/package-manager/build/ios/CocoaPodsPackageManager.js
var require_CocoaPodsPackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/ios/CocoaPodsPackageManager.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getImprovedPodInstallError = exports2.getPodRepoUpdateMessage = exports2.getPodUpdateMessage = exports2.CocoaPodsPackageManager = exports2.extractMissingDependencyError = exports2.CocoaPodsError = void 0;
    var spawn_async_1 = __importDefault(require_spawnAsync()), chalk_1 = __importDefault(require_source()), fs_1 = require("fs"), os_1 = __importDefault(require("os")), path_1 = __importDefault(require("path")), spawn_1 = require_spawn(), CocoaPodsError = class extends Error {
      code;
      cause;
      name = "CocoaPodsError";
      isPackageManagerError = !0;
      constructor(message, code, cause) {
        super(cause ? `${message}
\u2514\u2500 Cause: ${cause.message}` : message), this.code = code, this.cause = cause;
      }
    };
    exports2.CocoaPodsError = CocoaPodsError;
    function extractMissingDependencyError(errorOutput) {
      let results = errorOutput.match(/Unable to find a specification for ['"`]([\w-_\d\s]+)['"`] depended upon by ['"`]([\w-_\d\s]+)['"`]/);
      return results ? [results[1], results[2]] : null;
    }
    exports2.extractMissingDependencyError = extractMissingDependencyError;
    var CocoaPodsPackageManager = class _CocoaPodsPackageManager {
      options;
      silent;
      static getPodProjectRoot(projectRoot) {
        if (_CocoaPodsPackageManager.isUsingPods(projectRoot))
          return projectRoot;
        let iosProject = path_1.default.join(projectRoot, "ios");
        if (_CocoaPodsPackageManager.isUsingPods(iosProject))
          return iosProject;
        let macOsProject = path_1.default.join(projectRoot, "macos");
        return _CocoaPodsPackageManager.isUsingPods(macOsProject) ? macOsProject : null;
      }
      static isUsingPods(projectRoot) {
        return (0, fs_1.existsSync)(path_1.default.join(projectRoot, "Podfile"));
      }
      static async gemInstallCLIAsync(nonInteractive = !1, spawnOptions = { stdio: "inherit" }) {
        let options = ["install", "cocoapods", "--no-document"];
        try {
          await (0, spawn_async_1.default)("gem", options, spawnOptions);
        } catch (error) {
          if (nonInteractive)
            throw new CocoaPodsError("Failed to install CocoaPods CLI with gem (recommended)", "COMMAND_FAILED", error);
          await (0, spawn_1.spawnSudoAsync)(["gem", ...options], spawnOptions);
        }
      }
      static async brewLinkCLIAsync(spawnOptions = { stdio: "inherit" }) {
        await (0, spawn_async_1.default)("brew", ["link", "cocoapods"], spawnOptions);
      }
      static async brewInstallCLIAsync(spawnOptions = { stdio: "inherit" }) {
        await (0, spawn_async_1.default)("brew", ["install", "cocoapods"], spawnOptions);
      }
      static async installCLIAsync({ nonInteractive = !1, spawnOptions = { stdio: "inherit" } }) {
        spawnOptions || (spawnOptions = { stdio: "inherit" });
        let silent = !!spawnOptions.ignoreStdio;
        try {
          return !silent && console.log("\u203A Attempting to install CocoaPods CLI with Gem"), await _CocoaPodsPackageManager.gemInstallCLIAsync(nonInteractive, spawnOptions), !silent && console.log("\u203A Successfully installed CocoaPods CLI with Gem"), !0;
        } catch (error) {
          silent || (console.log(chalk_1.default.yellow("\u203A Failed to install CocoaPods CLI with Gem")), console.log(chalk_1.default.red(error.stderr ?? error.message)), console.log("\u203A Attempting to install CocoaPods CLI with Homebrew"));
          try {
            if (await _CocoaPodsPackageManager.brewInstallCLIAsync(spawnOptions), !await _CocoaPodsPackageManager.isCLIInstalledAsync(spawnOptions))
              try {
                if (await _CocoaPodsPackageManager.brewLinkCLIAsync(spawnOptions), !await _CocoaPodsPackageManager.isCLIInstalledAsync(spawnOptions))
                  throw new CocoaPodsError("CLI could not be installed automatically with gem or Homebrew, please install CocoaPods manually and try again", "NO_CLI", error);
              } catch (error2) {
                throw new CocoaPodsError("Homebrew installation appeared to succeed but CocoaPods CLI not found in PATH and unable to link.", "NO_CLI", error2);
              }
            return !silent && console.log("\u203A Successfully installed CocoaPods CLI with Homebrew"), !0;
          } catch (error2) {
            throw !silent && console.warn(chalk_1.default.yellow("\u203A Failed to install CocoaPods with Homebrew. Please install CocoaPods CLI manually and try again.")), new CocoaPodsError("Failed to install CocoaPods with Homebrew. Please install CocoaPods CLI manually and try again.", "NO_CLI", error2);
          }
        }
      }
      static isAvailable(projectRoot, silent) {
        return process.platform !== "darwin" ? (!silent && console.log(chalk_1.default.red("CocoaPods is only supported on macOS machines")), !1) : _CocoaPodsPackageManager.isUsingPods(projectRoot) ? !0 : (!silent && console.log(chalk_1.default.yellow("CocoaPods is not supported in this project")), !1);
      }
      static async isCLIInstalledAsync(spawnOptions = { stdio: "inherit" }) {
        try {
          return await (0, spawn_async_1.default)("pod", ["--version"], spawnOptions), !0;
        } catch {
          return !1;
        }
      }
      constructor({ cwd: cwd2, silent }) {
        this.silent = !!silent, this.options = {
          cwd: cwd2,
          // We use pipe by default instead of inherit so that we can capture stderr/stdout and process it for errors.
          // Later we'll also pipe the stdout/stderr to the terminal when silent is false.
          stdio: "pipe"
        };
      }
      get name() {
        return "CocoaPods";
      }
      /** Runs `pod install` and attempts to automatically run known troubleshooting steps automatically. */
      async installAsync({ spinner } = {}) {
        await this._installAsync({ spinner });
      }
      isCLIInstalledAsync() {
        return _CocoaPodsPackageManager.isCLIInstalledAsync(this.options);
      }
      installCLIAsync() {
        return _CocoaPodsPackageManager.installCLIAsync({
          nonInteractive: !0,
          spawnOptions: this.options
        });
      }
      async handleInstallErrorAsync({ error, shouldUpdate = !0, updatedPackages = [], spinner }) {
        if (!error.output)
          throw error;
        if (!shouldUpdate)
          throw getImprovedPodInstallError(error, {
            cwd: this.options.cwd
          });
        let errorOutput = error.output.join(os_1.default.EOL).trim(), { updatePackage, shouldUpdateRepo } = getPodUpdateMessage(errorOutput);
        return !updatePackage || updatedPackages.includes(updatePackage) ? await this._installAsync({
          spinner,
          shouldRepoUpdate: !0,
          // Include a boolean to ensure pod install --repo-update isn't invoked in the unlikely case where the pods fail to update.
          shouldUpdate: !1,
          updatedPackages
        }) : (updatedPackages.push(updatePackage), await this.runInstallTypeCommandAsync(["update", updatePackage, shouldUpdateRepo ? "" : "--no-repo-update"].filter(Boolean), {
          formatWarning() {
            return `Failed to update ${chalk_1.default.bold(updatePackage)}. Attempting to update the repo instead.`;
          },
          spinner,
          updatedPackages
        }));
      }
      async _installAsync({ shouldRepoUpdate, ...props } = {}) {
        return await this.runInstallTypeCommandAsync(["install", shouldRepoUpdate ? "--repo-update" : ""].filter(Boolean), {
          formatWarning(error) {
            return getPodRepoUpdateMessage(error.output.join(os_1.default.EOL).trim()).message;
          },
          ...props
        });
      }
      async runInstallTypeCommandAsync(command, { formatWarning, ...props } = {}) {
        try {
          return await this._runAsync(command);
        } catch (error) {
          if (formatWarning) {
            let warning = formatWarning(error);
            props.spinner && (props.spinner.text = chalk_1.default.bold(warning)), this.silent || console.warn(chalk_1.default.yellow(warning));
          }
          return await this.handleInstallErrorAsync({ error, ...props });
        }
      }
      async addWithParametersAsync(names, parameters) {
        throw new Error("Unimplemented");
      }
      addAsync(names = []) {
        throw new Error("Unimplemented");
      }
      addDevAsync(names = []) {
        throw new Error("Unimplemented");
      }
      addGlobalAsync(names = []) {
        throw new Error("Unimplemented");
      }
      removeAsync(names = []) {
        throw new Error("Unimplemented");
      }
      removeDevAsync(names = []) {
        throw new Error("Unimplemented");
      }
      removeGlobalAsync(names = []) {
        throw new Error("Unimplemented");
      }
      async versionAsync() {
        let { stdout } = await (0, spawn_async_1.default)("pod", ["--version"], this.options);
        return stdout.trim();
      }
      async configAsync(key) {
        throw new Error("Unimplemented");
      }
      async removeLockfileAsync() {
        throw new Error("Unimplemented");
      }
      async uninstallAsync() {
        throw new Error("Unimplemented");
      }
      // Private
      async podRepoUpdateAsync() {
        try {
          await this._runAsync(["repo", "update"]);
        } catch (error) {
          throw error.message = error.message || (error.stderr ?? error.stdout), new CocoaPodsError("The command `pod install --repo-update` failed", "COMMAND_FAILED", error);
        }
      }
      // Exposed for testing
      async _runAsync(args) {
        this.silent || console.log(`> pod ${args.join(" ")}`);
        let promise = (0, spawn_async_1.default)("pod", [
          ...args,
          // Enables colors while collecting output.
          "--ansi"
        ], {
          // Add the cwd and other options to the spawn options.
          ...this.options,
          // We use pipe by default instead of inherit so that we can capture stderr/stdout and process it for errors.
          // This is particularly required for the `pod install --repo-update` error.
          // Later we'll also pipe the stdout/stderr to the terminal when silent is false,
          // currently this means we lose out on the ansi colors unless passing the `--ansi` flag to every command.
          stdio: "pipe"
        });
        return this.silent || promise.child.stdout && promise.child.stdout.pipe(process.stdout), await promise;
      }
    };
    exports2.CocoaPodsPackageManager = CocoaPodsPackageManager;
    function shouldPodRepoUpdate(errorOutput) {
      let output = errorOutput;
      return output.includes("pod repo update") || output.includes("--no-repo-update");
    }
    function getPodUpdateMessage(output) {
      let props = output.match(/run ['"`]pod update ([\w-_\d/]+)( --no-repo-update)?['"`] to apply changes/);
      return {
        updatePackage: (props == null ? void 0 : props[1]) ?? null,
        shouldUpdateRepo: !(props != null && props[2])
      };
    }
    exports2.getPodUpdateMessage = getPodUpdateMessage;
    function getPodRepoUpdateMessage(errorOutput) {
      let warningInfo = extractMissingDependencyError(errorOutput), brokenPackage = getPodUpdateMessage(errorOutput), message;
      return warningInfo ? message = `Couldn't install: ${warningInfo[1]} \xBB ${chalk_1.default.underline(warningInfo[0])}.` : brokenPackage != null && brokenPackage.updatePackage ? message = `Couldn't install: ${brokenPackage == null ? void 0 : brokenPackage.updatePackage}.` : message = "Couldn't install Pods.", message += " Updating the Pods project and trying again...", { message, ...brokenPackage };
    }
    exports2.getPodRepoUpdateMessage = getPodRepoUpdateMessage;
    function getImprovedPodInstallError(error, { cwd: cwd2 = process.cwd() }) {
      var _a2, _b;
      let errorOutput = error.output.join(os_1.default.EOL).trim();
      if (error.stdout.match(/No [`'"]Podfile[`'"] found in the project directory/))
        error.message = `No Podfile found in directory: ${cwd2}. Ensure CocoaPods is setup any try again.`;
      else if (shouldPodRepoUpdate(errorOutput)) {
        let warningInfo = extractMissingDependencyError(errorOutput), reason;
        warningInfo ? reason = `Couldn't install: ${warningInfo[1]} \xBB ${chalk_1.default.underline(warningInfo[0])}` : reason = "This is often due to native package versions mismatching";
        let solution;
        if (warningInfo != null && warningInfo[0] ? warningInfo[0].match(/^(?:@?expo|@?react)(-|\/)/) ? solution = `Ensure the node module "${warningInfo[0]}" is installed in your project, then run 'npx pod-install' to try again.` : solution = `Ensure the CocoaPod "${warningInfo[0]}" is installed in your project, then run 'npx pod-install' to try again.` : solution = "Try deleting the 'ios/Pods' folder or the 'ios/Podfile.lock' file and running 'npx pod-install' to resolve.", error.message = `${reason}. ${solution}`, error.stdout) {
          let cocoapodsDebugInfo = error.stdout.split(os_1.default.EOL), firstWarning = cocoapodsDebugInfo.findIndex((v) => v.startsWith("[!]"));
          if (firstWarning !== -1) {
            let warning = cocoapodsDebugInfo.slice(firstWarning).join(os_1.default.EOL);
            error.message += `

${chalk_1.default.gray(warning)}`;
          }
        }
        return new CocoaPodsError("Command `pod install --repo-update` failed.", "COMMAND_FAILED", error);
      } else {
        let stderr = error.stderr.trim(), usefulError = (_a2 = error.stdout.match(/\[!\]\s((?:.|\n)*)/)) == null ? void 0 : _a2[1];
        usefulError && ((_b = error.message) != null && _b.match(/pod exited with non-zero code: 1/) && (error.message = ""), stderr = null), error.message = [usefulError, error.message, stderr].filter(Boolean).join(`
`);
      }
      return new CocoaPodsError("Command `pod install` failed.", "COMMAND_FAILED", error);
    }
    exports2.getImprovedPodInstallError = getImprovedPodInstallError;
  }
});

// ../../node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "../../node_modules/js-tokens/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports2.matchToToken = function(match2) {
      var token = { type: "invalid", value: match2[0], closed: void 0 };
      return match2[1] ? (token.type = "string", token.closed = !!(match2[3] || match2[4])) : match2[5] ? token.type = "comment" : match2[6] ? (token.type = "comment", token.closed = !!match2[7]) : match2[8] ? token.type = "regex" : match2[9] ? token.type = "number" : match2[10] ? token.type = "name" : match2[11] ? token.type = "punctuator" : match2[12] && (token.type = "whitespace"), token;
    };
  }
});

// ../../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "../../node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.isIdentifierChar = isIdentifierChar;
    exports2.isIdentifierName = isIdentifierName;
    exports2.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        if (pos += set[i], pos > code)
          return !1;
        if (pos += set[i + 1], pos >= code)
          return !0;
      }
      return !1;
    }
    function isIdentifierStart(code) {
      return code < 65 ? code === 36 : code <= 90 ? !0 : code < 97 ? code === 95 : code <= 122 ? !0 : code <= 65535 ? code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      return code < 48 ? code === 36 : code < 58 ? !0 : code < 65 ? !1 : code <= 90 ? !0 : code < 97 ? code === 95 : code <= 122 ? !0 : code <= 65535 ? code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name) {
      let isFirst = !0;
      for (let i = 0; i < name.length; i++) {
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
          let trail = name.charCodeAt(++i);
          (trail & 64512) === 56320 && (cp = 65536 + ((cp & 1023) << 10) + (trail & 1023));
        }
        if (isFirst) {
          if (isFirst = !1, !isIdentifierStart(cp))
            return !1;
        } else if (!isIdentifierChar(cp))
          return !1;
      }
      return !isFirst;
    }
  }
});

// ../../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "../../node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.isKeyword = isKeyword;
    exports2.isReservedWord = isReservedWord;
    exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports2.isStrictBindReservedWord = isStrictBindReservedWord;
    exports2.isStrictReservedWord = isStrictReservedWord;
    var reservedWords2 = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    }, keywords = new Set(reservedWords2.keyword), reservedWordsStrictSet = new Set(reservedWords2.strict), reservedWordsStrictBindSet = new Set(reservedWords2.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
  }
});

// ../../node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    Object.defineProperty(exports2, "isIdentifierChar", {
      enumerable: !0,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports2, "isIdentifierName", {
      enumerable: !0,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports2, "isIdentifierStart", {
      enumerable: !0,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports2, "isKeyword", {
      enumerable: !0,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports2, "isReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictReservedWord", {
      enumerable: !0,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier(), _keyword = require_keyword();
  }
});

// ../../node_modules/@babel/highlight/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str != "string")
        throw new TypeError("Expected a string");
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name2(), reverseKeywords = {};
    for (key in cssKeywords)
      cssKeywords.hasOwnProperty(key) && (reverseKeywords[cssKeywords[key]] = key);
    var key, convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert)
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model]))
          throw new Error("missing channels property: " + model);
        if (!("labels" in convert[model]))
          throw new Error("missing channel labels property: " + model);
        if (convert[model].labels.length !== convert[model].channels)
          throw new Error("channel and label counts mismatch: " + model);
        channels = convert[model].channels, labels = convert[model].labels, delete convert[model].channels, delete convert[model].labels, Object.defineProperty(convert[model], "channels", { value: channels }), Object.defineProperty(convert[model], "labels", { value: labels });
      }
    var channels, labels, model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, l;
      return max === min ? h = 0 : r === max ? h = (g - b) / delta : g === max ? h = 2 + (b - r) / delta : b === max && (h = 4 + (r - g) / delta), h = Math.min(h * 60, 360), h < 0 && (h += 360), l = (min + max) / 2, max === min ? s = 0 : l <= 0.5 ? s = delta / (max + min) : s = delta / (2 - max - min), [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif, gdif, bdif, h, s, r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, v = Math.max(r, g, b), diff = v - Math.min(r, g, b), diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      return diff === 0 ? h = s = 0 : (s = diff / v, rdif = diffc(r), gdif = diffc(g), bdif = diffc(b), r === v ? h = bdif - gdif : g === v ? h = 1 / 3 + rdif - bdif : b === v && (h = 2 / 3 + gdif - rdif), h < 0 ? h += 1 : h > 1 && (h -= 1)), [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0], g = rgb[1], b = rgb[2], h = convert.rgb.hsl(rgb)[0], w = 1 / 255 * Math.min(r, Math.min(g, b));
      return b = 1 - 1 / 255 * Math.max(r, Math.max(g, b)), [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, c, m, y, k;
      return k = Math.min(1 - r, 1 - g, 1 - b), c = (1 - r - k) / (1 - k) || 0, m = (1 - g - k) / (1 - k) || 0, y = (1 - b - k) / (1 - k) || 0, [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed)
        return reversed;
      var currentClosestDistance = 1 / 0, currentClosestKeyword;
      for (var keyword in cssKeywords)
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword], distance = comparativeDistance(rgb, value);
          distance < currentClosestDistance && (currentClosestDistance = distance, currentClosestKeyword = keyword);
        }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92, b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805, y = r * 0.2126 + g * 0.7152 + b * 0.0722, z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb), x = xyz[0], y = xyz[1], z = xyz[2], l, a, b;
      return x /= 95.047, y /= 100, z /= 108.883, x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116, y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116, z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116, l = 116 * y - 16, a = 500 * (x - y), b = 200 * (y - z), [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val;
      if (s === 0)
        return val = l * 255, [val, val, val];
      l < 0.5 ? t2 = l * (1 + s) : t2 = l + s - l * s, t1 = 2 * l - t2, rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++)
        t3 = h + 1 / 3 * -(i - 1), t3 < 0 && t3++, t3 > 1 && t3--, 6 * t3 < 1 ? val = t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? val = t2 : 3 * t3 < 2 ? val = t1 + (t2 - t1) * (2 / 3 - t3) * 6 : val = t1, rgb[i] = val * 255;
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0], s = hsl[1] / 100, l = hsl[2] / 100, smin = s, lmin = Math.max(l, 0.01), sv, v;
      return l *= 2, s *= l <= 1 ? l : 2 - l, smin *= lmin <= 1 ? lmin : 2 - lmin, v = (l + s) / 2, sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s), [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60, s = hsv[1] / 100, v = hsv[2] / 100, hi = Math.floor(h) % 6, f = h - Math.floor(h), p = 255 * v * (1 - s), q = 255 * v * (1 - s * f), t = 255 * v * (1 - s * (1 - f));
      switch (v *= 255, hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0], s = hsv[1] / 100, v = hsv[2] / 100, vmin = Math.max(v, 0.01), lmin, sl, l;
      return l = (2 - s) * v, lmin = (2 - s) * vmin, sl = s * vmin, sl /= lmin <= 1 ? lmin : 2 - lmin, sl = sl || 0, l /= 2, [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360, wh = hwb[1] / 100, bl = hwb[2] / 100, ratio = wh + bl, i, v, f, n;
      ratio > 1 && (wh /= ratio, bl /= ratio), i = Math.floor(6 * h), v = 1 - bl, f = 6 * h - i, i & 1 && (f = 1 - f), n = wh + f * (v - wh);
      var r, g, b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v, g = n, b = wh;
          break;
        case 1:
          r = n, g = v, b = wh;
          break;
        case 2:
          r = wh, g = v, b = n;
          break;
        case 3:
          r = wh, g = n, b = v;
          break;
        case 4:
          r = n, g = wh, b = v;
          break;
        case 5:
          r = v, g = wh, b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100, m = cmyk[1] / 100, y = cmyk[2] / 100, k = cmyk[3] / 100, r, g, b;
      return r = 1 - Math.min(1, c * (1 - k) + k), g = 1 - Math.min(1, m * (1 - k) + k), b = 1 - Math.min(1, y * (1 - k) + k), [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100, y = xyz[1] / 100, z = xyz[2] / 100, r, g, b;
      return r = x * 3.2406 + y * -1.5372 + z * -0.4986, g = x * -0.9689 + y * 1.8758 + z * 0.0415, b = x * 0.0557 + y * -0.204 + z * 1.057, r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92, g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92, b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92, r = Math.min(Math.max(0, r), 1), g = Math.min(Math.max(0, g), 1), b = Math.min(Math.max(0, b), 1), [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0], y = xyz[1], z = xyz[2], l, a, b;
      return x /= 95.047, y /= 100, z /= 108.883, x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116, y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116, z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116, l = 116 * y - 16, a = 500 * (x - y), b = 200 * (y - z), [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0], a = lab[1], b = lab[2], x, y, z;
      y = (l + 16) / 116, x = a / 500 + y, z = y - b / 200;
      var y2 = Math.pow(y, 3), x2 = Math.pow(x, 3), z2 = Math.pow(z, 3);
      return y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787, x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787, z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787, x *= 95.047, y *= 100, z *= 108.883, [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0], a = lab[1], b = lab[2], hr, h, c;
      return hr = Math.atan2(b, a), h = hr * 360 / 2 / Math.PI, h < 0 && (h += 360), c = Math.sqrt(a * a + b * b), [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0], c = lch[1], h = lch[2], a, b, hr;
      return hr = h / 360 * 2 * Math.PI, a = c * Math.cos(hr), b = c * Math.sin(hr), [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0], g = args[1], b = args[2], value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      if (value = Math.round(value / 50), value === 0)
        return 30;
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      return value === 2 && (ansi += 60), ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0], g = args[1], b = args[2];
      if (r === g && g === b)
        return r < 8 ? 16 : r > 248 ? 231 : Math.round((r - 8) / 247 * 24) + 232;
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7)
        return args > 50 && (color += 3.5), color = color / 10.5 * 255, [color, color, color];
      var mult = (~~(args > 50) + 1) * 0.5, r = (color & 1) * mult * 255, g = (color >> 1 & 1) * mult * 255, b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem, r = Math.floor(args / 36) / 5 * 255, g = Math.floor((rem = args % 36) / 6) / 5 * 255, b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255), string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match2)
        return [0, 0, 0];
      var colorString = match2[0];
      match2[0].length === 3 && (colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join(""));
      var integer = parseInt(colorString, 16), r = integer >> 16 & 255, g = integer >> 8 & 255, b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, max = Math.max(Math.max(r, g), b), min = Math.min(Math.min(r, g), b), chroma = max - min, grayscale, hue;
      return chroma < 1 ? grayscale = min / (1 - chroma) : grayscale = 0, chroma <= 0 ? hue = 0 : max === r ? hue = (g - b) / chroma % 6 : max === g ? hue = 2 + (b - r) / chroma : hue = 4 + (r - g) / chroma + 4, hue /= 6, hue %= 1, [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100, l = hsl[2] / 100, c = 1, f = 0;
      return l < 0.5 ? c = 2 * s * l : c = 2 * s * (1 - l), c < 1 && (f = (l - 0.5 * c) / (1 - c)), [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100, v = hsv[2] / 100, c = s * v, f = 0;
      return c < 1 && (f = (v - c) / (1 - c)), [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360, c = hcg[1] / 100, g = hcg[2] / 100;
      if (c === 0)
        return [g * 255, g * 255, g * 255];
      var pure = [0, 0, 0], hi = h % 1 * 6, v = hi % 1, w = 1 - v, mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1, pure[1] = v, pure[2] = 0;
          break;
        case 1:
          pure[0] = w, pure[1] = 1, pure[2] = 0;
          break;
        case 2:
          pure[0] = 0, pure[1] = 1, pure[2] = v;
          break;
        case 3:
          pure[0] = 0, pure[1] = w, pure[2] = 1;
          break;
        case 4:
          pure[0] = v, pure[1] = 0, pure[2] = 1;
          break;
        default:
          pure[0] = 1, pure[1] = 0, pure[2] = w;
      }
      return mg = (1 - c) * g, [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100, g = hcg[2] / 100, v = c + g * (1 - c), f = 0;
      return v > 0 && (f = c / v), [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100, g = hcg[2] / 100, l = g * (1 - c) + 0.5 * c, s = 0;
      return l > 0 && l < 0.5 ? s = c / (2 * l) : l >= 0.5 && l < 1 && (s = c / (2 * (1 - l))), [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100, g = hcg[2] / 100, v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100, b = hwb[2] / 100, v = 1 - b, c = v - w, g = 0;
      return c < 1 && (g = (v - c) / (1 - c)), [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255, integer = (val << 16) + (val << 8) + val, string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions2();
    function buildGraph() {
      for (var graph = {}, models = Object.keys(conversions), len = models.length, i = 0; i < len; i++)
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph(), queue = [fromModel];
      for (graph[fromModel].distance = 0; queue.length; )
        for (var current = queue.pop(), adjacents = Object.keys(conversions[current]), len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i], node = graph[adjacent];
          node.distance === -1 && (node.distance = graph[current].distance + 1, node.parent = current, queue.unshift(adjacent));
        }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      for (var path6 = [graph[toModel].parent, toModel], fn = conversions[graph[toModel].parent][toModel], cur = graph[toModel].parent; graph[cur].parent; )
        path6.unshift(graph[cur].parent), fn = link(conversions[graph[cur].parent][cur], fn), cur = graph[cur].parent;
      return fn.conversion = path6, fn;
    }
    module2.exports = function(fromModel) {
      for (var graph = deriveBFS(fromModel), conversion = {}, models = Object.keys(graph), len = models.length, i = 0; i < len; i++) {
        var toModel = models[i], node = graph[toModel];
        node.parent !== null && (conversion[toModel] = wrapConversion(toModel, graph));
      }
      return conversion;
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/color-convert/index.js
var require_color_convert2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions2(), route = require_route2(), convert = {}, models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        return args == null ? args : (arguments.length > 1 && (args = Array.prototype.slice.call(arguments)), fn(args));
      };
      return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args == null)
          return args;
        arguments.length > 1 && (args = Array.prototype.slice.call(arguments));
        var result = fn(args);
        if (typeof result == "object")
          for (var len = result.length, i = 0; i < len; i++)
            result[i] = Math.round(result[i]);
        return result;
      };
      return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {}, Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels }), Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel), routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn), convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// ../../node_modules/@babel/highlight/node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var colorConvert = require_color_convert2(), wrapAnsi162 = (fn, offset) => function() {
      return `\x1B[${fn.apply(colorConvert, arguments) + offset}m`;
    }, wrapAnsi2562 = (fn, offset) => function() {
      let code = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};5;${code}m`;
    }, wrapAnsi16m2 = (fn, offset) => function() {
      let rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles2() {
      let codes2 = /* @__PURE__ */ new Map(), styles3 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles3.color.grey = styles3.color.gray;
      for (let groupName of Object.keys(styles3)) {
        let group = styles3[groupName];
        for (let styleName of Object.keys(group)) {
          let style = group[styleName];
          styles3[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          }, group[styleName] = styles3[styleName], codes2.set(style[0], style[1]);
        }
        Object.defineProperty(styles3, groupName, {
          value: group,
          enumerable: !1
        }), Object.defineProperty(styles3, "codes", {
          value: codes2,
          enumerable: !1
        });
      }
      let ansi2ansi = (n) => n, rgb2rgb = (r, g, b) => [r, g, b];
      styles3.color.close = "\x1B[39m", styles3.bgColor.close = "\x1B[49m", styles3.color.ansi = {
        ansi: wrapAnsi162(ansi2ansi, 0)
      }, styles3.color.ansi256 = {
        ansi256: wrapAnsi2562(ansi2ansi, 0)
      }, styles3.color.ansi16m = {
        rgb: wrapAnsi16m2(rgb2rgb, 0)
      }, styles3.bgColor.ansi = {
        ansi: wrapAnsi162(ansi2ansi, 10)
      }, styles3.bgColor.ansi256 = {
        ansi256: wrapAnsi2562(ansi2ansi, 10)
      }, styles3.bgColor.ansi16m = {
        rgb: wrapAnsi16m2(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] != "object")
          continue;
        let suite = colorConvert[key];
        key === "ansi16" && (key = "ansi"), "ansi16" in suite && (styles3.color.ansi[key] = wrapAnsi162(suite.ansi16, 0), styles3.bgColor.ansi[key] = wrapAnsi162(suite.ansi16, 10)), "ansi256" in suite && (styles3.color.ansi256[key] = wrapAnsi2562(suite.ansi256, 0), styles3.bgColor.ansi256[key] = wrapAnsi2562(suite.ansi256, 10)), "rgb" in suite && (styles3.color.ansi16m[key] = wrapAnsi16m2(suite.rgb, 0), styles3.bgColor.ansi16m[key] = wrapAnsi16m2(suite.rgb, 10));
      }
      return styles3;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: !0,
      get: assembleStyles2
    });
  }
});

// ../../node_modules/@babel/highlight/node_modules/has-flag/index.js
var require_has_flag2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv2) => {
      argv2 = argv2 || process.argv;
      let prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--", pos = argv2.indexOf(prefix + flag), terminatorPos = argv2.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? !0 : pos < terminatorPos);
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/supports-color/index.js
var require_supports_color2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os2 = require("os"), hasFlag2 = require_has_flag2(), env2 = process.env, forceColor;
    hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") ? forceColor = !1 : (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) && (forceColor = !0);
    "FORCE_COLOR" in env2 && (forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0);
    function translateLevel2(level) {
      return level === 0 ? !1 : {
        level,
        hasBasic: !0,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor2(stream2) {
      if (forceColor === !1)
        return 0;
      if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor"))
        return 3;
      if (hasFlag2("color=256"))
        return 2;
      if (stream2 && !stream2.isTTY && forceColor !== !0)
        return 0;
      let min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        let osRelease = os2.release().split(".");
        return Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in env2)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env2) || env2.CI_NAME === "codeship" ? 1 : min;
      if ("TEAMCITY_VERSION" in env2)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      if (env2.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in env2) {
        let version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(env2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM) || "COLORTERM" in env2 ? 1 : (env2.TERM === "dumb", min);
    }
    function getSupportLevel(stream2) {
      let level = supportsColor2(stream2);
      return translateLevel2(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/chalk/templates.js
var require_templates2 = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/chalk/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, ESCAPES = /* @__PURE__ */ new Map([
      ["n", `
`],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c) {
      return c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3 ? String.fromCharCode(parseInt(c.slice(1), 16)) : ESCAPES.get(c) || c;
    }
    function parseArguments(name, args) {
      let results = [], chunks = args.trim().split(/\s*,\s*/g), matches;
      for (let chunk of chunks)
        if (!isNaN(chunk))
          results.push(Number(chunk));
        else if (matches = chunk.match(STRING_REGEX))
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, chr) => escape2 ? unescape2(escape2) : chr));
        else
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      let results = [], matches;
      for (; (matches = STYLE_REGEX.exec(style)) !== null; ) {
        let name = matches[1];
        if (matches[2]) {
          let args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else
          results.push([name]);
      }
      return results;
    }
    function buildStyle(chalk12, styles3) {
      let enabled = {};
      for (let layer of styles3)
        for (let style of layer.styles)
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
      let current = chalk12;
      for (let styleName of Object.keys(enabled))
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current))
            throw new Error(`Unknown Chalk style: ${styleName}`);
          enabled[styleName].length > 0 ? current = current[styleName].apply(current, enabled[styleName]) : current = current[styleName];
        }
      return current;
    }
    module2.exports = (chalk12, tmp) => {
      let styles3 = [], chunks = [], chunk = [];
      if (tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar)
          chunk.push(unescape2(escapeChar));
        else if (style) {
          let str = chunk.join("");
          chunk = [], chunks.push(styles3.length === 0 ? str : buildStyle(chalk12, styles3)(str)), styles3.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles3.length === 0)
            throw new Error("Found extraneous } in Chalk template literal");
          chunks.push(buildStyle(chalk12, styles3)(chunk.join(""))), chunk = [], styles3.pop();
        } else
          chunk.push(chr);
      }), chunks.push(chunk.join("")), styles3.length > 0) {
        let errMsg = `Chalk template literal is missing ${styles3.length} closing bracket${styles3.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// ../../node_modules/@babel/highlight/node_modules/chalk/index.js
var require_chalk = __commonJS({
  "../../node_modules/@babel/highlight/node_modules/chalk/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp(), ansiStyles2 = require_ansi_styles2(), stdoutColor2 = require_supports_color2().stdout, template = require_templates2(), isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm"), levelMapping2 = ["ansi", "ansi", "ansi256", "ansi16m"], skipModels = /* @__PURE__ */ new Set(["gray"]), styles3 = /* @__PURE__ */ Object.create(null);
    function applyOptions2(obj, options) {
      options = options || {};
      let scLevel = stdoutColor2 ? stdoutColor2.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level, obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        let chalk12 = {};
        return applyOptions2(chalk12, options), chalk12.template = function() {
          let args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk12.template].concat(args));
        }, Object.setPrototypeOf(chalk12, Chalk.prototype), Object.setPrototypeOf(chalk12.template, chalk12), chalk12.template.constructor = Chalk, chalk12.template;
      }
      applyOptions2(this, options);
    }
    isSimpleWindowsTerm && (ansiStyles2.blue.open = "\x1B[94m");
    for (let key of Object.keys(ansiStyles2))
      ansiStyles2[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles2[key].close), "g"), styles3[key] = {
        get() {
          let codes2 = ansiStyles2[key];
          return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, key);
        }
      };
    styles3.visible = {
      get() {
        return build.call(this, this._styles || [], !0, "visible");
      }
    };
    ansiStyles2.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles2.color.close), "g");
    for (let model of Object.keys(ansiStyles2.color.ansi))
      skipModels.has(model) || (styles3[model] = {
        get() {
          let level = this.level;
          return function() {
            let codes2 = {
              open: ansiStyles2.color[levelMapping2[level]][model].apply(null, arguments),
              close: ansiStyles2.color.close,
              closeRe: ansiStyles2.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, model);
          };
        }
      });
    ansiStyles2.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles2.bgColor.close), "g");
    for (let model of Object.keys(ansiStyles2.bgColor.ansi)) {
      if (skipModels.has(model))
        continue;
      let bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles3[bgModel] = {
        get() {
          let level = this.level;
          return function() {
            let codes2 = {
              open: ansiStyles2.bgColor[levelMapping2[level]][model].apply(null, arguments),
              close: ansiStyles2.bgColor.close,
              closeRe: ansiStyles2.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, model);
          };
        }
      };
    }
    var proto2 = Object.defineProperties(() => {
    }, styles3);
    function build(_styles, _empty, key) {
      let builder = function() {
        return applyStyle2.apply(builder, arguments);
      };
      builder._styles = _styles, builder._empty = _empty;
      let self = this;
      return Object.defineProperty(builder, "level", {
        enumerable: !0,
        get() {
          return self.level;
        },
        set(level) {
          self.level = level;
        }
      }), Object.defineProperty(builder, "enabled", {
        enumerable: !0,
        get() {
          return self.enabled;
        },
        set(enabled) {
          self.enabled = enabled;
        }
      }), builder.hasGrey = this.hasGrey || key === "gray" || key === "grey", builder.__proto__ = proto2, builder;
    }
    function applyStyle2() {
      let args = arguments, argsLen = args.length, str = String(arguments[0]);
      if (argsLen === 0)
        return "";
      if (argsLen > 1)
        for (let a = 1; a < argsLen; a++)
          str += " " + args[a];
      if (!this.enabled || this.level <= 0 || !str)
        return this._empty ? "" : str;
      let originalDim = ansiStyles2.dim.open;
      isSimpleWindowsTerm && this.hasGrey && (ansiStyles2.dim.open = "");
      for (let code of this._styles.slice().reverse())
        str = code.open + str.replace(code.closeRe, code.open) + code.close, str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      return ansiStyles2.dim.open = originalDim, str;
    }
    function chalkTag(chalk12, strings) {
      if (!Array.isArray(strings))
        return [].slice.call(arguments, 1).join(" ");
      let args = [].slice.call(arguments, 2), parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++)
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&")), parts.push(String(strings.raw[i]));
      return template(chalk12, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles3);
    module2.exports = Chalk();
    module2.exports.supportsColor = stdoutColor2;
    module2.exports.default = module2.exports;
  }
});

// ../../node_modules/@babel/highlight/lib/index.js
var require_lib5 = __commonJS({
  "../../node_modules/@babel/highlight/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.default = highlight;
    exports2.shouldHighlight = shouldHighlight;
    var _jsTokens = require_js_tokens(), _helperValidatorIdentifier = require_lib4(), _chalk = _interopRequireWildcard(require_chalk(), !0);
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap != "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap(), cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule)
        return obj;
      if (obj === null || typeof obj != "object" && typeof obj != "function")
        return { default: obj };
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj))
        return cache2.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache2 && cache2.set(obj, newObj), newObj;
    }
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    function getDefs(chalk12) {
      return {
        keyword: chalk12.cyan,
        capitalized: chalk12.yellow,
        jsxIdentifier: chalk12.yellow,
        punctuator: chalk12.yellow,
        number: chalk12.magenta,
        string: chalk12.green,
        regex: chalk12.magenta,
        comment: chalk12.grey,
        invalid: chalk12.white.bgRed.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/, BRACKET = /^[()[\]{}]$/, tokenize;
    {
      let JSX_TAG = /^[a-z][\w-]*$/i, getTokenType = function(token, offset, text) {
        if (token.type === "name") {
          if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, !0) || sometimesKeywords.has(token.value))
            return "keyword";
          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</"))
            return "jsxIdentifier";
          if (token.value[0] !== token.value[0].toLowerCase())
            return "capitalized";
        }
        return token.type === "punctuator" && BRACKET.test(token.value) ? "bracket" : token.type === "invalid" && (token.value === "@" || token.value === "#") ? "punctuator" : token.type;
      };
      tokenize = function* (text) {
        let match2;
        for (; match2 = _jsTokens.default.exec(text); ) {
          let token = _jsTokens.matchToToken(match2);
          yield {
            type: getTokenType(token, match2.index, text),
            value: token.value
          };
        }
      };
    }
    function highlightTokens(defs, text) {
      let highlighted = "";
      for (let {
        type,
        value
      } of tokenize(text)) {
        let colorize = defs[type];
        colorize ? highlighted += value.split(NEWLINE).map((str) => colorize(str)).join(`
`) : highlighted += value;
      }
      return highlighted;
    }
    function shouldHighlight(options) {
      return _chalk.default.level > 0 || options.forceColor;
    }
    var chalkWithForcedColor;
    function getChalk(forceColor) {
      if (forceColor) {
        var _chalkWithForcedColor;
        return (_chalkWithForcedColor = chalkWithForcedColor) != null || (chalkWithForcedColor = new _chalk.default.constructor({
          enabled: !0,
          level: 1
        })), chalkWithForcedColor;
      }
      return _chalk.default;
    }
    exports2.getChalk = (options) => getChalk(options.forceColor);
    function highlight(code, options = {}) {
      if (code !== "" && shouldHighlight(options)) {
        let defs = getDefs(getChalk(options.forceColor));
        return highlightTokens(defs, code);
      } else
        return code;
    }
  }
});

// ../../node_modules/@expo/json-file/node_modules/@babel/code-frame/lib/index.js
var require_lib6 = __commonJS({
  "../../node_modules/@expo/json-file/node_modules/@babel/code-frame/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: !0
    });
    exports2.codeFrameColumns = codeFrameColumns;
    exports2.default = _default;
    var _highlight = _interopRequireWildcard(require_lib5());
    function _getRequireWildcardCache() {
      if (typeof WeakMap != "function")
        return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      return _getRequireWildcardCache = function() {
        return cache2;
      }, cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule)
        return obj;
      if (obj === null || typeof obj != "object" && typeof obj != "function")
        return { default: obj };
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj))
        return cache2.get(obj);
      var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj)
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
      return newObj.default = obj, cache2 && cache2.set(obj, newObj), newObj;
    }
    var deprecationWarningShown = !1;
    function getDefs(chalk12) {
      return {
        gutter: chalk12.grey,
        marker: chalk12.red.bold,
        message: chalk12.red.bold
      };
    }
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      let startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start), endLoc = Object.assign({}, startLoc, loc.end), {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {}, startLine = startLoc.line, startColumn = startLoc.column, endLine = endLoc.line, endColumn = endLoc.column, start = Math.max(startLine - (linesAbove + 1), 0), end = Math.min(source.length, endLine + linesBelow);
      startLine === -1 && (start = 0), endLine === -1 && (end = source.length);
      let lineDiff = endLine - startLine, markerLines = {};
      if (lineDiff)
        for (let i = 0; i <= lineDiff; i++) {
          let lineNumber = i + startLine;
          if (!startColumn)
            markerLines[lineNumber] = !0;
          else if (i === 0) {
            let sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff)
            markerLines[lineNumber] = [0, endColumn];
          else {
            let sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      else
        startColumn === endColumn ? startColumn ? markerLines[startLine] = [startColumn, 0] : markerLines[startLine] = !0 : markerLines[startLine] = [startColumn, endColumn - startColumn];
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      let highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts), chalk12 = (0, _highlight.getChalk)(opts), defs = getDefs(chalk12), maybeHighlight = (chalkFn, string) => highlighted ? chalkFn(string) : string, lines = rawLines.split(NEWLINE), {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts), hasColumns = loc.start && typeof loc.start.column == "number", numberMaxWidth = String(end).length, frame = (highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines).split(NEWLINE).slice(start, end).map((line, index) => {
        let number = start + 1 + index, gutter = ` ${` ${number}`.slice(-numberMaxWidth)} | `, hasMarker = markerLines[number], lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            let markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " "), numberOfMarkers = hasMarker[1] || 1;
            markerLine = [`
 `, maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join(""), lastMarkerLine && opts.message && (markerLine += " " + maybeHighlight(defs.message, opts.message));
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line, markerLine].join("");
        } else
          return ` ${maybeHighlight(defs.gutter, gutter)}${line}`;
      }).join(`
`);
      return opts.message && !hasColumns && (frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`), highlighted ? chalk12.reset(frame) : frame;
    }
    function _default(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = !0;
        let message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning)
          process.emitWarning(message, "DeprecationWarning");
        else {
          let deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning", console.warn(new Error(message));
        }
      }
      return colNumber = Math.max(colNumber, 0), codeFrameColumns(rawLines, {
        start: {
          column: colNumber,
          line: lineNumber
        }
      }, opts);
    }
  }
});

// ../../node_modules/json5/lib/unicode.js
var require_unicode = __commonJS({
  "../../node_modules/json5/lib/unicode.js"(exports2, module2) {
    module2.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    module2.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
    module2.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
  }
});

// ../../node_modules/json5/lib/util.js
var require_util4 = __commonJS({
  "../../node_modules/json5/lib/util.js"(exports2, module2) {
    var unicode = require_unicode();
    module2.exports = {
      isSpaceSeparator(c) {
        return typeof c == "string" && unicode.Space_Separator.test(c);
      },
      isIdStartChar(c) {
        return typeof c == "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "$" || c === "_" || unicode.ID_Start.test(c));
      },
      isIdContinueChar(c) {
        return typeof c == "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "$" || c === "_" || c === "\u200C" || c === "\u200D" || unicode.ID_Continue.test(c));
      },
      isDigit(c) {
        return typeof c == "string" && /[0-9]/.test(c);
      },
      isHexDigit(c) {
        return typeof c == "string" && /[0-9A-Fa-f]/.test(c);
      }
    };
  }
});

// ../../node_modules/json5/lib/parse.js
var require_parse5 = __commonJS({
  "../../node_modules/json5/lib/parse.js"(exports2, module2) {
    var util = require_util4(), source, parseState, stack, pos, line, column, token, key, root;
    module2.exports = function(text, reviver) {
      source = String(text), parseState = "start", stack = [], pos = 0, line = 1, column = 0, token = void 0, key = void 0, root = void 0;
      do
        token = lex(), parseStates[parseState]();
      while (token.type !== "eof");
      return typeof reviver == "function" ? internalize({ "": root }, "", reviver) : root;
    };
    function internalize(holder, name, reviver) {
      let value = holder[name];
      if (value != null && typeof value == "object")
        if (Array.isArray(value))
          for (let i = 0; i < value.length; i++) {
            let key2 = String(i), replacement = internalize(value, key2, reviver);
            replacement === void 0 ? delete value[key2] : Object.defineProperty(value, key2, {
              value: replacement,
              writable: !0,
              enumerable: !0,
              configurable: !0
            });
          }
        else
          for (let key2 in value) {
            let replacement = internalize(value, key2, reviver);
            replacement === void 0 ? delete value[key2] : Object.defineProperty(value, key2, {
              value: replacement,
              writable: !0,
              enumerable: !0,
              configurable: !0
            });
          }
      return reviver.call(holder, name, value);
    }
    var lexState, buffer, doubleQuote, sign, c;
    function lex() {
      for (lexState = "default", buffer = "", doubleQuote = !1, sign = 1; ; ) {
        c = peek();
        let token2 = lexStates[lexState]();
        if (token2)
          return token2;
      }
    }
    function peek() {
      if (source[pos])
        return String.fromCodePoint(source.codePointAt(pos));
    }
    function read() {
      let c2 = peek();
      return c2 === `
` ? (line++, column = 0) : c2 ? column += c2.length : column++, c2 && (pos += c2.length), c2;
    }
    var lexStates = {
      default() {
        switch (c) {
          case "	":
          case "\v":
          case "\f":
          case " ":
          case "\xA0":
          case "\uFEFF":
          case `
`:
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            return;
          case "/":
            read(), lexState = "comment";
            return;
          case void 0:
            return read(), newToken("eof");
        }
        if (util.isSpaceSeparator(c)) {
          read();
          return;
        }
        return lexStates[parseState]();
      },
      comment() {
        switch (c) {
          case "*":
            read(), lexState = "multiLineComment";
            return;
          case "/":
            read(), lexState = "singleLineComment";
            return;
        }
        throw invalidChar(read());
      },
      multiLineComment() {
        switch (c) {
          case "*":
            read(), lexState = "multiLineCommentAsterisk";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
      },
      multiLineCommentAsterisk() {
        switch (c) {
          case "*":
            read();
            return;
          case "/":
            read(), lexState = "default";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read(), lexState = "multiLineComment";
      },
      singleLineComment() {
        switch (c) {
          case `
`:
          case "\r":
          case "\u2028":
          case "\u2029":
            read(), lexState = "default";
            return;
          case void 0:
            return read(), newToken("eof");
        }
        read();
      },
      value() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
          case "n":
            return read(), literal("ull"), newToken("null", null);
          case "t":
            return read(), literal("rue"), newToken("boolean", !0);
          case "f":
            return read(), literal("alse"), newToken("boolean", !1);
          case "-":
          case "+":
            read() === "-" && (sign = -1), lexState = "sign";
            return;
          case ".":
            buffer = read(), lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read(), lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read(), lexState = "decimalInteger";
            return;
          case "I":
            return read(), literal("nfinity"), newToken("numeric", 1 / 0);
          case "N":
            return read(), literal("aN"), newToken("numeric", NaN);
          case '"':
          case "'":
            doubleQuote = read() === '"', buffer = "", lexState = "string";
            return;
        }
        throw invalidChar(read());
      },
      identifierNameStartEscape() {
        if (c !== "u")
          throw invalidChar(read());
        read();
        let u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
            break;
          default:
            if (!util.isIdStartChar(u))
              throw invalidIdentifier();
            break;
        }
        buffer += u, lexState = "identifierName";
      },
      identifierName() {
        switch (c) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read();
            return;
          case "\\":
            read(), lexState = "identifierNameEscape";
            return;
        }
        if (util.isIdContinueChar(c)) {
          buffer += read();
          return;
        }
        return newToken("identifier", buffer);
      },
      identifierNameEscape() {
        if (c !== "u")
          throw invalidChar(read());
        read();
        let u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;
          default:
            if (!util.isIdContinueChar(u))
              throw invalidIdentifier();
            break;
        }
        buffer += u, lexState = "identifierName";
      },
      sign() {
        switch (c) {
          case ".":
            buffer = read(), lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read(), lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read(), lexState = "decimalInteger";
            return;
          case "I":
            return read(), literal("nfinity"), newToken("numeric", sign * (1 / 0));
          case "N":
            return read(), literal("aN"), newToken("numeric", NaN);
        }
        throw invalidChar(read());
      },
      zero() {
        switch (c) {
          case ".":
            buffer += read(), lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read(), lexState = "decimalExponent";
            return;
          case "x":
          case "X":
            buffer += read(), lexState = "hexadecimal";
            return;
        }
        return newToken("numeric", sign * 0);
      },
      decimalInteger() {
        switch (c) {
          case ".":
            buffer += read(), lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read(), lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalPointLeading() {
        if (util.isDigit(c)) {
          buffer += read(), lexState = "decimalFraction";
          return;
        }
        throw invalidChar(read());
      },
      decimalPoint() {
        switch (c) {
          case "e":
          case "E":
            buffer += read(), lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read(), lexState = "decimalFraction";
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalFraction() {
        switch (c) {
          case "e":
          case "E":
            buffer += read(), lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalExponent() {
        switch (c) {
          case "+":
          case "-":
            buffer += read(), lexState = "decimalExponentSign";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read(), lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentSign() {
        if (util.isDigit(c)) {
          buffer += read(), lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentInteger() {
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      hexadecimal() {
        if (util.isHexDigit(c)) {
          buffer += read(), lexState = "hexadecimalInteger";
          return;
        }
        throw invalidChar(read());
      },
      hexadecimalInteger() {
        if (util.isHexDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      string() {
        switch (c) {
          case "\\":
            read(), buffer += escape2();
            return;
          case '"':
            if (doubleQuote)
              return read(), newToken("string", buffer);
            buffer += read();
            return;
          case "'":
            if (!doubleQuote)
              return read(), newToken("string", buffer);
            buffer += read();
            return;
          case `
`:
          case "\r":
            throw invalidChar(read());
          case "\u2028":
          case "\u2029":
            separatorChar(c);
            break;
          case void 0:
            throw invalidChar(read());
        }
        buffer += read();
      },
      start() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
        }
        lexState = "value";
      },
      beforePropertyName() {
        switch (c) {
          case "$":
          case "_":
            buffer = read(), lexState = "identifierName";
            return;
          case "\\":
            read(), lexState = "identifierNameStartEscape";
            return;
          case "}":
            return newToken("punctuator", read());
          case '"':
          case "'":
            doubleQuote = read() === '"', lexState = "string";
            return;
        }
        if (util.isIdStartChar(c)) {
          buffer += read(), lexState = "identifierName";
          return;
        }
        throw invalidChar(read());
      },
      afterPropertyName() {
        if (c === ":")
          return newToken("punctuator", read());
        throw invalidChar(read());
      },
      beforePropertyValue() {
        lexState = "value";
      },
      afterPropertyValue() {
        switch (c) {
          case ",":
          case "}":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforeArrayValue() {
        if (c === "]")
          return newToken("punctuator", read());
        lexState = "value";
      },
      afterArrayValue() {
        switch (c) {
          case ",":
          case "]":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      end() {
        throw invalidChar(read());
      }
    };
    function newToken(type, value) {
      return {
        type,
        value,
        line,
        column
      };
    }
    function literal(s) {
      for (let c2 of s) {
        if (peek() !== c2)
          throw invalidChar(read());
        read();
      }
    }
    function escape2() {
      switch (peek()) {
        case "b":
          return read(), "\b";
        case "f":
          return read(), "\f";
        case "n":
          return read(), `
`;
        case "r":
          return read(), "\r";
        case "t":
          return read(), "	";
        case "v":
          return read(), "\v";
        case "0":
          if (read(), util.isDigit(peek()))
            throw invalidChar(read());
          return "\0";
        case "x":
          return read(), hexEscape();
        case "u":
          return read(), unicodeEscape();
        case `
`:
        case "\u2028":
        case "\u2029":
          return read(), "";
        case "\r":
          return read(), peek() === `
` && read(), "";
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          throw invalidChar(read());
        case void 0:
          throw invalidChar(read());
      }
      return read();
    }
    function hexEscape() {
      let buffer2 = "", c2 = peek();
      if (!util.isHexDigit(c2) || (buffer2 += read(), c2 = peek(), !util.isHexDigit(c2)))
        throw invalidChar(read());
      return buffer2 += read(), String.fromCodePoint(parseInt(buffer2, 16));
    }
    function unicodeEscape() {
      let buffer2 = "", count = 4;
      for (; count-- > 0; ) {
        let c2 = peek();
        if (!util.isHexDigit(c2))
          throw invalidChar(read());
        buffer2 += read();
      }
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    var parseStates = {
      start() {
        if (token.type === "eof")
          throw invalidEOF();
        push();
      },
      beforePropertyName() {
        switch (token.type) {
          case "identifier":
          case "string":
            key = token.value, parseState = "afterPropertyName";
            return;
          case "punctuator":
            pop();
            return;
          case "eof":
            throw invalidEOF();
        }
      },
      afterPropertyName() {
        if (token.type === "eof")
          throw invalidEOF();
        parseState = "beforePropertyValue";
      },
      beforePropertyValue() {
        if (token.type === "eof")
          throw invalidEOF();
        push();
      },
      beforeArrayValue() {
        if (token.type === "eof")
          throw invalidEOF();
        if (token.type === "punctuator" && token.value === "]") {
          pop();
          return;
        }
        push();
      },
      afterPropertyValue() {
        if (token.type === "eof")
          throw invalidEOF();
        switch (token.value) {
          case ",":
            parseState = "beforePropertyName";
            return;
          case "}":
            pop();
        }
      },
      afterArrayValue() {
        if (token.type === "eof")
          throw invalidEOF();
        switch (token.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;
          case "]":
            pop();
        }
      },
      end() {
      }
    };
    function push() {
      let value;
      switch (token.type) {
        case "punctuator":
          switch (token.value) {
            case "{":
              value = {};
              break;
            case "[":
              value = [];
              break;
          }
          break;
        case "null":
        case "boolean":
        case "numeric":
        case "string":
          value = token.value;
          break;
      }
      if (root === void 0)
        root = value;
      else {
        let parent = stack[stack.length - 1];
        Array.isArray(parent) ? parent.push(value) : Object.defineProperty(parent, key, {
          value,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
      if (value !== null && typeof value == "object")
        stack.push(value), Array.isArray(value) ? parseState = "beforeArrayValue" : parseState = "beforePropertyName";
      else {
        let current = stack[stack.length - 1];
        current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
      }
    }
    function pop() {
      stack.pop();
      let current = stack[stack.length - 1];
      current == null ? parseState = "end" : Array.isArray(current) ? parseState = "afterArrayValue" : parseState = "afterPropertyValue";
    }
    function invalidChar(c2) {
      return syntaxError(c2 === void 0 ? `JSON5: invalid end of input at ${line}:${column}` : `JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
    }
    function invalidEOF() {
      return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
    }
    function invalidIdentifier() {
      return column -= 5, syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
    }
    function separatorChar(c2) {
      console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
    }
    function formatChar(c2) {
      let replacements = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      };
      if (replacements[c2])
        return replacements[c2];
      if (c2 < " ") {
        let hexString = c2.charCodeAt(0).toString(16);
        return "\\x" + ("00" + hexString).substring(hexString.length);
      }
      return c2;
    }
    function syntaxError(message) {
      let err = new SyntaxError(message);
      return err.lineNumber = line, err.columnNumber = column, err;
    }
  }
});

// ../../node_modules/json5/lib/stringify.js
var require_stringify3 = __commonJS({
  "../../node_modules/json5/lib/stringify.js"(exports2, module2) {
    var util = require_util4();
    module2.exports = function(value, replacer, space) {
      let stack = [], indent = "", propertyList, replacerFunc, gap = "", quote2;
      if (replacer != null && typeof replacer == "object" && !Array.isArray(replacer) && (space = replacer.space, quote2 = replacer.quote, replacer = replacer.replacer), typeof replacer == "function")
        replacerFunc = replacer;
      else if (Array.isArray(replacer)) {
        propertyList = [];
        for (let v of replacer) {
          let item;
          typeof v == "string" ? item = v : (typeof v == "number" || v instanceof String || v instanceof Number) && (item = String(v)), item !== void 0 && propertyList.indexOf(item) < 0 && propertyList.push(item);
        }
      }
      return space instanceof Number ? space = Number(space) : space instanceof String && (space = String(space)), typeof space == "number" ? space > 0 && (space = Math.min(10, Math.floor(space)), gap = "          ".substr(0, space)) : typeof space == "string" && (gap = space.substr(0, 10)), serializeProperty("", { "": value });
      function serializeProperty(key, holder) {
        let value2 = holder[key];
        switch (value2 != null && (typeof value2.toJSON5 == "function" ? value2 = value2.toJSON5(key) : typeof value2.toJSON == "function" && (value2 = value2.toJSON(key))), replacerFunc && (value2 = replacerFunc.call(holder, key, value2)), value2 instanceof Number ? value2 = Number(value2) : value2 instanceof String ? value2 = String(value2) : value2 instanceof Boolean && (value2 = value2.valueOf()), value2) {
          case null:
            return "null";
          case !0:
            return "true";
          case !1:
            return "false";
        }
        if (typeof value2 == "string")
          return quoteString(value2, !1);
        if (typeof value2 == "number")
          return String(value2);
        if (typeof value2 == "object")
          return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
      }
      function quoteString(value2) {
        let quotes = {
          "'": 0.1,
          '"': 0.2
        }, replacements = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029"
        }, product = "";
        for (let i = 0; i < value2.length; i++) {
          let c = value2[i];
          switch (c) {
            case "'":
            case '"':
              quotes[c]++, product += c;
              continue;
            case "\0":
              if (util.isDigit(value2[i + 1])) {
                product += "\\x00";
                continue;
              }
          }
          if (replacements[c]) {
            product += replacements[c];
            continue;
          }
          if (c < " ") {
            let hexString = c.charCodeAt(0).toString(16);
            product += "\\x" + ("00" + hexString).substring(hexString.length);
            continue;
          }
          product += c;
        }
        let quoteChar = quote2 || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
        return product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]), quoteChar + product + quoteChar;
      }
      function serializeObject(value2) {
        if (stack.indexOf(value2) >= 0)
          throw TypeError("Converting circular structure to JSON5");
        stack.push(value2);
        let stepback = indent;
        indent = indent + gap;
        let keys = propertyList || Object.keys(value2), partial = [];
        for (let key of keys) {
          let propertyString = serializeProperty(key, value2);
          if (propertyString !== void 0) {
            let member = serializeKey(key) + ":";
            gap !== "" && (member += " "), member += propertyString, partial.push(member);
          }
        }
        let final;
        if (partial.length === 0)
          final = "{}";
        else {
          let properties;
          if (gap === "")
            properties = partial.join(","), final = "{" + properties + "}";
          else {
            let separator = `,
` + indent;
            properties = partial.join(separator), final = `{
` + indent + properties + `,
` + stepback + "}";
          }
        }
        return stack.pop(), indent = stepback, final;
      }
      function serializeKey(key) {
        if (key.length === 0)
          return quoteString(key, !0);
        let firstChar = String.fromCodePoint(key.codePointAt(0));
        if (!util.isIdStartChar(firstChar))
          return quoteString(key, !0);
        for (let i = firstChar.length; i < key.length; i++)
          if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i))))
            return quoteString(key, !0);
        return key;
      }
      function serializeArray(value2) {
        if (stack.indexOf(value2) >= 0)
          throw TypeError("Converting circular structure to JSON5");
        stack.push(value2);
        let stepback = indent;
        indent = indent + gap;
        let partial = [];
        for (let i = 0; i < value2.length; i++) {
          let propertyString = serializeProperty(String(i), value2);
          partial.push(propertyString !== void 0 ? propertyString : "null");
        }
        let final;
        if (partial.length === 0)
          final = "[]";
        else if (gap === "")
          final = "[" + partial.join(",") + "]";
        else {
          let separator = `,
` + indent, properties = partial.join(separator);
          final = `[
` + indent + properties + `,
` + stepback + "]";
        }
        return stack.pop(), indent = stepback, final;
      }
    };
  }
});

// ../../node_modules/json5/lib/index.js
var require_lib7 = __commonJS({
  "../../node_modules/json5/lib/index.js"(exports2, module2) {
    var parse6 = require_parse5(), stringify = require_stringify3(), JSON5 = {
      parse: parse6,
      stringify
    };
    module2.exports = JSON5;
  }
});

// ../../node_modules/imurmurhash/imurmurhash.js
var require_imurmurhash = __commonJS({
  "../../node_modules/imurmurhash/imurmurhash.js"(exports2, module2) {
    (function() {
      var cache2;
      function MurmurHash3(key, seed) {
        var m = this instanceof MurmurHash3 ? this : cache2;
        if (m.reset(seed), typeof key == "string" && key.length > 0 && m.hash(key), m !== this)
          return m;
      }
      MurmurHash3.prototype.hash = function(key) {
        var h1, k1, i, top, len;
        switch (len = key.length, this.len += len, k1 = this.k1, i = 0, this.rem) {
          case 0:
            k1 ^= len > i ? key.charCodeAt(i++) & 65535 : 0;
          case 1:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 8 : 0;
          case 2:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 16 : 0;
          case 3:
            k1 ^= len > i ? (key.charCodeAt(i) & 255) << 24 : 0, k1 ^= len > i ? (key.charCodeAt(i++) & 65280) >> 8 : 0;
        }
        if (this.rem = len + this.rem & 3, len -= this.rem, len > 0) {
          for (h1 = this.h1; k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295, k1 = k1 << 15 | k1 >>> 17, k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295, h1 ^= k1, h1 = h1 << 13 | h1 >>> 19, h1 = h1 * 5 + 3864292196 & 4294967295, !(i >= len); )
            k1 = key.charCodeAt(i++) & 65535 ^ (key.charCodeAt(i++) & 65535) << 8 ^ (key.charCodeAt(i++) & 65535) << 16, top = key.charCodeAt(i++), k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
          switch (k1 = 0, this.rem) {
            case 3:
              k1 ^= (key.charCodeAt(i + 2) & 65535) << 16;
            case 2:
              k1 ^= (key.charCodeAt(i + 1) & 65535) << 8;
            case 1:
              k1 ^= key.charCodeAt(i) & 65535;
          }
          this.h1 = h1;
        }
        return this.k1 = k1, this;
      }, MurmurHash3.prototype.result = function() {
        var k1, h1;
        return k1 = this.k1, h1 = this.h1, k1 > 0 && (k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295, k1 = k1 << 15 | k1 >>> 17, k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295, h1 ^= k1), h1 ^= this.len, h1 ^= h1 >>> 16, h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295, h1 ^= h1 >>> 13, h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295, h1 ^= h1 >>> 16, h1 >>> 0;
      }, MurmurHash3.prototype.reset = function(seed) {
        return this.h1 = typeof seed == "number" ? seed : 0, this.rem = this.k1 = this.len = 0, this;
      }, cache2 = new MurmurHash3(), typeof module2 < "u" ? module2.exports = MurmurHash3 : this.MurmurHash3 = MurmurHash3;
    })();
  }
});

// ../../node_modules/write-file-atomic/index.js
var require_write_file_atomic = __commonJS({
  "../../node_modules/write-file-atomic/index.js"(exports2, module2) {
    "use strict";
    module2.exports = writeFile;
    module2.exports.sync = writeFileSync2;
    module2.exports._getTmpname = getTmpname;
    module2.exports._cleanupOnExit = cleanupOnExit;
    var fs7 = require_graceful_fs(), MurmurHash3 = require_imurmurhash(), onExit = require_signal_exit(), path6 = require("path"), activeFiles = {}, threadId = function() {
      try {
        var workerThreads = require("worker_threads");
        return workerThreads.threadId;
      } catch {
        return 0;
      }
    }(), invocations = 0;
    function getTmpname(filename) {
      return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
    }
    function cleanupOnExit(tmpfile) {
      return function() {
        try {
          fs7.unlinkSync(typeof tmpfile == "function" ? tmpfile() : tmpfile);
        } catch {
        }
      };
    }
    function writeFile(filename, data, options, callback) {
      options ? options instanceof Function ? (callback = options, options = {}) : typeof options == "string" && (options = { encoding: options }) : options = {};
      var Promise2 = options.Promise || global.Promise, truename, fd, tmpfile, removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile)), absoluteName = path6.resolve(filename);
      new Promise2(function(resolve7) {
        activeFiles[absoluteName] || (activeFiles[absoluteName] = []), activeFiles[absoluteName].push(resolve7), activeFiles[absoluteName].length === 1 && resolve7();
      }).then(function() {
        return new Promise2(function(resolve7) {
          fs7.realpath(filename, function(_, realname) {
            truename = realname || filename, tmpfile = getTmpname(truename), resolve7();
          });
        });
      }).then(function() {
        return new Promise2(function(resolve7) {
          options.mode && options.chown ? resolve7() : fs7.stat(truename, function(err, stats) {
            err || !stats || (options = Object.assign({}, options), options.mode == null && (options.mode = stats.mode), options.chown == null && process.getuid && (options.chown = { uid: stats.uid, gid: stats.gid })), resolve7();
          });
        });
      }).then(function() {
        return new Promise2(function(resolve7, reject) {
          fs7.open(tmpfile, "w", options.mode, function(err, _fd) {
            fd = _fd, err ? reject(err) : resolve7();
          });
        });
      }).then(function() {
        return new Promise2(function(resolve7, reject) {
          Buffer.isBuffer(data) ? fs7.write(fd, data, 0, data.length, 0, function(err) {
            err ? reject(err) : resolve7();
          }) : data != null ? fs7.write(fd, String(data), 0, String(options.encoding || "utf8"), function(err) {
            err ? reject(err) : resolve7();
          }) : resolve7();
        });
      }).then(function() {
        return new Promise2(function(resolve7, reject) {
          options.fsync !== !1 ? fs7.fsync(fd, function(err) {
            err ? fs7.close(fd, () => reject(err)) : fs7.close(fd, resolve7);
          }) : fs7.close(fd, resolve7);
        });
      }).then(function() {
        if (fd = null, options.chown)
          return new Promise2(function(resolve7, reject) {
            fs7.chown(tmpfile, options.chown.uid, options.chown.gid, function(err) {
              err ? reject(err) : resolve7();
            });
          });
      }).then(function() {
        if (options.mode)
          return new Promise2(function(resolve7, reject) {
            fs7.chmod(tmpfile, options.mode, function(err) {
              err ? reject(err) : resolve7();
            });
          });
      }).then(function() {
        return new Promise2(function(resolve7, reject) {
          fs7.rename(tmpfile, truename, function(err) {
            err ? reject(err) : resolve7();
          });
        });
      }).then(function() {
        removeOnExitHandler(), callback();
      }, function(err) {
        return new Promise2((resolve7) => fd ? fs7.close(fd, resolve7) : resolve7()).then(() => {
          removeOnExitHandler(), fs7.unlink(tmpfile, function() {
            callback(err);
          });
        });
      }).then(function() {
        activeFiles[absoluteName].shift(), activeFiles[absoluteName].length > 0 ? activeFiles[absoluteName][0]() : delete activeFiles[absoluteName];
      });
    }
    function writeFileSync2(filename, data, options) {
      typeof options == "string" ? options = { encoding: options } : options || (options = {});
      try {
        filename = fs7.realpathSync(filename);
      } catch {
      }
      var tmpfile = getTmpname(filename);
      if (!options.mode || !options.chown)
        try {
          var stats = fs7.statSync(filename);
          options = Object.assign({}, options), options.mode || (options.mode = stats.mode), !options.chown && process.getuid && (options.chown = { uid: stats.uid, gid: stats.gid });
        } catch {
        }
      var fd, cleanup = cleanupOnExit(tmpfile), removeOnExitHandler = onExit(cleanup);
      try {
        fd = fs7.openSync(tmpfile, "w", options.mode), Buffer.isBuffer(data) ? fs7.writeSync(fd, data, 0, data.length, 0) : data != null && fs7.writeSync(fd, String(data), 0, String(options.encoding || "utf8")), options.fsync !== !1 && fs7.fsyncSync(fd), fs7.closeSync(fd), options.chown && fs7.chownSync(tmpfile, options.chown.uid, options.chown.gid), options.mode && fs7.chmodSync(tmpfile, options.mode), fs7.renameSync(tmpfile, filename), removeOnExitHandler();
      } catch (err) {
        if (fd)
          try {
            fs7.closeSync(fd);
          } catch {
          }
        throw removeOnExitHandler(), cleanup(), err;
      }
    }
  }
});

// ../../node_modules/@expo/json-file/build/JsonFileError.js
var require_JsonFileError = __commonJS({
  "../../node_modules/@expo/json-file/build/JsonFileError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.EmptyJsonFileError = void 0;
    var JsonFileError = class extends Error {
      constructor(message, cause, code, fileName) {
        let fullMessage = message;
        fileName && (fullMessage += `
${cause ? "\u251C" : "\u2514"}\u2500 File: ${fileName}`), cause && (fullMessage += `
\u2514\u2500 Cause: ${cause.name}: ${cause.message}`), super(fullMessage), this.name = this.constructor.name, this.cause = cause, this.code = code, this.fileName = fileName, this.isJsonFileError = !0;
      }
    };
    exports2.default = JsonFileError;
    var EmptyJsonFileError = class extends JsonFileError {
      constructor(fileName) {
        super("Cannot parse an empty JSON string", void 0, "EJSONEMPTY", fileName);
      }
    };
    exports2.EmptyJsonFileError = EmptyJsonFileError;
  }
});

// ../../node_modules/@expo/json-file/build/JsonFile.js
var require_JsonFile = __commonJS({
  "../../node_modules/@expo/json-file/build/JsonFile.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null)
        for (var k in mod)
          k !== "default" && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    }, __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var code_frame_1 = require_lib6(), fs_1 = __importDefault(require("fs")), json5_1 = __importDefault(require_lib7()), path_1 = __importDefault(require("path")), util_1 = require("util"), write_file_atomic_1 = __importDefault(require_write_file_atomic()), JsonFileError_1 = __importStar(require_JsonFileError()), writeFileAtomicAsync = (0, util_1.promisify)(write_file_atomic_1.default), DEFAULT_OPTIONS = {
      badJsonDefault: void 0,
      jsonParseErrorDefault: void 0,
      cantReadFileDefault: void 0,
      ensureDir: !1,
      default: void 0,
      json5: !1,
      space: 2,
      addNewLineAtEOF: !0
    }, JsonFile = class {
      constructor(file, options = {}) {
        this.file = file, this.options = options;
      }
      read(options) {
        return read(this.file, this._getOptions(options));
      }
      async readAsync(options) {
        return readAsync(this.file, this._getOptions(options));
      }
      async writeAsync(object, options) {
        return writeAsync(this.file, object, this._getOptions(options));
      }
      parseJsonString(json, options) {
        return parseJsonString(json, options);
      }
      async getAsync(key, defaultValue, options) {
        return getAsync(this.file, key, defaultValue, this._getOptions(options));
      }
      async setAsync(key, value, options) {
        return setAsync(this.file, key, value, this._getOptions(options));
      }
      async mergeAsync(sources, options) {
        return mergeAsync(this.file, sources, this._getOptions(options));
      }
      async deleteKeyAsync(key, options) {
        return deleteKeyAsync(this.file, key, this._getOptions(options));
      }
      async deleteKeysAsync(keys, options) {
        return deleteKeysAsync(this.file, keys, this._getOptions(options));
      }
      async rewriteAsync(options) {
        return rewriteAsync(this.file, this._getOptions(options));
      }
      _getOptions(options) {
        return {
          ...this.options,
          ...options
        };
      }
    };
    exports2.default = JsonFile;
    JsonFile.read = read;
    JsonFile.readAsync = readAsync;
    JsonFile.parseJsonString = parseJsonString;
    JsonFile.writeAsync = writeAsync;
    JsonFile.getAsync = getAsync;
    JsonFile.setAsync = setAsync;
    JsonFile.mergeAsync = mergeAsync;
    JsonFile.deleteKeyAsync = deleteKeyAsync;
    JsonFile.deleteKeysAsync = deleteKeysAsync;
    JsonFile.rewriteAsync = rewriteAsync;
    function read(file, options) {
      let json;
      try {
        json = fs_1.default.readFileSync(file, "utf8");
      } catch (error) {
        assertEmptyJsonString(json, file);
        let defaultValue = cantReadFileDefault(options);
        if (defaultValue === void 0)
          throw new JsonFileError_1.default(`Can't read JSON file: ${file}`, error, error.code, file);
        return defaultValue;
      }
      return parseJsonString(json, options, file);
    }
    async function readAsync(file, options) {
      let json;
      try {
        json = await fs_1.default.promises.readFile(file, "utf8");
      } catch (error) {
        assertEmptyJsonString(json, file);
        let defaultValue = cantReadFileDefault(options);
        if (defaultValue === void 0)
          throw new JsonFileError_1.default(`Can't read JSON file: ${file}`, error, error.code);
        return defaultValue;
      }
      return parseJsonString(json, options);
    }
    function parseJsonString(json, options, fileName) {
      assertEmptyJsonString(json, fileName);
      try {
        return _getOption(options, "json5") ? json5_1.default.parse(json) : JSON.parse(json);
      } catch (e) {
        let defaultValue = jsonParseErrorDefault(options);
        if (defaultValue === void 0) {
          let location = locationFromSyntaxError(e, json);
          if (location) {
            let codeFrame = (0, code_frame_1.codeFrameColumns)(json, { start: location });
            e.codeFrame = codeFrame, e.message += `
${codeFrame}`;
          }
          throw new JsonFileError_1.default(`Error parsing JSON: ${json}`, e, "EJSONPARSE", fileName);
        } else
          return defaultValue;
      }
    }
    async function getAsync(file, key, defaultValue, options) {
      let object = await readAsync(file, options);
      if (key in object)
        return object[key];
      if (defaultValue === void 0)
        throw new JsonFileError_1.default(`No value at key path "${key}" in JSON object from: ${file}`);
      return defaultValue;
    }
    async function writeAsync(file, object, options) {
      options != null && options.ensureDir && await fs_1.default.promises.mkdir(path_1.default.dirname(file), { recursive: !0 });
      let space = _getOption(options, "space"), json5 = _getOption(options, "json5"), addNewLineAtEOF = _getOption(options, "addNewLineAtEOF"), json;
      try {
        json5 ? json = json5_1.default.stringify(object, null, space) : json = JSON.stringify(object, null, space);
      } catch (e) {
        throw new JsonFileError_1.default(`Couldn't JSON.stringify object for file: ${file}`, e);
      }
      let data = addNewLineAtEOF ? `${json}
` : json;
      return await writeFileAtomicAsync(file, data, {}), object;
    }
    async function setAsync(file, key, value, options) {
      let object = await readAsync(file, options);
      return writeAsync(file, { ...object, [key]: value }, options);
    }
    async function mergeAsync(file, sources, options) {
      let object = await readAsync(file, options);
      return Array.isArray(sources) ? Object.assign(object, ...sources) : Object.assign(object, sources), writeAsync(file, object, options);
    }
    async function deleteKeyAsync(file, key, options) {
      return deleteKeysAsync(file, [key], options);
    }
    async function deleteKeysAsync(file, keys, options) {
      let object = await readAsync(file, options), didDelete = !1;
      for (let i = 0; i < keys.length; i++) {
        let key = keys[i];
        object.hasOwnProperty(key) && (delete object[key], didDelete = !0);
      }
      return didDelete ? writeAsync(file, object, options) : object;
    }
    async function rewriteAsync(file, options) {
      let object = await readAsync(file, options);
      return writeAsync(file, object, options);
    }
    function jsonParseErrorDefault(options = {}) {
      return options.jsonParseErrorDefault === void 0 ? options.default : options.jsonParseErrorDefault;
    }
    function cantReadFileDefault(options = {}) {
      return options.cantReadFileDefault === void 0 ? options.default : options.cantReadFileDefault;
    }
    function _getOption(options, field) {
      return options && options[field] !== void 0 ? options[field] : DEFAULT_OPTIONS[field];
    }
    function locationFromSyntaxError(error, sourceString) {
      if ("lineNumber" in error && "columnNumber" in error)
        return { line: error.lineNumber, column: error.columnNumber };
      let match2 = /at position (\d+)/.exec(error.message);
      if (match2) {
        let index = parseInt(match2[1], 10), lines = sourceString.slice(0, index + 1).split(`
`);
        return { line: lines.length, column: lines[lines.length - 1].length };
      }
      return null;
    }
    function assertEmptyJsonString(json, file) {
      if ((json == null ? void 0 : json.trim()) === "")
        throw new JsonFileError_1.EmptyJsonFileError(file);
    }
  }
});

// ../../node_modules/npm-package-arg/node_modules/hosted-git-info/git-host-info.js
var require_git_host_info = __commonJS({
  "../../node_modules/npm-package-arg/node_modules/hosted-git-info/git-host-info.js"(exports2, module2) {
    "use strict";
    var gitHosts = module2.exports = {
      github: {
        // First two are insecure and generally shouldn't be used any more, but
        // they are still supported.
        protocols: ["git", "http", "git+ssh", "git+https", "ssh", "https"],
        domain: "github.com",
        treepath: "tree",
        filetemplate: "https://{auth@}raw.githubusercontent.com/{user}/{project}/{committish}/{path}",
        bugstemplate: "https://{domain}/{user}/{project}/issues",
        gittemplate: "git://{auth@}{domain}/{user}/{project}.git{#committish}",
        tarballtemplate: "https://codeload.{domain}/{user}/{project}/tar.gz/{committish}"
      },
      bitbucket: {
        protocols: ["git+ssh", "git+https", "ssh", "https"],
        domain: "bitbucket.org",
        treepath: "src",
        tarballtemplate: "https://{domain}/{user}/{project}/get/{committish}.tar.gz"
      },
      gitlab: {
        protocols: ["git+ssh", "git+https", "ssh", "https"],
        domain: "gitlab.com",
        treepath: "tree",
        bugstemplate: "https://{domain}/{user}/{project}/issues",
        httpstemplate: "git+https://{auth@}{domain}/{user}/{projectPath}.git{#committish}",
        tarballtemplate: "https://{domain}/{user}/{project}/repository/archive.tar.gz?ref={committish}",
        pathmatch: /^\/([^/]+)\/((?!.*(\/-\/|\/repository(\/[^/]+)?\/archive\.tar\.gz)).*?)(?:\.git|\/)?$/
      },
      gist: {
        protocols: ["git", "git+ssh", "git+https", "ssh", "https"],
        domain: "gist.github.com",
        pathmatch: /^[/](?:([^/]+)[/])?([a-z0-9]{7,})(?:[.]git)?$/,
        filetemplate: "https://gist.githubusercontent.com/{user}/{project}/raw{/committish}/{path}",
        bugstemplate: "https://{domain}/{project}",
        gittemplate: "git://{domain}/{project}.git{#committish}",
        sshtemplate: "git@{domain}:/{project}.git{#committish}",
        sshurltemplate: "git+ssh://git@{domain}/{project}.git{#committish}",
        browsetemplate: "https://{domain}/{project}{/committish}",
        browsefiletemplate: "https://{domain}/{project}{/committish}{#path}",
        docstemplate: "https://{domain}/{project}{/committish}",
        httpstemplate: "git+https://{domain}/{project}.git{#committish}",
        shortcuttemplate: "{type}:{project}{#committish}",
        pathtemplate: "{project}{#committish}",
        tarballtemplate: "https://codeload.github.com/gist/{project}/tar.gz/{committish}",
        hashformat: function(fragment) {
          return "file-" + formatHashFragment(fragment);
        }
      }
    }, gitHostDefaults = {
      sshtemplate: "git@{domain}:{user}/{project}.git{#committish}",
      sshurltemplate: "git+ssh://git@{domain}/{user}/{project}.git{#committish}",
      browsetemplate: "https://{domain}/{user}/{project}{/tree/committish}",
      browsefiletemplate: "https://{domain}/{user}/{project}/{treepath}/{committish}/{path}{#fragment}",
      docstemplate: "https://{domain}/{user}/{project}{/tree/committish}#readme",
      httpstemplate: "git+https://{auth@}{domain}/{user}/{project}.git{#committish}",
      filetemplate: "https://{domain}/{user}/{project}/raw/{committish}/{path}",
      shortcuttemplate: "{type}:{user}/{project}{#committish}",
      pathtemplate: "{user}/{project}{#committish}",
      pathmatch: /^[/]([^/]+)[/]([^/]+?)(?:[.]git|[/])?$/,
      hashformat: formatHashFragment
    };
    Object.keys(gitHosts).forEach(function(name) {
      Object.keys(gitHostDefaults).forEach(function(key) {
        gitHosts[name][key] || (gitHosts[name][key] = gitHostDefaults[key]);
      }), gitHosts[name].protocols_re = RegExp("^(" + gitHosts[name].protocols.map(function(protocol) {
        return protocol.replace(/([\\+*{}()[\]$^|])/g, "\\$1");
      }).join("|") + "):$");
    });
    function formatHashFragment(fragment) {
      return fragment.toLowerCase().replace(/^\W+|\/|\W+$/g, "").replace(/\W+/g, "-");
    }
  }
});

// ../../node_modules/npm-package-arg/node_modules/hosted-git-info/git-host.js
var require_git_host = __commonJS({
  "../../node_modules/npm-package-arg/node_modules/hosted-git-info/git-host.js"(exports2, module2) {
    "use strict";
    var gitHosts = require_git_host_info(), extend = Object.assign || function(target, source) {
      if (source === null || typeof source != "object")
        return target;
      let keys = Object.keys(source), i = keys.length;
      for (; i--; )
        target[keys[i]] = source[keys[i]];
      return target;
    };
    module2.exports = GitHost;
    function GitHost(type, user, auth, project, committish, defaultRepresentation, opts) {
      var gitHostInfo = this;
      gitHostInfo.type = type, Object.keys(gitHosts[type]).forEach(function(key) {
        gitHostInfo[key] = gitHosts[type][key];
      }), gitHostInfo.user = user, gitHostInfo.auth = auth, gitHostInfo.project = project, gitHostInfo.committish = committish, gitHostInfo.default = defaultRepresentation, gitHostInfo.opts = opts || {};
    }
    GitHost.prototype.hash = function() {
      return this.committish ? "#" + this.committish : "";
    };
    GitHost.prototype._fill = function(template, opts) {
      if (template) {
        var vars = extend({}, opts);
        vars.path = vars.path ? vars.path.replace(/^[/]+/g, "") : "", opts = extend(extend({}, this.opts), opts);
        var self = this;
        Object.keys(this).forEach(function(key) {
          self[key] != null && vars[key] == null && (vars[key] = self[key]);
        });
        var rawAuth = vars.auth, rawcommittish = vars.committish, rawFragment = vars.fragment, rawPath = vars.path, rawProject = vars.project;
        Object.keys(vars).forEach(function(key) {
          var value = vars[key];
          (key === "path" || key === "project") && typeof value == "string" ? vars[key] = value.split("/").map(function(pathComponent) {
            return encodeURIComponent(pathComponent);
          }).join("/") : key !== "domain" && (vars[key] = encodeURIComponent(value));
        }), vars["auth@"] = rawAuth ? rawAuth + "@" : "", vars["#fragment"] = rawFragment ? "#" + this.hashformat(rawFragment) : "", vars.fragment = vars.fragment ? vars.fragment : "", vars["#path"] = rawPath ? "#" + this.hashformat(rawPath) : "", vars["/path"] = vars.path ? "/" + vars.path : "", vars.projectPath = rawProject.split("/").map(encodeURIComponent).join("/"), opts.noCommittish ? (vars["#committish"] = "", vars["/tree/committish"] = "", vars["/committish"] = "", vars.committish = "") : (vars["#committish"] = rawcommittish ? "#" + rawcommittish : "", vars["/tree/committish"] = vars.committish ? "/" + vars.treepath + "/" + vars.committish : "", vars["/committish"] = vars.committish ? "/" + vars.committish : "", vars.committish = vars.committish || "master");
        var res = template;
        return Object.keys(vars).forEach(function(key) {
          res = res.replace(new RegExp("[{]" + key + "[}]", "g"), vars[key]);
        }), opts.noGitPlus ? res.replace(/^git[+]/, "") : res;
      }
    };
    GitHost.prototype.ssh = function(opts) {
      return this._fill(this.sshtemplate, opts);
    };
    GitHost.prototype.sshurl = function(opts) {
      return this._fill(this.sshurltemplate, opts);
    };
    GitHost.prototype.browse = function(P, F, opts) {
      return typeof P == "string" ? (typeof F != "string" && (opts = F, F = null), this._fill(this.browsefiletemplate, extend({
        fragment: F,
        path: P
      }, opts))) : this._fill(this.browsetemplate, P);
    };
    GitHost.prototype.docs = function(opts) {
      return this._fill(this.docstemplate, opts);
    };
    GitHost.prototype.bugs = function(opts) {
      return this._fill(this.bugstemplate, opts);
    };
    GitHost.prototype.https = function(opts) {
      return this._fill(this.httpstemplate, opts);
    };
    GitHost.prototype.git = function(opts) {
      return this._fill(this.gittemplate, opts);
    };
    GitHost.prototype.shortcut = function(opts) {
      return this._fill(this.shortcuttemplate, opts);
    };
    GitHost.prototype.path = function(opts) {
      return this._fill(this.pathtemplate, opts);
    };
    GitHost.prototype.tarball = function(opts_) {
      var opts = extend({}, opts_, { noCommittish: !1 });
      return this._fill(this.tarballtemplate, opts);
    };
    GitHost.prototype.file = function(P, opts) {
      return this._fill(this.filetemplate, extend({ path: P }, opts));
    };
    GitHost.prototype.getDefaultRepresentation = function() {
      return this.default;
    };
    GitHost.prototype.toString = function(opts) {
      return this.default && typeof this[this.default] == "function" ? this[this.default](opts) : this.sshurl(opts);
    };
  }
});

// ../../node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "../../node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next)
          yield walker.value;
      };
    };
  }
});

// ../../node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "../../node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self = this;
      if (self instanceof Yallist || (self = new Yallist()), self.tail = null, self.head = null, self.length = 0, list && typeof list.forEach == "function")
        list.forEach(function(item) {
          self.push(item);
        });
      else if (arguments.length > 0)
        for (var i = 0, l = arguments.length; i < l; i++)
          self.push(arguments[i]);
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this)
        throw new Error("removing node which does not belong to this list");
      var next = node.next, prev = node.prev;
      return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null, next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node !== this.head) {
        node.list && node.list.removeNode(node);
        var head = this.head;
        node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
      }
    };
    Yallist.prototype.pushNode = function(node) {
      if (node !== this.tail) {
        node.list && node.list.removeNode(node);
        var tail = this.tail;
        node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
      }
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++)
        push(this, arguments[i]);
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++)
        unshift(this, arguments[i]);
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (this.tail) {
        var res = this.tail.value;
        return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
      }
    };
    Yallist.prototype.shift = function() {
      if (this.head) {
        var res = this.head.value;
        return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
      }
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++)
        fn.call(thisp, walker.value, i, this), walker = walker.next;
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--)
        fn.call(thisp, walker.value, i, this), walker = walker.prev;
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++)
        walker = walker.next;
      if (i === n && walker !== null)
        return walker.value;
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++)
        walker = walker.prev;
      if (i === n && walker !== null)
        return walker.value;
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      for (var res = new Yallist(), walker = this.head; walker !== null; )
        res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var res = new Yallist(), walker = this.tail; walker !== null; )
        res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc, walker = this.head;
      if (arguments.length > 1)
        acc = initial;
      else if (this.head)
        walker = this.head.next, acc = this.head.value;
      else
        throw new TypeError("Reduce of empty list with no initial value");
      for (var i = 0; walker !== null; i++)
        acc = fn(acc, walker.value, i), walker = walker.next;
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc, walker = this.tail;
      if (arguments.length > 1)
        acc = initial;
      else if (this.tail)
        walker = this.tail.prev, acc = this.tail.value;
      else
        throw new TypeError("Reduce of empty list with no initial value");
      for (var i = this.length - 1; walker !== null; i--)
        acc = fn(acc, walker.value, i), walker = walker.prev;
      return acc;
    };
    Yallist.prototype.toArray = function() {
      for (var arr = new Array(this.length), i = 0, walker = this.head; walker !== null; i++)
        arr[i] = walker.value, walker = walker.next;
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      for (var arr = new Array(this.length), i = 0, walker = this.tail; walker !== null; i++)
        arr[i] = walker.value, walker = walker.prev;
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
      var ret = new Yallist();
      if (to < from || to < 0)
        return ret;
      from < 0 && (from = 0), to > this.length && (to = this.length);
      for (var i = 0, walker = this.head; walker !== null && i < from; i++)
        walker = walker.next;
      for (; walker !== null && i < to; i++, walker = walker.next)
        ret.push(walker.value);
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
      var ret = new Yallist();
      if (to < from || to < 0)
        return ret;
      from < 0 && (from = 0), to > this.length && (to = this.length);
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--)
        walker = walker.prev;
      for (; walker !== null && i > from; i--, walker = walker.prev)
        ret.push(walker.value);
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
      for (var i = 0, walker = this.head; walker !== null && i < start; i++)
        walker = walker.next;
      for (var ret = [], i = 0; walker && i < deleteCount; i++)
        ret.push(walker.value), walker = this.removeNode(walker);
      walker === null && (walker = this.tail), walker !== this.head && walker !== this.tail && (walker = walker.prev);
      for (var i = 0; i < nodes.length; i++)
        walker = insert(this, walker, nodes[i]);
      return ret;
    };
    Yallist.prototype.reverse = function() {
      for (var head = this.head, tail = this.tail, walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next, walker.next = p;
      }
      return this.head = tail, this.tail = head, this;
    };
    function insert(self, node, value) {
      var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
      return inserted.next === null && (self.tail = inserted), inserted.prev === null && (self.head = inserted), self.length++, inserted;
    }
    function push(self, item) {
      self.tail = new Node(item, self.tail, null, self), self.head || (self.head = self.tail), self.length++;
    }
    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self), self.tail || (self.tail = self.head), self.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node))
        return new Node(value, prev, next, list);
      this.list = list, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
    }
    try {
      require_iterator()(Yallist);
    } catch {
    }
  }
});

// ../../node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist(), MAX = Symbol("max"), LENGTH = Symbol("length"), LENGTH_CALCULATOR = Symbol("lengthCalculator"), ALLOW_STALE = Symbol("allowStale"), MAX_AGE = Symbol("maxAge"), DISPOSE = Symbol("dispose"), NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet"), LRU_LIST = Symbol("lruList"), CACHE = Symbol("cache"), UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet"), naiveLength = () => 1, LRUCache2 = class {
      constructor(options) {
        if (typeof options == "number" && (options = { max: options }), options || (options = {}), options.max && (typeof options.max != "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        let max = this[MAX] = options.max || 1 / 0, lc = options.length || naiveLength;
        if (this[LENGTH_CALCULATOR] = typeof lc != "function" ? naiveLength : lc, this[ALLOW_STALE] = options.stale || !1, options.maxAge && typeof options.maxAge != "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0, this[DISPOSE] = options.dispose, this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || !1, this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || !1, this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL != "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || 1 / 0, trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA != "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA, trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        typeof lC != "function" && (lC = naiveLength), lC !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = lC, this[LENGTH] = 0, this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key), this[LENGTH] += hit.length;
        })), trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          let prev = walker.prev;
          forEachStep(this, fn, walker, thisp), walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          let next = walker.next;
          forEachStep(this, fn, walker, thisp), walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value)), this[CACHE] = /* @__PURE__ */ new Map(), this[LRU_LIST] = new Yallist(), this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? !1 : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        if (maxAge = maxAge || this[MAX_AGE], maxAge && typeof maxAge != "number")
          throw new TypeError("maxAge must be a number");
        let now = maxAge ? Date.now() : 0, len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX])
            return del(this, this[CACHE].get(key)), !1;
          let item = this[CACHE].get(key).value;
          return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](key, item.value)), item.now = now, item.maxAge = maxAge, item.value = value, this[LENGTH] += len - item.length, item.length = len, this.get(key), trim(this), !0;
        }
        let hit = new Entry(key, value, len, now, maxAge);
        return hit.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](key, value), !1) : (this[LENGTH] += hit.length, this[LRU_LIST].unshift(hit), this[CACHE].set(key, this[LRU_LIST].head), trim(this), !0);
      }
      has(key) {
        if (!this[CACHE].has(key))
          return !1;
        let hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, !0);
      }
      peek(key) {
        return get(this, key, !1);
      }
      pop() {
        let node = this[LRU_LIST].tail;
        return node ? (del(this, node), node.value) : null;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        let now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          let hit = arr[l], expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            let maxAge = expiresAt - now;
            maxAge > 0 && this.set(hit.k, hit.v, maxAge);
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, !1));
      }
    }, get = (self, key, doUse) => {
      let node = self[CACHE].get(key);
      if (node) {
        let hit = node.value;
        if (isStale(self, hit)) {
          if (del(self, node), !self[ALLOW_STALE])
            return;
        } else
          doUse && (self[UPDATE_AGE_ON_GET] && (node.value.now = Date.now()), self[LRU_LIST].unshiftNode(node));
        return hit.value;
      }
    }, isStale = (self, hit) => {
      if (!hit || !hit.maxAge && !self[MAX_AGE])
        return !1;
      let diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
    }, trim = (self) => {
      if (self[LENGTH] > self[MAX])
        for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
          let prev = walker.prev;
          del(self, walker), walker = prev;
        }
    }, del = (self, node) => {
      if (node) {
        let hit = node.value;
        self[DISPOSE] && self[DISPOSE](hit.key, hit.value), self[LENGTH] -= hit.length, self[CACHE].delete(hit.key), self[LRU_LIST].removeNode(node);
      }
    }, Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key, this.value = value, this.length = length, this.now = now, this.maxAge = maxAge || 0;
      }
    }, forEachStep = (self, fn, node, thisp) => {
      let hit = node.value;
      isStale(self, hit) && (del(self, node), self[ALLOW_STALE] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self);
    };
    module2.exports = LRUCache2;
  }
});

// ../../node_modules/npm-package-arg/node_modules/hosted-git-info/index.js
var require_hosted_git_info = __commonJS({
  "../../node_modules/npm-package-arg/node_modules/hosted-git-info/index.js"(exports2, module2) {
    "use strict";
    var url = require("url"), gitHosts = require_git_host_info(), GitHost = module2.exports = require_git_host(), LRU = require_lru_cache(), cache2 = new LRU({ max: 1e3 }), protocolToRepresentationMap = {
      "git+ssh:": "sshurl",
      "git+https:": "https",
      "ssh:": "sshurl",
      "git:": "git"
    };
    function protocolToRepresentation(protocol) {
      return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);
    }
    var authProtocols = {
      "git:": !0,
      "https:": !0,
      "git+https:": !0,
      "http:": !0,
      "git+http:": !0
    };
    module2.exports.fromUrl = function(giturl, opts) {
      if (typeof giturl == "string") {
        var key = giturl + JSON.stringify(opts || {});
        return cache2.has(key) || cache2.set(key, fromUrl(giturl, opts)), cache2.get(key);
      }
    };
    function fromUrl(giturl, opts) {
      if (!(giturl == null || giturl === "")) {
        var url2 = fixupUnqualifiedGist(
          isGitHubShorthand(giturl) ? "github:" + giturl : giturl
        ), parsed = parseGitUrl(url2), shortcutMatch = url2.match(/^([^:]+):(?:[^@]+@)?(?:([^/]*)\/)?([^#]+)/), matches = Object.keys(gitHosts).map(function(gitHostName) {
          try {
            var gitHostInfo = gitHosts[gitHostName], auth = null;
            parsed.auth && authProtocols[parsed.protocol] && (auth = parsed.auth);
            var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null, user = null, project = null, defaultRepresentation = null;
            if (shortcutMatch && shortcutMatch[1] === gitHostName)
              user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]), project = decodeURIComponent(shortcutMatch[3].replace(/\.git$/, "")), defaultRepresentation = "shortcut";
            else {
              if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, "") !== gitHostInfo.domain || !gitHostInfo.protocols_re.test(parsed.protocol) || !parsed.path)
                return;
              var pathmatch = gitHostInfo.pathmatch, matched = parsed.path.match(pathmatch);
              if (!matched)
                return;
              matched[1] !== null && matched[1] !== void 0 && (user = decodeURIComponent(matched[1].replace(/^:/, ""))), project = decodeURIComponent(matched[2]), defaultRepresentation = protocolToRepresentation(parsed.protocol);
            }
            return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);
          } catch (ex) {
            if (!(ex instanceof URIError))
              throw ex;
          }
        }).filter(function(gitHostInfo) {
          return gitHostInfo;
        });
        if (matches.length === 1)
          return matches[0];
      }
    }
    function isGitHubShorthand(arg) {
      return /^[^:@%/\s.-][^:@%/\s]*[/][^:@\s/%]+(?:#.*)?$/.test(arg);
    }
    function fixupUnqualifiedGist(giturl) {
      var parsed = url.parse(giturl);
      return parsed.protocol === "gist:" && parsed.host && !parsed.path ? parsed.protocol + "/" + parsed.host : giturl;
    }
    function parseGitUrl(giturl) {
      var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);
      if (!matched) {
        var legacy = url.parse(giturl);
        if (legacy.auth) {
          let authmatch = giturl.match(/[^@]+@[^:/]+/);
          if (authmatch) {
            var whatwg = new url.URL(authmatch[0]);
            legacy.auth = whatwg.username || "", whatwg.password && (legacy.auth += ":" + whatwg.password);
          }
        }
        return legacy;
      }
      return {
        protocol: "git+ssh:",
        slashes: !0,
        auth: matched[1],
        host: matched[2],
        port: null,
        hostname: matched[2],
        hash: matched[4],
        search: null,
        query: null,
        pathname: "/" + matched[3],
        path: "/" + matched[3],
        href: "git+ssh://" + matched[1] + "@" + matched[2] + "/" + matched[3] + (matched[4] || "")
      };
    }
  }
});

// ../../node_modules/os-tmpdir/index.js
var require_os_tmpdir = __commonJS({
  "../../node_modules/os-tmpdir/index.js"(exports2, module2) {
    "use strict";
    var isWindows = process.platform === "win32", trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;
    module2.exports = function() {
      var path6;
      return isWindows ? path6 = process.env.TEMP || process.env.TMP || (process.env.SystemRoot || process.env.windir) + "\\temp" : path6 = process.env.TMPDIR || process.env.TMP || process.env.TEMP || "/tmp", trailingSlashRe.test(path6) && (path6 = path6.slice(0, -1)), path6;
    };
  }
});

// ../../node_modules/os-homedir/index.js
var require_os_homedir = __commonJS({
  "../../node_modules/os-homedir/index.js"(exports2, module2) {
    "use strict";
    var os2 = require("os");
    function homedir2() {
      var env2 = process.env, home2 = env2.HOME, user = env2.LOGNAME || env2.USER || env2.LNAME || env2.USERNAME;
      return process.platform === "win32" ? env2.USERPROFILE || env2.HOMEDRIVE + env2.HOMEPATH || home2 || null : process.platform === "darwin" ? home2 || (user ? "/Users/" + user : null) : process.platform === "linux" ? home2 || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null) : home2 || null;
    }
    module2.exports = typeof os2.homedir == "function" ? os2.homedir : homedir2;
  }
});

// ../../node_modules/osenv/osenv.js
var require_osenv = __commonJS({
  "../../node_modules/osenv/osenv.js"(exports2) {
    var isWindows = process.platform === "win32", path6 = require("path"), exec = require("child_process").exec, osTmpdir = require_os_tmpdir(), osHomedir = require_os_homedir();
    function memo(key, lookup, fallback) {
      var fell = !1, falling = !1;
      exports2[key] = function(cb) {
        var val = lookup();
        return !val && !fell && !falling && fallback && (fell = !0, falling = !0, exec(fallback, function(er, output, stderr) {
          falling = !1, !er && (val = output.trim());
        })), exports2[key] = function(cb2) {
          return cb2 && process.nextTick(cb2.bind(null, null, val)), val;
        }, cb && !falling && process.nextTick(cb.bind(null, null, val)), val;
      };
    }
    memo("user", function() {
      return isWindows ? process.env.USERDOMAIN + "\\" + process.env.USERNAME : process.env.USER;
    }, "whoami");
    memo("prompt", function() {
      return isWindows ? process.env.PROMPT : process.env.PS1;
    });
    memo("hostname", function() {
      return isWindows ? process.env.COMPUTERNAME : process.env.HOSTNAME;
    }, "hostname");
    memo("tmpdir", function() {
      return osTmpdir();
    });
    memo("home", function() {
      return osHomedir();
    });
    memo("path", function() {
      return (process.env.PATH || process.env.Path || process.env.path).split(isWindows ? ";" : ":");
    });
    memo("editor", function() {
      return process.env.EDITOR || process.env.VISUAL || (isWindows ? "notepad.exe" : "vi");
    });
    memo("shell", function() {
      return isWindows ? process.env.ComSpec || "cmd" : process.env.SHELL || "bash";
    });
  }
});

// ../../node_modules/npm-package-arg/node_modules/semver/semver.js
var require_semver = __commonJS({
  "../../node_modules/npm-package-arg/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER"), console.log.apply(console, args);
    } : debug = function() {
    };
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256, MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991, MAX_SAFE_COMPONENT_LENGTH = 16, re = exports2.re = [], src = exports2.src = [], R = 0, NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++, FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?", LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~", TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^", CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3", HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++)
      debug(i, src[i]), re[i] || (re[i] = new RegExp(src[i]));
    var i;
    exports2.parse = parse6;
    function parse6(version2, options) {
      if ((!options || typeof options != "object") && (options = {
        loose: !!options,
        includePrerelease: !1
      }), version2 instanceof SemVer)
        return version2;
      if (typeof version2 != "string" || version2.length > MAX_LENGTH)
        return null;
      var r = options.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version2))
        return null;
      try {
        return new SemVer(version2, options);
      } catch {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version2, options) {
      var v = parse6(version2, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version2, options) {
      var s = parse6(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version2, options) {
      if ((!options || typeof options != "object") && (options = {
        loose: !!options,
        includePrerelease: !1
      }), version2 instanceof SemVer) {
        if (version2.loose === options.loose)
          return version2;
        version2 = version2.version;
      } else if (typeof version2 != "string")
        throw new TypeError("Invalid Version: " + version2);
      if (version2.length > MAX_LENGTH)
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      if (!(this instanceof SemVer))
        return new SemVer(version2, options);
      debug("SemVer", version2, options), this.options = options, this.loose = !!options.loose;
      var m = version2.trim().match(options.loose ? re[LOOSE] : re[FULL]);
      if (!m)
        throw new TypeError("Invalid Version: " + version2);
      if (this.raw = version2, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
        throw new TypeError("Invalid patch version");
      m[4] ? this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER)
            return num;
        }
        return id;
      }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
    }
    SemVer.prototype.format = function() {
      return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      return debug("SemVer.compare", this.version, this.options, other), other instanceof SemVer || (other = new SemVer(other, this.options)), this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length)
        return -1;
      if (!this.prerelease.length && other.prerelease.length)
        return 1;
      if (!this.prerelease.length && !other.prerelease.length)
        return 0;
      var i2 = 0;
      do {
        var a = this.prerelease[i2], b = other.prerelease[i2];
        if (debug("prerelease compare", i2, a, b), a === void 0 && b === void 0)
          return 0;
        if (b === void 0)
          return 1;
        if (a === void 0)
          return -1;
        if (a === b)
          continue;
        return compareIdentifiers(a, b);
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", identifier), this.inc("pre", identifier);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            for (var i2 = this.prerelease.length; --i2 >= 0; )
              typeof this.prerelease[i2] == "number" && (this.prerelease[i2]++, i2 = -2);
            i2 === -1 && this.prerelease.push(0);
          }
          identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [identifier, 0]) : this.prerelease = [identifier, 0]);
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      return this.format(), this.raw = this.version, this;
    };
    exports2.inc = inc;
    function inc(version2, release, loose, identifier) {
      typeof loose == "string" && (identifier = loose, loose = void 0);
      try {
        return new SemVer(version2, loose).inc(release, identifier).version;
      } catch {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2))
        return null;
      var v1 = parse6(version1), v2 = parse6(version2), prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1)
        if ((key === "major" || key === "minor" || key === "patch") && v1[key] !== v2[key])
          return prefix + key;
      return defaultResult;
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a), bnum = numeric.test(b);
      return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, !0);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a === b;
        case "!==":
          return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if ((!options || typeof options != "object") && (options = {
        loose: !!options,
        includePrerelease: !1
      }), comp instanceof Comparator) {
        if (comp.loose === !!options.loose)
          return comp;
        comp = comp.value;
      }
      if (!(this instanceof Comparator))
        return new Comparator(comp, options);
      debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR], m = comp.match(r);
      if (!m)
        throw new TypeError("Invalid comparator: " + comp);
      this.operator = m[1], this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version2) {
      return debug("Comparator.test", version2, this.options.loose), this.semver === ANY ? !0 : (typeof version2 == "string" && (version2 = new SemVer(version2, this.options)), cmp(version2, this.operator, this.semver, this.options));
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator))
        throw new TypeError("a Comparator is required");
      (!options || typeof options != "object") && (options = {
        loose: !!options,
        includePrerelease: !1
      });
      var rangeTmp;
      if (this.operator === "")
        return rangeTmp = new Range(comp.value, options), satisfies(this.value, rangeTmp, options);
      if (comp.operator === "")
        return rangeTmp = new Range(this.value, options), satisfies(comp.semver, rangeTmp, options);
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">"), sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<"), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<="), oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"), oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if ((!options || typeof options != "object") && (options = {
        loose: !!options,
        includePrerelease: !1
      }), range instanceof Range)
        return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
      if (range instanceof Comparator)
        return new Range(range.value, options);
      if (!(this instanceof Range))
        return new Range(range, options);
      if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range, this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      }), !this.set.length)
        throw new TypeError("Invalid SemVer Range: " + range);
      this.format();
    }
    Range.prototype.format = function() {
      return this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim(), this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace), debug("hyphen replace", range), range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace), debug("comparator trim", range, re[COMPARATORTRIM]), range = range.replace(re[TILDETRIM], tildeTrimReplace), range = range.replace(re[CARETTRIM], caretTrimReplace), range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR], set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      return this.options.loose && (set = set.filter(function(comp) {
        return !!comp.match(compRe);
      })), set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this), set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range))
        throw new TypeError("a Range is required");
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      return debug("comp", comp, options), comp = replaceCarets(comp, options), debug("caret", comp), comp = replaceTildes(comp, options), debug("tildes", comp), comp = replaceXRanges(comp, options), debug("xrange", comp), comp = replaceStars(comp, options), debug("stars", comp), comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        return isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : pr ? (debug("replaceTilde pr", pr), ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0") : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0", debug("tilde return", ret), ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        return isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? M === "0" ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0" : pr ? (debug("replaceCaret pr", pr), M === "0" ? m === "0" ? ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) : ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0") : (debug("no pr"), M === "0" ? m === "0" ? ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1) : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0"), debug("caret return", ret), ret;
      });
    }
    function replaceXRanges(comp, options) {
      return debug("replaceXRanges", comp, options), comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M), xm = xM || isX(m), xp = xm || isX(p), anyX = xp;
        return gtlt === "=" && anyX && (gtlt = ""), xM ? gtlt === ">" || gtlt === "<" ? ret = "<0.0.0" : ret = "*" : gtlt && anyX ? (xm && (m = 0), p = 0, gtlt === ">" ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, p = 0)) : gtlt === "<=" && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), ret = gtlt + M + "." + m + "." + p) : xm ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : xp && (ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0"), debug("xRange return", ret), ret;
      });
    }
    function replaceStars(comp, options) {
      return debug("replaceStars", comp, options), comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      return isX(fM) ? from = "" : isX(fm) ? from = ">=" + fM + ".0.0" : isX(fp) ? from = ">=" + fM + "." + fm + ".0" : from = ">=" + from, isX(tM) ? to = "" : isX(tm) ? to = "<" + (+tM + 1) + ".0.0" : isX(tp) ? to = "<" + tM + "." + (+tm + 1) + ".0" : tpr ? to = "<=" + tM + "." + tm + "." + tp + "-" + tpr : to = "<=" + to, (from + " " + to).trim();
    }
    Range.prototype.test = function(version2) {
      if (!version2)
        return !1;
      typeof version2 == "string" && (version2 = new SemVer(version2, this.options));
      for (var i2 = 0; i2 < this.set.length; i2++)
        if (testSet(this.set[i2], version2, this.options))
          return !0;
      return !1;
    };
    function testSet(set, version2, options) {
      for (var i2 = 0; i2 < set.length; i2++)
        if (!set[i2].test(version2))
          return !1;
      if (version2.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++)
          if (debug(set[i2].semver), set[i2].semver !== ANY && set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch)
              return !0;
          }
        return !1;
      }
      return !0;
    }
    exports2.satisfies = satisfies;
    function satisfies(version2, range, options) {
      try {
        range = new Range(range, options);
      } catch {
        return !1;
      }
      return range.test(version2);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null, maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch {
        return null;
      }
      return versions.forEach(function(v) {
        rangeObj.test(v) && (!max || maxSV.compare(v) === -1) && (max = v, maxSV = new SemVer(max, options));
      }), max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null, minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch {
        return null;
      }
      return versions.forEach(function(v) {
        rangeObj.test(v) && (!min || minSV.compare(v) === 1) && (min = v, minSV = new SemVer(min, options));
      }), min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver) || (minver = new SemVer("0.0.0-0"), range.test(minver)))
        return minver;
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              compver.prerelease.length === 0 ? compver.patch++ : compver.prerelease.push(0), compver.raw = compver.format();
            case "":
            case ">=":
              (!minver || gt(minver, compver)) && (minver = compver);
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      return minver && range.test(minver) ? minver : null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version2, range, options) {
      return outside(version2, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version2, range, options) {
      return outside(version2, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version2, range, hilo, options) {
      version2 = new SemVer(version2, options), range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
          break;
        case "<":
          gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options))
        return !1;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2], high = null, low = null;
        if (comparators.forEach(function(comparator) {
          comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
        }), high.operator === comp || high.operator === ecomp || (!low.operator || low.operator === comp) && ltefn(version2, low.semver))
          return !1;
        if (low.operator === ecomp && ltfn(version2, low.semver))
          return !1;
      }
      return !0;
    }
    exports2.prerelease = prerelease;
    function prerelease(version2, options) {
      var parsed = parse6(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      return r1 = new Range(r1, options), r2 = new Range(r2, options), r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version2) {
      if (version2 instanceof SemVer)
        return version2;
      if (typeof version2 != "string")
        return null;
      var match2 = version2.match(re[COERCE]);
      return match2 == null ? null : parse6(match2[1] + "." + (match2[2] || "0") + "." + (match2[3] || "0"));
    }
  }
});

// ../../node_modules/npm-package-arg/npa.js
var require_npa = __commonJS({
  "../../node_modules/npm-package-arg/npa.js"(exports2, module2) {
    "use strict";
    module2.exports = npa;
    module2.exports.resolve = resolve7;
    module2.exports.Result = Result;
    var url, HostedGit, semver, path_;
    function path6() {
      return path_ || (path_ = require("path")), path_;
    }
    var validatePackageName, osenv, isWindows = process.platform === "win32" || global.FAKE_WINDOWS, hasSlashes = isWindows ? /\\|[/]/ : /[/]/, isURL = /^(?:git[+])?[a-z]+:/i, isFilename = /[.](?:tgz|tar.gz|tar)$/i;
    function npa(arg, where) {
      let name, spec;
      if (typeof arg == "object")
        return arg instanceof Result && (!where || where === arg.where) ? arg : arg.name && arg.rawSpec ? npa.resolve(arg.name, arg.rawSpec, where || arg.where) : npa(arg.raw, where || arg.where);
      let nameEndsAt = arg[0] === "@" ? arg.slice(1).indexOf("@") + 1 : arg.indexOf("@"), namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;
      return isURL.test(arg) || namePart[0] !== "@" && (hasSlashes.test(namePart) || isFilename.test(namePart)) ? spec = arg : nameEndsAt > 0 ? (name = namePart, spec = arg.slice(nameEndsAt + 1)) : (validatePackageName || (validatePackageName = require_validate_npm_package_name()), validatePackageName(arg).validForOldPackages ? name = arg : spec = arg), resolve7(name, spec, where, arg);
    }
    var isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;
    function resolve7(name, spec, where, arg) {
      let res = new Result({
        raw: arg,
        name,
        rawSpec: spec,
        fromArgument: arg != null
      });
      if (name && res.setName(name), spec && (isFilespec.test(spec) || /^file:/i.test(spec)))
        return fromFile(res, where);
      if (spec && /^npm:/i.test(spec))
        return fromAlias(res, where);
      HostedGit || (HostedGit = require_hosted_git_info());
      let hosted = HostedGit.fromUrl(spec, { noGitPlus: !0, noCommittish: !0 });
      return hosted ? fromHostedGit(res, hosted) : spec && isURL.test(spec) ? fromURL(res) : spec && (hasSlashes.test(spec) || isFilename.test(spec)) ? fromFile(res, where) : fromRegistry(res);
    }
    function invalidPackageName(name, valid) {
      let err = new Error(`Invalid package name "${name}": ${valid.errors.join("; ")}`);
      return err.code = "EINVALIDPACKAGENAME", err;
    }
    function invalidTagName(name) {
      let err = new Error(`Invalid tag name "${name}": Tags may not have any characters that encodeURIComponent encodes.`);
      return err.code = "EINVALIDTAGNAME", err;
    }
    function Result(opts) {
      this.type = opts.type, this.registry = opts.registry, this.where = opts.where, opts.raw == null ? this.raw = opts.name ? opts.name + "@" + opts.rawSpec : opts.rawSpec : this.raw = opts.raw, this.name = void 0, this.escapedName = void 0, this.scope = void 0, this.rawSpec = opts.rawSpec == null ? "" : opts.rawSpec, this.saveSpec = opts.saveSpec, this.fetchSpec = opts.fetchSpec, opts.name && this.setName(opts.name), this.gitRange = opts.gitRange, this.gitCommittish = opts.gitCommittish, this.hosted = opts.hosted;
    }
    Result.prototype.setName = function(name) {
      validatePackageName || (validatePackageName = require_validate_npm_package_name());
      let valid = validatePackageName(name);
      if (!valid.validForOldPackages)
        throw invalidPackageName(name, valid);
      return this.name = name, this.scope = name[0] === "@" ? name.slice(0, name.indexOf("/")) : void 0, this.escapedName = name.replace("/", "%2f"), this;
    };
    Result.prototype.toString = function() {
      let full = [];
      this.name != null && this.name !== "" && full.push(this.name);
      let spec = this.saveSpec || this.fetchSpec || this.rawSpec;
      return spec != null && spec !== "" && full.push(spec), full.length ? full.join("@") : this.raw;
    };
    Result.prototype.toJSON = function() {
      let result = Object.assign({}, this);
      return delete result.hosted, result;
    };
    function setGitCommittish(res, committish) {
      return committish != null && committish.length >= 7 && committish.slice(0, 7) === "semver:" ? (res.gitRange = decodeURIComponent(committish.slice(7)), res.gitCommittish = null) : res.gitCommittish = committish === "" ? null : committish, res;
    }
    var isAbsolutePath = /^[/]|^[A-Za-z]:/;
    function resolvePath(where, spec) {
      return isAbsolutePath.test(spec) ? spec : path6().resolve(where, spec);
    }
    function isAbsolute(dir) {
      return !!(dir[0] === "/" || /^[A-Za-z]:/.test(dir));
    }
    function fromFile(res, where) {
      where || (where = process.cwd()), res.type = isFilename.test(res.rawSpec) ? "file" : "directory", res.where = where;
      let spec = res.rawSpec.replace(/\\/g, "/").replace(/^file:[/]*([A-Za-z]:)/, "$1").replace(/^file:(?:[/]*([~./]))?/, "$1");
      return /^~[/]/.test(spec) ? (osenv || (osenv = require_osenv()), res.fetchSpec = resolvePath(osenv.home(), spec.slice(2)), res.saveSpec = "file:" + spec) : (res.fetchSpec = resolvePath(where, spec), isAbsolute(spec) ? res.saveSpec = "file:" + spec : res.saveSpec = "file:" + path6().relative(where, res.fetchSpec)), res;
    }
    function fromHostedGit(res, hosted) {
      return res.type = "git", res.hosted = hosted, res.saveSpec = hosted.toString({ noGitPlus: !1, noCommittish: !1 }), res.fetchSpec = hosted.getDefaultRepresentation() === "shortcut" ? null : hosted.toString(), setGitCommittish(res, hosted.committish);
    }
    function unsupportedURLType(protocol, spec) {
      let err = new Error(`Unsupported URL Type "${protocol}": ${spec}`);
      return err.code = "EUNSUPPORTEDPROTOCOL", err;
    }
    function matchGitScp(spec) {
      let matched = spec.match(/^git\+ssh:\/\/([^:#]+:[^#]+(?:\.git)?)(?:#(.*))?$/i);
      return matched && !matched[1].match(/:[0-9]+\/?.*$/i) && {
        fetchSpec: matched[1],
        gitCommittish: matched[2] == null ? null : matched[2]
      };
    }
    function fromURL(res) {
      url || (url = require("url"));
      let urlparse = url.parse(res.rawSpec);
      switch (res.saveSpec = res.rawSpec, urlparse.protocol) {
        case "git:":
        case "git+http:":
        case "git+https:":
        case "git+rsync:":
        case "git+ftp:":
        case "git+file:":
        case "git+ssh:":
          res.type = "git";
          let match2 = urlparse.protocol === "git+ssh:" && matchGitScp(res.rawSpec);
          match2 ? (setGitCommittish(res, match2.gitCommittish), res.fetchSpec = match2.fetchSpec) : (setGitCommittish(res, urlparse.hash != null ? urlparse.hash.slice(1) : ""), urlparse.protocol = urlparse.protocol.replace(/^git[+]/, ""), urlparse.protocol === "file:" && /^git\+file:\/\/[a-z]:/i.test(res.rawSpec) && (urlparse.host += ":", urlparse.hostname += ":"), delete urlparse.hash, res.fetchSpec = url.format(urlparse));
          break;
        case "http:":
        case "https:":
          res.type = "remote", res.fetchSpec = res.saveSpec;
          break;
        default:
          throw unsupportedURLType(urlparse.protocol, res.rawSpec);
      }
      return res;
    }
    function fromAlias(res, where) {
      let subSpec = npa(res.rawSpec.substr(4), where);
      if (subSpec.type === "alias")
        throw new Error("nested aliases not supported");
      if (!subSpec.registry)
        throw new Error("aliases only work for registry deps");
      return res.subSpec = subSpec, res.registry = !0, res.type = "alias", res.saveSpec = null, res.fetchSpec = null, res;
    }
    function fromRegistry(res) {
      res.registry = !0;
      let spec = res.rawSpec === "" ? "latest" : res.rawSpec;
      res.saveSpec = null, res.fetchSpec = spec, semver || (semver = require_semver());
      let version2 = semver.valid(spec, !0), range = semver.validRange(spec, !0);
      if (version2)
        res.type = "version";
      else if (range)
        res.type = "range";
      else {
        if (encodeURIComponent(spec) !== spec)
          throw invalidTagName(spec);
        res.type = "tag";
      }
      return res;
    }
  }
});

// ../../node_modules/@expo/package-manager/build/node/BasePackageManager.js
var require_BasePackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/node/BasePackageManager.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.BasePackageManager = void 0;
    var spawn_async_1 = __importDefault(require_spawnAsync()), assert_1 = __importDefault(require("assert")), fs_1 = __importDefault(require("fs")), path_1 = __importDefault(require("path")), BasePackageManager = class {
      silent;
      log;
      options;
      constructor({ silent, log: log2, env: env2 = process.env, ...options } = {}) {
        this.silent = !!silent, this.log = log2 ?? (silent ? void 0 : console.log), this.options = {
          stdio: silent ? void 0 : "inherit",
          ...options,
          env: { ...this.getDefaultEnvironment(), ...env2 }
        };
      }
      /** Get the default environment variables used when running the package manager. */
      getDefaultEnvironment() {
        return {
          ADBLOCK: "1",
          DISABLE_OPENCOLLECTIVE: "1"
        };
      }
      /** Ensure the CWD is set to a non-empty string */
      ensureCwdDefined(method) {
        var _a2;
        let cwd2 = (_a2 = this.options.cwd) == null ? void 0 : _a2.toString(), className = this.constructor.name, methodName = method ? `.${method}` : "";
        return (0, assert_1.default)(cwd2, `cwd is required for ${className}${methodName}`), cwd2;
      }
      runAsync(command) {
        var _a2;
        return (_a2 = this.log) == null || _a2.call(this, `> ${this.name} ${command.join(" ")}`), (0, spawn_async_1.default)(this.bin, command, this.options);
      }
      async versionAsync() {
        return await this.runAsync(["--version"]).then(({ stdout }) => stdout.trim());
      }
      async getConfigAsync(key) {
        return await this.runAsync(["config", "get", key]).then(({ stdout }) => stdout.trim());
      }
      async removeLockfileAsync() {
        let cwd2 = this.ensureCwdDefined("removeLockFile"), filePath = path_1.default.join(cwd2, this.lockFile);
        await fs_1.default.promises.rm(filePath, { force: !0 });
      }
      installAsync(flags = []) {
        return this.runAsync(["install", ...flags]);
      }
      async uninstallAsync() {
        let cwd2 = this.ensureCwdDefined("uninstallAsync"), modulesPath = path_1.default.join(cwd2, "node_modules");
        await fs_1.default.promises.rm(modulesPath, { force: !0, recursive: !0 });
      }
    };
    exports2.BasePackageManager = BasePackageManager;
  }
});

// ../../node_modules/yocto-queue/index.js
var require_yocto_queue = __commonJS({
  "../../node_modules/yocto-queue/index.js"(exports2, module2) {
    var Node = class {
      /// value;
      /// next;
      constructor(value) {
        this.value = value, this.next = void 0;
      }
    }, Queue = class {
      // TODO: Use private class fields when targeting Node.js 12.
      // #_head;
      // #_tail;
      // #_size;
      constructor() {
        this.clear();
      }
      enqueue(value) {
        let node = new Node(value);
        this._head ? (this._tail.next = node, this._tail = node) : (this._head = node, this._tail = node), this._size++;
      }
      dequeue() {
        let current = this._head;
        if (current)
          return this._head = this._head.next, this._size--, current.value;
      }
      clear() {
        this._head = void 0, this._tail = void 0, this._size = 0;
      }
      get size() {
        return this._size;
      }
      *[Symbol.iterator]() {
        let current = this._head;
        for (; current; )
          yield current.value, current = current.next;
      }
    };
    module2.exports = Queue;
  }
});

// ../../node_modules/find-up/node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "../../node_modules/find-up/node_modules/p-limit/index.js"(exports2, module2) {
    "use strict";
    var Queue = require_yocto_queue(), pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === 1 / 0) && concurrency > 0))
        throw new TypeError("Expected `concurrency` to be a number from 1 and up");
      let queue = new Queue(), activeCount = 0, next = () => {
        activeCount--, queue.size > 0 && queue.dequeue()();
      }, run2 = async (fn, resolve7, ...args) => {
        activeCount++;
        let result = (async () => fn(...args))();
        resolve7(result);
        try {
          await result;
        } catch {
        }
        next();
      }, enqueue = (fn, resolve7, ...args) => {
        queue.enqueue(run2.bind(null, fn, resolve7, ...args)), (async () => (await Promise.resolve(), activeCount < concurrency && queue.size > 0 && queue.dequeue()()))();
      }, generator = (fn, ...args) => new Promise((resolve7) => {
        enqueue(fn, resolve7, ...args);
      });
      return Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.size
        },
        clearQueue: {
          value: () => {
            queue.clear();
          }
        }
      }), generator;
    };
    module2.exports = pLimit;
  }
});

// ../../node_modules/find-up/node_modules/p-locate/index.js
var require_p_locate = __commonJS({
  "../../node_modules/find-up/node_modules/p-locate/index.js"(exports2, module2) {
    "use strict";
    var pLimit = require_p_limit(), EndError = class extends Error {
      constructor(value) {
        super(), this.value = value;
      }
    }, testElement = async (element, tester) => tester(await element), finder = async (element) => {
      let values = await Promise.all(element);
      if (values[1] === !0)
        throw new EndError(values[0]);
      return !1;
    }, pLocate = async (iterable, tester, options) => {
      options = {
        concurrency: 1 / 0,
        preserveOrder: !0,
        ...options
      };
      let limit = pLimit(options.concurrency), items = [...iterable].map((element) => [element, limit(testElement, element, tester)]), checkLimit = pLimit(options.preserveOrder ? 1 : 1 / 0);
      try {
        await Promise.all(items.map((element) => checkLimit(finder, element)));
      } catch (error) {
        if (error instanceof EndError)
          return error.value;
        throw error;
      }
    };
    module2.exports = pLocate;
  }
});

// ../../node_modules/find-up/node_modules/locate-path/index.js
var require_locate_path = __commonJS({
  "../../node_modules/find-up/node_modules/locate-path/index.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), fs7 = require("fs"), { promisify: promisify2 } = require("util"), pLocate = require_p_locate(), fsStat = promisify2(fs7.stat), fsLStat = promisify2(fs7.lstat), typeMappings = {
      directory: "isDirectory",
      file: "isFile"
    };
    function checkType({ type }) {
      if (!(type in typeMappings))
        throw new Error(`Invalid type specified: ${type}`);
    }
    var matchType = (type, stat3) => type === void 0 || stat3[typeMappings[type]]();
    module2.exports = async (paths, options) => {
      options = {
        cwd: process.cwd(),
        type: "file",
        allowSymlinks: !0,
        ...options
      }, checkType(options);
      let statFn = options.allowSymlinks ? fsStat : fsLStat;
      return pLocate(paths, async (path_) => {
        try {
          let stat3 = await statFn(path6.resolve(options.cwd, path_));
          return matchType(options.type, stat3);
        } catch {
          return !1;
        }
      }, options);
    };
    module2.exports.sync = (paths, options) => {
      options = {
        cwd: process.cwd(),
        allowSymlinks: !0,
        type: "file",
        ...options
      }, checkType(options);
      let statFn = options.allowSymlinks ? fs7.statSync : fs7.lstatSync;
      for (let path_ of paths)
        try {
          let stat3 = statFn(path6.resolve(options.cwd, path_));
          if (matchType(options.type, stat3))
            return path_;
        } catch {
        }
    };
  }
});

// ../../node_modules/path-exists/index.js
var require_path_exists2 = __commonJS({
  "../../node_modules/path-exists/index.js"(exports2, module2) {
    "use strict";
    var fs7 = require("fs"), { promisify: promisify2 } = require("util"), pAccess = promisify2(fs7.access);
    module2.exports = async (path6) => {
      try {
        return await pAccess(path6), !0;
      } catch {
        return !1;
      }
    };
    module2.exports.sync = (path6) => {
      try {
        return fs7.accessSync(path6), !0;
      } catch {
        return !1;
      }
    };
  }
});

// ../../node_modules/find-up/index.js
var require_find_up = __commonJS({
  "../../node_modules/find-up/index.js"(exports2, module2) {
    "use strict";
    var path6 = require("path"), locatePath = require_locate_path(), pathExists3 = require_path_exists2(), stop = Symbol("findUp.stop");
    module2.exports = async (name, options = {}) => {
      let directory = path6.resolve(options.cwd || ""), { root } = path6.parse(directory), paths = [].concat(name), runMatcher = async (locateOptions) => {
        if (typeof name != "function")
          return locatePath(paths, locateOptions);
        let foundPath = await name(locateOptions.cwd);
        return typeof foundPath == "string" ? locatePath([foundPath], locateOptions) : foundPath;
      };
      for (; ; ) {
        let foundPath = await runMatcher({ ...options, cwd: directory });
        if (foundPath === stop)
          return;
        if (foundPath)
          return path6.resolve(directory, foundPath);
        if (directory === root)
          return;
        directory = path6.dirname(directory);
      }
    };
    module2.exports.sync = (name, options = {}) => {
      let directory = path6.resolve(options.cwd || ""), { root } = path6.parse(directory), paths = [].concat(name), runMatcher = (locateOptions) => {
        if (typeof name != "function")
          return locatePath.sync(paths, locateOptions);
        let foundPath = name(locateOptions.cwd);
        return typeof foundPath == "string" ? locatePath.sync([foundPath], locateOptions) : foundPath;
      };
      for (; ; ) {
        let foundPath = runMatcher({ ...options, cwd: directory });
        if (foundPath === stop)
          return;
        if (foundPath)
          return path6.resolve(directory, foundPath);
        if (directory === root)
          return;
        directory = path6.dirname(directory);
      }
    };
    module2.exports.exists = pathExists3;
    module2.exports.sync.exists = pathExists3.sync;
    module2.exports.stop = stop;
  }
});

// ../../node_modules/find-yarn-workspace-root/index.js
var require_find_yarn_workspace_root = __commonJS({
  "../../node_modules/find-yarn-workspace-root/index.js"(exports2, module2) {
    "use strict";
    var fs7 = require("fs"), micromatch = require_micromatch(), path6 = require("path");
    module2.exports = findWorkspaceRoot;
    function findWorkspaceRoot(initial) {
      initial || (initial = process.cwd());
      let previous = null, current = path6.normalize(initial);
      do {
        let manifest = readPackageJSON(current), workspaces = extractWorkspaces(manifest);
        if (workspaces) {
          let relativePath = path6.relative(current, initial);
          return relativePath === "" || micromatch([relativePath], workspaces).length > 0 ? current : null;
        }
        previous = current, current = path6.dirname(current);
      } while (current !== previous);
      return null;
    }
    function extractWorkspaces(manifest) {
      let workspaces = (manifest || {}).workspaces;
      return workspaces && workspaces.packages || (Array.isArray(workspaces) ? workspaces : null);
    }
    function readPackageJSON(dir) {
      let file = path6.join(dir, "package.json");
      return fs7.existsSync(file) ? JSON.parse(fs7.readFileSync(file, "utf8")) : null;
    }
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/common.js
var require_common3 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/common.js"(exports2, module2) {
    "use strict";
    function isNothing(subject) {
      return typeof subject > "u" || subject === null;
    }
    function isObject(subject) {
      return typeof subject == "object" && subject !== null;
    }
    function toArray(sequence) {
      return Array.isArray(sequence) ? sequence : isNothing(sequence) ? [] : [sequence];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source)
        for (sourceKeys = Object.keys(source), index = 0, length = sourceKeys.length; index < length; index += 1)
          key = sourceKeys[index], target[key] = source[key];
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1)
        result += string;
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend;
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/exception.js"(exports2, module2) {
    "use strict";
    function YAMLException(reason, mark) {
      Error.call(this), this.name = "YAMLException", this.reason = reason, this.mark = mark, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function(compact) {
      var result = this.name + ": ";
      return result += this.reason || "(unknown reason)", !compact && this.mark && (result += " " + this.mark.toString()), result;
    };
    module2.exports = YAMLException;
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/mark.js"(exports2, module2) {
    "use strict";
    var common = require_common3();
    function Mark(name, buffer, position, line, column) {
      this.name = name, this.buffer = buffer, this.position = position, this.line = line, this.column = column;
    }
    Mark.prototype.getSnippet = function(indent, maxLength) {
      var head, start, tail, end, snippet;
      if (!this.buffer)
        return null;
      for (indent = indent || 4, maxLength = maxLength || 75, head = "", start = this.position; start > 0 && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(start - 1)) === -1; )
        if (start -= 1, this.position - start > maxLength / 2 - 1) {
          head = " ... ", start += 5;
          break;
        }
      for (tail = "", end = this.position; end < this.buffer.length && `\0\r
\x85\u2028\u2029`.indexOf(this.buffer.charAt(end)) === -1; )
        if (end += 1, end - this.position > maxLength / 2 - 1) {
          tail = " ... ", end -= 5;
          break;
        }
      return snippet = this.buffer.slice(start, end), common.repeat(" ", indent) + head + snippet + tail + `
` + common.repeat(" ", indent + this.position - start + head.length) + "^";
    };
    Mark.prototype.toString = function(compact) {
      var snippet, where = "";
      return this.name && (where += 'in "' + this.name + '" '), where += "at line " + (this.line + 1) + ", column " + (this.column + 1), compact || (snippet = this.getSnippet(), snippet && (where += `:
` + snippet)), where;
    };
    module2.exports = Mark;
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type.js"(exports2, module2) {
    "use strict";
    var YAMLException = require_exception(), TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "defaultStyle",
      "styleAliases"
    ], YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      return map !== null && Object.keys(map).forEach(function(style) {
        map[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      }), result;
    }
    function Type(tag, options) {
      if (options = options || {}, Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1)
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }), this.tag = tag, this.kind = options.kind || null, this.resolve = options.resolve || function() {
        return !0;
      }, this.construct = options.construct || function(data) {
        return data;
      }, this.instanceOf = options.instanceOf || null, this.predicate = options.predicate || null, this.represent = options.represent || null, this.defaultStyle = options.defaultStyle || null, this.styleAliases = compileStyleAliases(options.styleAliases || null), YAML_NODE_KINDS.indexOf(this.kind) === -1)
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
    module2.exports = Type;
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema4 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/schema.js"(exports2, module2) {
    "use strict";
    var common = require_common3(), YAMLException = require_exception(), Type = require_type();
    function compileList(schema, name, result) {
      var exclude = [];
      return schema.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name, result);
      }), schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
          previousType.tag === currentType.tag && previousType.kind === currentType.kind && exclude.push(previousIndex);
        }), result.push(currentType);
      }), result.filter(function(type, index) {
        return exclude.indexOf(index) === -1;
      });
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;
      function collectType(type) {
        result[type.kind][type.tag] = result.fallback[type.tag] = type;
      }
      for (index = 0, length = arguments.length; index < length; index += 1)
        arguments[index].forEach(collectType);
      return result;
    }
    function Schema(definition) {
      this.include = definition.include || [], this.implicit = definition.implicit || [], this.explicit = definition.explicit || [], this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar")
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }), this.compiledImplicit = compileList(this, "implicit", []), this.compiledExplicit = compileList(this, "explicit", []), this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema.DEFAULT = null;
    Schema.create = function() {
      var schemas, types2;
      switch (arguments.length) {
        case 1:
          schemas = Schema.DEFAULT, types2 = arguments[0];
          break;
        case 2:
          schemas = arguments[0], types2 = arguments[1];
          break;
        default:
          throw new YAMLException("Wrong number of arguments for Schema.create function");
      }
      if (schemas = common.toArray(schemas), types2 = common.toArray(types2), !schemas.every(function(schema) {
        return schema instanceof Schema;
      }))
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
      if (!types2.every(function(type) {
        return type instanceof Type;
      }))
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      return new Schema({
        include: schemas,
        explicit: types2
      });
    };
    module2.exports = Schema;
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/str.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq2 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/seq.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map2 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/map.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema4();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq2(),
        require_map2()
      ]
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null2 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/null.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return !0;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool3 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/bool.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return !1;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int3 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/int.js"(exports2, module2) {
    "use strict";
    var common = require_common3(), Type = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return !1;
      var max = data.length, index = 0, hasDigits = !1, ch;
      if (!max)
        return !1;
      if (ch = data[index], (ch === "-" || ch === "+") && (ch = data[++index]), ch === "0") {
        if (index + 1 === max)
          return !0;
        if (ch = data[++index], ch === "b") {
          for (index++; index < max; index++)
            if (ch = data[index], ch !== "_") {
              if (ch !== "0" && ch !== "1")
                return !1;
              hasDigits = !0;
            }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          for (index++; index < max; index++)
            if (ch = data[index], ch !== "_") {
              if (!isHexCode(data.charCodeAt(index)))
                return !1;
              hasDigits = !0;
            }
          return hasDigits && ch !== "_";
        }
        for (; index < max; index++)
          if (ch = data[index], ch !== "_") {
            if (!isOctCode(data.charCodeAt(index)))
              return !1;
            hasDigits = !0;
          }
        return hasDigits && ch !== "_";
      }
      if (ch === "_")
        return !1;
      for (; index < max; index++)
        if (ch = data[index], ch !== "_") {
          if (ch === ":")
            break;
          if (!isDecCode(data.charCodeAt(index)))
            return !1;
          hasDigits = !0;
        }
      return !hasDigits || ch === "_" ? !1 : ch !== ":" ? !0 : /^(:[0-5]?[0-9])+$/.test(data.slice(index));
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch, base, digits = [];
      return value.indexOf("_") !== -1 && (value = value.replace(/_/g, "")), ch = value[0], (ch === "-" || ch === "+") && (ch === "-" && (sign = -1), value = value.slice(1), ch = value[0]), value === "0" ? 0 : ch === "0" ? value[1] === "b" ? sign * parseInt(value.slice(2), 2) : value[1] === "x" ? sign * parseInt(value, 16) : sign * parseInt(value, 8) : value.indexOf(":") !== -1 ? (value.split(":").forEach(function(v) {
        digits.unshift(parseInt(v, 10));
      }), value = 0, base = 1, digits.forEach(function(d) {
        value += d * base, base *= 60;
      }), sign * value) : sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common.isNegativeZero(object);
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float3 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/float.js"(exports2, module2) {
    "use strict";
    var common = require_common3(), Type = require_type(), YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat(data) {
      return !(data === null || !YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === "_");
    }
    function constructYamlFloat(data) {
      var value, sign, base, digits;
      return value = data.replace(/_/g, "").toLowerCase(), sign = value[0] === "-" ? -1 : 1, digits = [], "+-".indexOf(value[0]) >= 0 && (value = value.slice(1)), value === ".inf" ? sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : value === ".nan" ? NaN : value.indexOf(":") >= 0 ? (value.split(":").forEach(function(v) {
        digits.unshift(parseFloat(v, 10));
      }), value = 0, base = 1, digits.forEach(function(d) {
        value += d * base, base *= 60;
      }), sign * value) : sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object))
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      else if (Number.POSITIVE_INFINITY === object)
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      else if (Number.NEGATIVE_INFINITY === object)
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      else if (common.isNegativeZero(object))
        return "-0.0";
      return res = object.toString(10), SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json2 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/schema/json.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema4();
    module2.exports = new Schema({
      include: [
        require_failsafe()
      ],
      implicit: [
        require_null2(),
        require_bool3(),
        require_int3(),
        require_float3()
      ]
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core2 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/schema/core.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema4();
    module2.exports = new Schema({
      include: [
        require_json2()
      ]
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp2 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/timestamp.js"(exports2, module2) {
    "use strict";
    var Type = require_type(), YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    ), YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    function resolveYamlTimestamp(data) {
      return data === null ? !1 : YAML_DATE_REGEXP.exec(data) !== null || YAML_TIMESTAMP_REGEXP.exec(data) !== null;
    }
    function constructYamlTimestamp(data) {
      var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      if (match2 = YAML_DATE_REGEXP.exec(data), match2 === null && (match2 = YAML_TIMESTAMP_REGEXP.exec(data)), match2 === null)
        throw new Error("Date resolve error");
      if (year = +match2[1], month = +match2[2] - 1, day = +match2[3], !match2[4])
        return new Date(Date.UTC(year, month, day));
      if (hour = +match2[4], minute = +match2[5], second = +match2[6], match2[7]) {
        for (fraction = match2[7].slice(0, 3); fraction.length < 3; )
          fraction += "0";
        fraction = +fraction;
      }
      return match2[9] && (tz_hour = +match2[10], tz_minute = +(match2[11] || 0), delta = (tz_hour * 60 + tz_minute) * 6e4, match2[9] === "-" && (delta = -delta)), date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction)), delta && date.setTime(date.getTime() - delta), date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/merge.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary2 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/binary.js"(exports2, module2) {
    "use strict";
    var NodeBuffer;
    try {
      _require = require, NodeBuffer = _require("buffer").Buffer;
    } catch {
    }
    var _require, Type = require_type(), BASE64_MAP = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
    function resolveYamlBinary(data) {
      if (data === null)
        return !1;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++)
        if (code = map.indexOf(data.charAt(idx)), !(code > 64)) {
          if (code < 0)
            return !1;
          bitlen += 6;
        }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++)
        idx % 4 === 0 && idx && (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)), bits = bits << 6 | map.indexOf(input.charAt(idx));
      return tailbits = max % 4 * 6, tailbits === 0 ? (result.push(bits >> 16 & 255), result.push(bits >> 8 & 255), result.push(bits & 255)) : tailbits === 18 ? (result.push(bits >> 10 & 255), result.push(bits >> 2 & 255)) : tailbits === 12 && result.push(bits >> 4 & 255), NodeBuffer ? NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result) : result;
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++)
        idx % 3 === 0 && idx && (result += map[bits >> 18 & 63], result += map[bits >> 12 & 63], result += map[bits >> 6 & 63], result += map[bits & 63]), bits = (bits << 8) + object[idx];
      return tail = max % 3, tail === 0 ? (result += map[bits >> 18 & 63], result += map[bits >> 12 & 63], result += map[bits >> 6 & 63], result += map[bits & 63]) : tail === 2 ? (result += map[bits >> 10 & 63], result += map[bits >> 4 & 63], result += map[bits << 2 & 63], result += map[64]) : tail === 1 && (result += map[bits >> 2 & 63], result += map[bits << 4 & 63], result += map[64], result += map[64]), result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap2 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/omap.js"(exports2, module2) {
    "use strict";
    var Type = require_type(), _hasOwnProperty = Object.prototype.hasOwnProperty, _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return !0;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (pair = object[index], pairHasKey = !1, _toString.call(pair) !== "[object Object]")
          return !1;
        for (pairKey in pair)
          if (_hasOwnProperty.call(pair, pairKey))
            if (!pairHasKey)
              pairHasKey = !0;
            else
              return !1;
        if (!pairHasKey)
          return !1;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return !1;
      }
      return !0;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs2 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/pairs.js"(exports2, module2) {
    "use strict";
    var Type = require_type(), _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return !0;
      var index, length, pair, keys, result, object = data;
      for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1) {
        if (pair = object[index], _toString.call(pair) !== "[object Object]" || (keys = Object.keys(pair), keys.length !== 1))
          return !1;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return !0;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index, length, pair, keys, result, object = data;
      for (result = new Array(object.length), index = 0, length = object.length; index < length; index += 1)
        pair = object[index], keys = Object.keys(pair), result[index] = [keys[0], pair[keys[0]]];
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set2 = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/set.js"(exports2, module2) {
    "use strict";
    var Type = require_type(), _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return !0;
      var key, object = data;
      for (key in object)
        if (_hasOwnProperty.call(object, key) && object[key] !== null)
          return !1;
      return !0;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema4();
    module2.exports = new Schema({
      include: [
        require_core2()
      ],
      implicit: [
        require_timestamp2(),
        require_merge()
      ],
      explicit: [
        require_binary2(),
        require_omap2(),
        require_pairs2(),
        require_set2()
      ]
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveJavascriptUndefined() {
      return !0;
    }
    function constructJavascriptUndefined() {
    }
    function representJavascriptUndefined() {
      return "";
    }
    function isUndefined(object) {
      return typeof object > "u";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/undefined", {
      kind: "scalar",
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined,
      represent: representJavascriptUndefined
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveJavascriptRegExp(data) {
      if (data === null || data.length === 0)
        return !1;
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      return !(regexp[0] === "/" && (tail && (modifiers = tail[1]), modifiers.length > 3 || regexp[regexp.length - modifiers.length - 1] !== "/"));
    }
    function constructJavascriptRegExp(data) {
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      return regexp[0] === "/" && (tail && (modifiers = tail[1]), regexp = regexp.slice(1, regexp.length - modifiers.length - 1)), new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object) {
      var result = "/" + object.source + "/";
      return object.global && (result += "g"), object.multiline && (result += "m"), object.ignoreCase && (result += "i"), result;
    }
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/regexp", {
      kind: "scalar",
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp,
      represent: representJavascriptRegExp
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/type/js/function.js"(exports2, module2) {
    "use strict";
    var esprima;
    try {
      _require = require, esprima = _require("esprima");
    } catch {
      typeof window < "u" && (esprima = window.esprima);
    }
    var _require, Type = require_type();
    function resolveJavascriptFunction(data) {
      if (data === null)
        return !1;
      try {
        var source = "(" + data + ")", ast = esprima.parse(source, { range: !0 });
        return !(ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression");
      } catch {
        return !1;
      }
    }
    function constructJavascriptFunction(data) {
      var source = "(" + data + ")", ast = esprima.parse(source, { range: !0 }), params = [], body;
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression")
        throw new Error("Failed to resolve function");
      return ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
      }), body = ast.body[0].expression.body.range, ast.body[0].expression.body.type === "BlockStatement" ? new Function(params, source.slice(body[0] + 1, body[1] - 1)) : new Function(params, "return " + source.slice(body[0], body[1]));
    }
    function representJavascriptFunction(object) {
      return object.toString();
    }
    function isFunction(object) {
      return Object.prototype.toString.call(object) === "[object Function]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/function", {
      kind: "scalar",
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction,
      represent: representJavascriptFunction
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/schema/default_full.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema4();
    module2.exports = Schema.DEFAULT = new Schema({
      include: [
        require_default_safe()
      ],
      explicit: [
        require_undefined(),
        require_regexp(),
        require_function()
      ]
    });
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/loader.js"(exports2, module2) {
    "use strict";
    var common = require_common3(), YAMLException = require_exception(), Mark = require_mark(), DEFAULT_SAFE_SCHEMA = require_default_safe(), DEFAULT_FULL_SCHEMA = require_default_full(), _hasOwnProperty = Object.prototype.hasOwnProperty, CONTEXT_FLOW_IN = 1, CONTEXT_FLOW_OUT = 2, CONTEXT_BLOCK_IN = 3, CONTEXT_BLOCK_OUT = 4, CHOMPING_CLIP = 1, CHOMPING_STRIP = 2, CHOMPING_KEEP = 3, PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/, PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/, PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i, PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      return 48 <= c && c <= 57 ? c - 48 : (lc = c | 32, 97 <= lc && lc <= 102 ? lc - 97 + 10 : -1);
    }
    function escapedHexLen(c) {
      return c === 120 ? 2 : c === 117 ? 4 : c === 85 ? 8 : 0;
    }
    function fromDecimalCode(c) {
      return 48 <= c && c <= 57 ? c - 48 : -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 || c === 9 ? "	" : c === 110 ? `
` : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      return c <= 65535 ? String.fromCharCode(c) : String.fromCharCode(
        (c - 65536 >> 10) + 55296,
        (c - 65536 & 1023) + 56320
      );
    }
    var simpleEscapeCheck = new Array(256), simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++)
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0, simpleEscapeMap[i] = simpleEscapeSequence(i);
    var i;
    function State(input, options) {
      this.input = input, this.filename = options.filename || null, this.schema = options.schema || DEFAULT_FULL_SCHEMA, this.onWarning = options.onWarning || null, this.legacy = options.legacy || !1, this.json = options.json || !1, this.listener = options.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = input.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
    }
    function generateError(state, message) {
      return new YAMLException(
        message,
        new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
      );
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      state.onWarning && state.onWarning.call(null, generateError(state, message));
    }
    var directiveHandlers = {
      YAML: function(state, name, args) {
        var match2, major, minor;
        state.version !== null && throwError(state, "duplication of %YAML directive"), args.length !== 1 && throwError(state, "YAML directive accepts exactly one argument"), match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]), match2 === null && throwError(state, "ill-formed argument of the YAML directive"), major = parseInt(match2[1], 10), minor = parseInt(match2[2], 10), major !== 1 && throwError(state, "unacceptable YAML version of the document"), state.version = args[0], state.checkLineBreaks = minor < 2, minor !== 1 && minor !== 2 && throwWarning(state, "unsupported YAML version of the document");
      },
      TAG: function(state, name, args) {
        var handle, prefix;
        args.length !== 2 && throwError(state, "TAG directive accepts exactly two arguments"), handle = args[0], prefix = args[1], PATTERN_TAG_HANDLE.test(handle) || throwError(state, "ill-formed tag handle (first argument) of the TAG directive"), _hasOwnProperty.call(state.tagMap, handle) && throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle'), PATTERN_TAG_URI.test(prefix) || throwError(state, "ill-formed tag prefix (second argument) of the TAG directive"), state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        if (_result = state.input.slice(start, end), checkJson)
          for (_position = 0, _length = _result.length; _position < _length; _position += 1)
            _character = _result.charCodeAt(_position), _character === 9 || 32 <= _character && _character <= 1114111 || throwError(state, "expected valid JSON character");
        else
          PATTERN_NON_PRINTABLE.test(_result) && throwError(state, "the stream contains non-printable characters");
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      for (common.isObject(source) || throwError(state, "cannot merge mappings; the provided source object is unacceptable"), sourceKeys = Object.keys(source), index = 0, quantity = sourceKeys.length; index < quantity; index += 1)
        key = sourceKeys[index], _hasOwnProperty.call(destination, key) || (destination[key] = source[key], overridableKeys[key] = !0);
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode))
        for (keyNode = Array.prototype.slice.call(keyNode), index = 0, quantity = keyNode.length; index < quantity; index += 1)
          Array.isArray(keyNode[index]) && throwError(state, "nested arrays are not supported inside keys"), typeof keyNode == "object" && _class(keyNode[index]) === "[object Object]" && (keyNode[index] = "[object Object]");
      if (typeof keyNode == "object" && _class(keyNode) === "[object Object]" && (keyNode = "[object Object]"), keyNode = String(keyNode), _result === null && (_result = {}), keyTag === "tag:yaml.org,2002:merge")
        if (Array.isArray(valueNode))
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1)
            mergeMappings(state, _result, valueNode[index], overridableKeys);
        else
          mergeMappings(state, _result, valueNode, overridableKeys);
      else
        !state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode) && (state.line = startLine || state.line, state.position = startPos || state.position, throwError(state, "duplicated mapping key")), _result[keyNode] = valueNode, delete overridableKeys[keyNode];
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position), ch === 10 ? state.position++ : ch === 13 ? (state.position++, state.input.charCodeAt(state.position) === 10 && state.position++) : throwError(state, "a line break is expected"), state.line += 1, state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      for (var lineBreaks = 0, ch = state.input.charCodeAt(state.position); ch !== 0; ) {
        for (; is_WHITE_SPACE(ch); )
          ch = state.input.charCodeAt(++state.position);
        if (allowComments && ch === 35)
          do
            ch = state.input.charCodeAt(++state.position);
          while (ch !== 10 && ch !== 13 && ch !== 0);
        if (is_EOL(ch))
          for (readLineBreak(state), ch = state.input.charCodeAt(state.position), lineBreaks++, state.lineIndent = 0; ch === 32; )
            state.lineIndent++, ch = state.input.charCodeAt(++state.position);
        else
          break;
      }
      return checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent && throwWarning(state, "deficient indentation"), lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      return ch = state.input.charCodeAt(_position), !!((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2) && (_position += 3, ch = state.input.charCodeAt(_position), ch === 0 || is_WS_OR_EOL(ch)));
    }
    function writeFoldedLines(state, count) {
      count === 1 ? state.result += " " : count > 1 && (state.result += common.repeat(`
`, count - 1));
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      if (ch = state.input.charCodeAt(state.position), is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96 || (ch === 63 || ch === 45) && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)))
        return !1;
      for (state.kind = "scalar", state.result = "", captureStart = captureEnd = state.position, hasPendingContent = !1; ch !== 0; ) {
        if (ch === 58) {
          if (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following))
            break;
        } else if (ch === 35) {
          if (preceding = state.input.charCodeAt(state.position - 1), is_WS_OR_EOL(preceding))
            break;
        } else {
          if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch))
            break;
          if (is_EOL(ch))
            if (_line = state.line, _lineStart = state.lineStart, _lineIndent = state.lineIndent, skipSeparationSpace(state, !1, -1), state.lineIndent >= nodeIndent) {
              hasPendingContent = !0, ch = state.input.charCodeAt(state.position);
              continue;
            } else {
              state.position = captureEnd, state.line = _line, state.lineStart = _lineStart, state.lineIndent = _lineIndent;
              break;
            }
        }
        hasPendingContent && (captureSegment(state, captureStart, captureEnd, !1), writeFoldedLines(state, state.line - _line), captureStart = captureEnd = state.position, hasPendingContent = !1), is_WHITE_SPACE(ch) || (captureEnd = state.position + 1), ch = state.input.charCodeAt(++state.position);
      }
      return captureSegment(state, captureStart, captureEnd, !1), state.result ? !0 : (state.kind = _kind, state.result = _result, !1);
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      if (ch = state.input.charCodeAt(state.position), ch !== 39)
        return !1;
      for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; )
        if (ch === 39)
          if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), ch === 39)
            captureStart = state.position, state.position++, captureEnd = state.position;
          else
            return !0;
        else
          is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError(state, "unexpected end of the document within a single quoted scalar") : (state.position++, captureEnd = state.position);
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      if (ch = state.input.charCodeAt(state.position), ch !== 34)
        return !1;
      for (state.kind = "scalar", state.result = "", state.position++, captureStart = captureEnd = state.position; (ch = state.input.charCodeAt(state.position)) !== 0; ) {
        if (ch === 34)
          return captureSegment(state, captureStart, state.position, !0), state.position++, !0;
        if (ch === 92) {
          if (captureSegment(state, captureStart, state.position, !0), ch = state.input.charCodeAt(++state.position), is_EOL(ch))
            skipSeparationSpace(state, !1, nodeIndent);
          else if (ch < 256 && simpleEscapeCheck[ch])
            state.result += simpleEscapeMap[ch], state.position++;
          else if ((tmp = escapedHexLen(ch)) > 0) {
            for (hexLength = tmp, hexResult = 0; hexLength > 0; hexLength--)
              ch = state.input.charCodeAt(++state.position), (tmp = fromHexCode(ch)) >= 0 ? hexResult = (hexResult << 4) + tmp : throwError(state, "expected hexadecimal character");
            state.result += charFromCodepoint(hexResult), state.position++;
          } else
            throwError(state, "unknown escape sequence");
          captureStart = captureEnd = state.position;
        } else
          is_EOL(ch) ? (captureSegment(state, captureStart, captureEnd, !0), writeFoldedLines(state, skipSeparationSpace(state, !1, nodeIndent)), captureStart = captureEnd = state.position) : state.position === state.lineStart && testDocumentSeparator(state) ? throwError(state, "unexpected end of the document within a double quoted scalar") : (state.position++, captureEnd = state.position);
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = !0, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
      if (ch = state.input.charCodeAt(state.position), ch === 91)
        terminator = 93, isMapping = !1, _result = [];
      else if (ch === 123)
        terminator = 125, isMapping = !0, _result = {};
      else
        return !1;
      for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(++state.position); ch !== 0; ) {
        if (skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === terminator)
          return state.position++, state.tag = _tag, state.anchor = _anchor, state.kind = isMapping ? "mapping" : "sequence", state.result = _result, !0;
        readNext || throwError(state, "missed comma between flow collection entries"), keyTag = keyNode = valueNode = null, isPair = isExplicitPair = !1, ch === 63 && (following = state.input.charCodeAt(state.position + 1), is_WS_OR_EOL(following) && (isPair = isExplicitPair = !0, state.position++, skipSeparationSpace(state, !0, nodeIndent))), _line = state.line, composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), keyTag = state.tag, keyNode = state.result, skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), (isExplicitPair || state.line === _line) && ch === 58 && (isPair = !0, ch = state.input.charCodeAt(++state.position), skipSeparationSpace(state, !0, nodeIndent), composeNode(state, nodeIndent, CONTEXT_FLOW_IN, !1, !0), valueNode = state.result), isMapping ? storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode) : isPair ? _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode)) : _result.push(keyNode), skipSeparationSpace(state, !0, nodeIndent), ch = state.input.charCodeAt(state.position), ch === 44 ? (readNext = !0, ch = state.input.charCodeAt(++state.position)) : readNext = !1;
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = !1, detectedIndent = !1, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = !1, tmp, ch;
      if (ch = state.input.charCodeAt(state.position), ch === 124)
        folding = !1;
      else if (ch === 62)
        folding = !0;
      else
        return !1;
      for (state.kind = "scalar", state.result = ""; ch !== 0; )
        if (ch = state.input.charCodeAt(++state.position), ch === 43 || ch === 45)
          CHOMPING_CLIP === chomping ? chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP : throwError(state, "repeat of a chomping mode identifier");
        else if ((tmp = fromDecimalCode(ch)) >= 0)
          tmp === 0 ? throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one") : detectedIndent ? throwError(state, "repeat of an indentation width identifier") : (textIndent = nodeIndent + tmp - 1, detectedIndent = !0);
        else
          break;
      if (is_WHITE_SPACE(ch)) {
        do
          ch = state.input.charCodeAt(++state.position);
        while (is_WHITE_SPACE(ch));
        if (ch === 35)
          do
            ch = state.input.charCodeAt(++state.position);
          while (!is_EOL(ch) && ch !== 0);
      }
      for (; ch !== 0; ) {
        for (readLineBreak(state), state.lineIndent = 0, ch = state.input.charCodeAt(state.position); (!detectedIndent || state.lineIndent < textIndent) && ch === 32; )
          state.lineIndent++, ch = state.input.charCodeAt(++state.position);
        if (!detectedIndent && state.lineIndent > textIndent && (textIndent = state.lineIndent), is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          chomping === CHOMPING_KEEP ? state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines) : chomping === CHOMPING_CLIP && didReadContent && (state.result += `
`);
          break;
        }
        for (folding ? is_WHITE_SPACE(ch) ? (atMoreIndented = !0, state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines)) : atMoreIndented ? (atMoreIndented = !1, state.result += common.repeat(`
`, emptyLines + 1)) : emptyLines === 0 ? didReadContent && (state.result += " ") : state.result += common.repeat(`
`, emptyLines) : state.result += common.repeat(`
`, didReadContent ? 1 + emptyLines : emptyLines), didReadContent = !0, detectedIndent = !0, emptyLines = 0, captureStart = state.position; !is_EOL(ch) && ch !== 0; )
          ch = state.input.charCodeAt(++state.position);
        captureSegment(state, captureStart, state.position, !1);
      }
      return !0;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = !1, ch;
      for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0 && !(ch !== 45 || (following = state.input.charCodeAt(state.position + 1), !is_WS_OR_EOL(following))); ) {
        if (detected = !0, state.position++, skipSeparationSpace(state, !0, -1) && state.lineIndent <= nodeIndent) {
          _result.push(null), ch = state.input.charCodeAt(state.position);
          continue;
        }
        if (_line = state.line, composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, !1, !0), _result.push(state.result), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), (state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
          throwError(state, "bad indentation of a sequence entry");
        else if (state.lineIndent < nodeIndent)
          break;
      }
      return detected ? (state.tag = _tag, state.anchor = _anchor, state.kind = "sequence", state.result = _result, !0) : !1;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = !1, detected = !1, ch;
      for (state.anchor !== null && (state.anchorMap[state.anchor] = _result), ch = state.input.charCodeAt(state.position); ch !== 0; ) {
        if (following = state.input.charCodeAt(state.position + 1), _line = state.line, _pos = state.position, (ch === 63 || ch === 58) && is_WS_OR_EOL(following))
          ch === 63 ? (atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !0, allowCompact = !0) : atExplicitKey ? (atExplicitKey = !1, allowCompact = !0) : throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), state.position += 1, ch = following;
        else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, !1, !0))
          if (state.line === _line) {
            for (ch = state.input.charCodeAt(state.position); is_WHITE_SPACE(ch); )
              ch = state.input.charCodeAt(++state.position);
            if (ch === 58)
              ch = state.input.charCodeAt(++state.position), is_WS_OR_EOL(ch) || throwError(state, "a whitespace character is expected after the key-value separator within a block mapping"), atExplicitKey && (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), keyTag = keyNode = valueNode = null), detected = !0, atExplicitKey = !1, allowCompact = !1, keyTag = state.tag, keyNode = state.result;
            else if (detected)
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            else
              return state.tag = _tag, state.anchor = _anchor, !0;
          } else if (detected)
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          else
            return state.tag = _tag, state.anchor = _anchor, !0;
        else
          break;
        if ((state.line === _line || state.lineIndent > nodeIndent) && (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, !0, allowCompact) && (atExplicitKey ? keyNode = state.result : valueNode = state.result), atExplicitKey || (storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos), keyTag = keyNode = valueNode = null), skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position)), state.lineIndent > nodeIndent && ch !== 0)
          throwError(state, "bad indentation of a mapping entry");
        else if (state.lineIndent < nodeIndent)
          break;
      }
      return atExplicitKey && storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null), detected && (state.tag = _tag, state.anchor = _anchor, state.kind = "mapping", state.result = _result), detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = !1, isNamed = !1, tagHandle, tagName, ch;
      if (ch = state.input.charCodeAt(state.position), ch !== 33)
        return !1;
      if (state.tag !== null && throwError(state, "duplication of a tag property"), ch = state.input.charCodeAt(++state.position), ch === 60 ? (isVerbatim = !0, ch = state.input.charCodeAt(++state.position)) : ch === 33 ? (isNamed = !0, tagHandle = "!!", ch = state.input.charCodeAt(++state.position)) : tagHandle = "!", _position = state.position, isVerbatim) {
        do
          ch = state.input.charCodeAt(++state.position);
        while (ch !== 0 && ch !== 62);
        state.position < state.length ? (tagName = state.input.slice(_position, state.position), ch = state.input.charCodeAt(++state.position)) : throwError(state, "unexpected end of the stream within a verbatim tag");
      } else {
        for (; ch !== 0 && !is_WS_OR_EOL(ch); )
          ch === 33 && (isNamed ? throwError(state, "tag suffix cannot contain exclamation marks") : (tagHandle = state.input.slice(_position - 1, state.position + 1), PATTERN_TAG_HANDLE.test(tagHandle) || throwError(state, "named tag handle cannot contain such characters"), isNamed = !0, _position = state.position + 1)), ch = state.input.charCodeAt(++state.position);
        tagName = state.input.slice(_position, state.position), PATTERN_FLOW_INDICATORS.test(tagName) && throwError(state, "tag suffix cannot contain flow indicator characters");
      }
      return tagName && !PATTERN_TAG_URI.test(tagName) && throwError(state, "tag name cannot contain such characters: " + tagName), isVerbatim ? state.tag = tagName : _hasOwnProperty.call(state.tagMap, tagHandle) ? state.tag = state.tagMap[tagHandle] + tagName : tagHandle === "!" ? state.tag = "!" + tagName : tagHandle === "!!" ? state.tag = "tag:yaml.org,2002:" + tagName : throwError(state, 'undeclared tag handle "' + tagHandle + '"'), !0;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      if (ch = state.input.charCodeAt(state.position), ch !== 38)
        return !1;
      for (state.anchor !== null && throwError(state, "duplication of an anchor property"), ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
        ch = state.input.charCodeAt(++state.position);
      return state.position === _position && throwError(state, "name of an anchor node must contain at least one character"), state.anchor = state.input.slice(_position, state.position), !0;
    }
    function readAlias(state) {
      var _position, alias, ch;
      if (ch = state.input.charCodeAt(state.position), ch !== 42)
        return !1;
      for (ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch); )
        ch = state.input.charCodeAt(++state.position);
      return state.position === _position && throwError(state, "name of an alias node must contain at least one character"), alias = state.input.slice(_position, state.position), _hasOwnProperty.call(state.anchorMap, alias) || throwError(state, 'unidentified alias "' + alias + '"'), state.result = state.anchorMap[alias], skipSeparationSpace(state, !0, -1), !0;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = !1, hasContent = !1, typeIndex, typeQuantity, type, flowIndent, blockIndent;
      if (state.listener !== null && state.listener("open", state), state.tag = null, state.anchor = null, state.kind = null, state.result = null, allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext, allowToSeek && skipSeparationSpace(state, !0, -1) && (atNewLine = !0, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)), indentStatus === 1)
        for (; readTagProperty(state) || readAnchorProperty(state); )
          skipSeparationSpace(state, !0, -1) ? (atNewLine = !0, allowBlockCollections = allowBlockStyles, state.lineIndent > parentIndent ? indentStatus = 1 : state.lineIndent === parentIndent ? indentStatus = 0 : state.lineIndent < parentIndent && (indentStatus = -1)) : allowBlockCollections = !1;
      if (allowBlockCollections && (allowBlockCollections = atNewLine || allowCompact), (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) && (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext ? flowIndent = parentIndent : flowIndent = parentIndent + 1, blockIndent = state.position - state.lineStart, indentStatus === 1 ? allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent) ? hasContent = !0 : (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent) ? hasContent = !0 : readAlias(state) ? (hasContent = !0, (state.tag !== null || state.anchor !== null) && throwError(state, "alias node should not have any properties")) : readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext) && (hasContent = !0, state.tag === null && (state.tag = "?")), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : indentStatus === 0 && (hasContent = allowBlockCollections && readBlockSequence(state, blockIndent))), state.tag !== null && state.tag !== "!")
        if (state.tag === "?") {
          for (state.result !== null && state.kind !== "scalar" && throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"'), typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1)
            if (type = state.implicitTypes[typeIndex], type.resolve(state.result)) {
              state.result = type.construct(state.result), state.tag = type.tag, state.anchor !== null && (state.anchorMap[state.anchor] = state.result);
              break;
            }
        } else
          _hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag) ? (type = state.typeMap[state.kind || "fallback"][state.tag], state.result !== null && type.kind !== state.kind && throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"'), type.resolve(state.result) ? (state.result = type.construct(state.result), state.anchor !== null && (state.anchorMap[state.anchor] = state.result)) : throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag")) : throwError(state, "unknown tag !<" + state.tag + ">");
      return state.listener !== null && state.listener("close", state), state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = !1, ch;
      for (state.version = null, state.checkLineBreaks = state.legacy, state.tagMap = {}, state.anchorMap = {}; (ch = state.input.charCodeAt(state.position)) !== 0 && (skipSeparationSpace(state, !0, -1), ch = state.input.charCodeAt(state.position), !(state.lineIndent > 0 || ch !== 37)); ) {
        for (hasDirectives = !0, ch = state.input.charCodeAt(++state.position), _position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
          ch = state.input.charCodeAt(++state.position);
        for (directiveName = state.input.slice(_position, state.position), directiveArgs = [], directiveName.length < 1 && throwError(state, "directive name must not be less than one character in length"); ch !== 0; ) {
          for (; is_WHITE_SPACE(ch); )
            ch = state.input.charCodeAt(++state.position);
          if (ch === 35) {
            do
              ch = state.input.charCodeAt(++state.position);
            while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          for (_position = state.position; ch !== 0 && !is_WS_OR_EOL(ch); )
            ch = state.input.charCodeAt(++state.position);
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        ch !== 0 && readLineBreak(state), _hasOwnProperty.call(directiveHandlers, directiveName) ? directiveHandlers[directiveName](state, directiveName, directiveArgs) : throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
      if (skipSeparationSpace(state, !0, -1), state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45 ? (state.position += 3, skipSeparationSpace(state, !0, -1)) : hasDirectives && throwError(state, "directives end mark is expected"), composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, !1, !0), skipSeparationSpace(state, !0, -1), state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position)) && throwWarning(state, "non-ASCII line breaks are interpreted as content"), state.documents.push(state.result), state.position === state.lineStart && testDocumentSeparator(state)) {
        state.input.charCodeAt(state.position) === 46 && (state.position += 3, skipSeparationSpace(state, !0, -1));
        return;
      }
      if (state.position < state.length - 1)
        throwError(state, "end of the stream or a document separator is expected");
      else
        return;
    }
    function loadDocuments(input, options) {
      input = String(input), options = options || {}, input.length !== 0 && (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13 && (input += `
`), input.charCodeAt(0) === 65279 && (input = input.slice(1)));
      var state = new State(input, options), nullpos = input.indexOf("\0");
      for (nullpos !== -1 && (state.position = nullpos, throwError(state, "null byte is not allowed in input")), state.input += "\0"; state.input.charCodeAt(state.position) === 32; )
        state.lineIndent += 1, state.position += 1;
      for (; state.position < state.length - 1; )
        readDocument(state);
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      iterator !== null && typeof iterator == "object" && typeof options > "u" && (options = iterator, iterator = null);
      var documents = loadDocuments(input, options);
      if (typeof iterator != "function")
        return documents;
      for (var index = 0, length = documents.length; index < length; index += 1)
        iterator(documents[index]);
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length !== 0) {
        if (documents.length === 1)
          return documents[0];
        throw new YAMLException("expected a single document in the stream, but found more");
      }
    }
    function safeLoadAll(input, iterator, options) {
      return typeof iterator == "object" && iterator !== null && typeof options > "u" && (options = iterator, iterator = null), loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    function safeLoad(input, options) {
      return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load;
    module2.exports.safeLoadAll = safeLoadAll;
    module2.exports.safeLoad = safeLoad;
  }
});

// ../../node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml/dumper.js"(exports2, module2) {
    "use strict";
    var common = require_common3(), YAMLException = require_exception(), DEFAULT_FULL_SCHEMA = require_default_full(), DEFAULT_SAFE_SCHEMA = require_default_safe(), _toString = Object.prototype.toString, _hasOwnProperty = Object.prototype.hasOwnProperty, CHAR_TAB = 9, CHAR_LINE_FEED = 10, CHAR_CARRIAGE_RETURN = 13, CHAR_SPACE = 32, CHAR_EXCLAMATION = 33, CHAR_DOUBLE_QUOTE = 34, CHAR_SHARP = 35, CHAR_PERCENT = 37, CHAR_AMPERSAND = 38, CHAR_SINGLE_QUOTE = 39, CHAR_ASTERISK = 42, CHAR_COMMA = 44, CHAR_MINUS = 45, CHAR_COLON = 58, CHAR_EQUALS = 61, CHAR_GREATER_THAN = 62, CHAR_QUESTION = 63, CHAR_COMMERCIAL_AT = 64, CHAR_LEFT_SQUARE_BRACKET = 91, CHAR_RIGHT_SQUARE_BRACKET = 93, CHAR_GRAVE_ACCENT = 96, CHAR_LEFT_CURLY_BRACKET = 123, CHAR_VERTICAL_LINE = 124, CHAR_RIGHT_CURLY_BRACKET = 125, ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null)
        return {};
      for (result = {}, keys = Object.keys(map), index = 0, length = keys.length; index < length; index += 1)
        tag = keys[index], style = String(map[tag]), tag.slice(0, 2) === "!!" && (tag = "tag:yaml.org,2002:" + tag.slice(2)), type = schema.compiledTypeMap.fallback[tag], type && _hasOwnProperty.call(type.styleAliases, style) && (style = type.styleAliases[style]), result[tag] = style;
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      if (string = character.toString(16).toUpperCase(), character <= 255)
        handle = "x", length = 2;
      else if (character <= 65535)
        handle = "u", length = 4;
      else if (character <= 4294967295)
        handle = "U", length = 8;
      else
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    function State(options) {
      this.schema = options.schema || DEFAULT_FULL_SCHEMA, this.indent = Math.max(1, options.indent || 2), this.noArrayIndent = options.noArrayIndent || !1, this.skipInvalid = options.skipInvalid || !1, this.flowLevel = common.isNothing(options.flowLevel) ? -1 : options.flowLevel, this.styleMap = compileStyleMap(this.schema, options.styles || null), this.sortKeys = options.sortKeys || !1, this.lineWidth = options.lineWidth || 80, this.noRefs = options.noRefs || !1, this.noCompatMode = options.noCompatMode || !1, this.condenseFlow = options.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      for (var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length; position < length; )
        next = string.indexOf(`
`, position), next === -1 ? (line = string.slice(position), position = length) : (line = string.slice(position, next + 1), position = next + 1), line.length && line !== `
` && (result += ind), result += line;
      return result;
    }
    function generateNextLine(state, level) {
      return `
` + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1)
        if (type = state.implicitTypes[index], type.resolve(str))
          return !0;
      return !1;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
    }
    function isNsChar(c) {
      return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev) {
      return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i, char, prev_char, hasLineBreak = !1, hasFoldableLine = !1, shouldTrackWidth = lineWidth !== -1, previousLineBreak = -1, plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly)
        for (i = 0; i < string.length; i++) {
          if (char = string.charCodeAt(i), !isPrintable(char))
            return STYLE_DOUBLE;
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null, plain = plain && isPlainSafe(char, prev_char);
        }
      else {
        for (i = 0; i < string.length; i++) {
          if (char = string.charCodeAt(i), char === CHAR_LINE_FEED)
            hasLineBreak = !0, shouldTrackWidth && (hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ", previousLineBreak = i);
          else if (!isPrintable(char))
            return STYLE_DOUBLE;
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null, plain = plain && isPlainSafe(char, prev_char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
      }
      return !hasLineBreak && !hasFoldableLine ? plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE : indentPerLevel > 9 && needIndentIndicator(string) ? STYLE_DOUBLE : hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string, level, iskey) {
      state.dump = function() {
        if (string.length === 0)
          return "''";
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1)
          return "'" + string + "'";
        var indent = state.indent * Math.max(1, level), lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent), singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "", clip = string[string.length - 1] === `
`, keep = clip && (string[string.length - 2] === `
` || string === `
`), chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + `
`;
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === `
` ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      for (var lineRe = /(\n+)([^\n]*)/g, result = function() {
        var nextLF = string.indexOf(`
`);
        return nextLF = nextLF !== -1 ? nextLF : string.length, lineRe.lastIndex = nextLF, foldLine(string.slice(0, nextLF), width);
      }(), prevMoreIndented = string[0] === `
` || string[0] === " ", moreIndented, match2; match2 = lineRe.exec(string); ) {
        var prefix = match2[1], line = match2[2];
        moreIndented = line[0] === " ", result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? `
` : "") + foldLine(line, width), prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      for (var breakRe = / [^ ]/g, match2, start = 0, end, curr = 0, next = 0, result = ""; match2 = breakRe.exec(line); )
        next = match2.index, next - start > width && (end = curr > start ? curr : next, result += `
` + line.slice(start, end), start = end + 1), curr = next;
      return result += `
`, line.length - start > width && curr > start ? result += line.slice(start, curr) + `
` + line.slice(curr + 1) : result += line.slice(start), result.slice(1);
    }
    function escapeString(string) {
      for (var result = "", char, nextChar, escapeSeq, i = 0; i < string.length; i++) {
        if (char = string.charCodeAt(i), char >= 55296 && char <= 56319 && (nextChar = string.charCodeAt(i + 1), nextChar >= 56320 && nextChar <= 57343)) {
          result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536), i++;
          continue;
        }
        escapeSeq = ESCAPE_SEQUENCES[char], result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1)
        writeNode(state, level, object[index], !1, !1) && (index !== 0 && (_result += "," + (state.condenseFlow ? "" : " ")), _result += state.dump);
      state.tag = _tag, state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1)
        writeNode(state, level + 1, object[index], !0, !0) && ((!compact || index !== 0) && (_result += generateNextLine(state, level)), state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? _result += "-" : _result += "- ", _result += state.dump);
      state.tag = _tag, state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1)
        pairBuffer = "", index !== 0 && (pairBuffer += ", "), state.condenseFlow && (pairBuffer += '"'), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state, level, objectKey, !1, !1) && (state.dump.length > 1024 && (pairBuffer += "? "), pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " "), writeNode(state, level, objectValue, !1, !1) && (pairBuffer += state.dump, _result += pairBuffer));
      state.tag = _tag, state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === !0)
        objectKeyList.sort();
      else if (typeof state.sortKeys == "function")
        objectKeyList.sort(state.sortKeys);
      else if (state.sortKeys)
        throw new YAMLException("sortKeys must be a boolean or a function");
      for (index = 0, length = objectKeyList.length; index < length; index += 1)
        pairBuffer = "", (!compact || index !== 0) && (pairBuffer += generateNextLine(state, level)), objectKey = objectKeyList[index], objectValue = object[objectKey], writeNode(state, level + 1, objectKey, !0, !0, !0) && (explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024, explicitPair && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += "?" : pairBuffer += "? "), pairBuffer += state.dump, explicitPair && (pairBuffer += generateNextLine(state, level)), writeNode(state, level + 1, objectValue, !0, explicitPair) && (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0) ? pairBuffer += ":" : pairBuffer += ": ", pairBuffer += state.dump, _result += pairBuffer));
      state.tag = _tag, state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      for (typeList = explicit ? state.explicitTypes : state.implicitTypes, index = 0, length = typeList.length; index < length; index += 1)
        if (type = typeList[index], (type.instanceOf || type.predicate) && (!type.instanceOf || typeof object == "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          if (state.tag = explicit ? type.tag : "?", type.represent) {
            if (style = state.styleMap[type.tag] || type.defaultStyle, _toString.call(type.represent) === "[object Function]")
              _result = type.represent(object, style);
            else if (_hasOwnProperty.call(type.represent, style))
              _result = type.represent[style](object, style);
            else
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            state.dump = _result;
          }
          return !0;
        }
      return !1;
    }
    function writeNode(state, level, object, block, compact, iskey) {
      state.tag = null, state.dump = object, detectType(state, object, !1) || detectType(state, object, !0);
      var type = _toString.call(state.dump);
      block && (block = state.flowLevel < 0 || state.flowLevel > level);
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray && (duplicateIndex = state.duplicates.indexOf(object), duplicate = duplicateIndex !== -1), (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) && (compact = !1), duplicate && state.usedDuplicates[duplicateIndex])
        state.dump = "*ref_" + duplicateIndex;
      else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex] && (state.usedDuplicates[duplicateIndex] = !0), type === "[object Object]")
          block && Object.keys(state.dump).length !== 0 ? (writeBlockMapping(state, level, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowMapping(state, level, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
        else if (type === "[object Array]") {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          block && state.dump.length !== 0 ? (writeBlockSequence(state, arrayLevel, state.dump, compact), duplicate && (state.dump = "&ref_" + duplicateIndex + state.dump)) : (writeFlowSequence(state, arrayLevel, state.dump), duplicate && (state.dump = "&ref_" + duplicateIndex + " " + state.dump));
        } else if (type === "[object String]")
          state.tag !== "?" && writeScalar(state, state.dump, level, iskey);
        else {
          if (state.skipInvalid)
            return !1;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        state.tag !== null && state.tag !== "?" && (state.dump = "!<" + state.tag + "> " + state.dump);
      }
      return !0;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      for (inspectNode(object, objects, duplicatesIndexes), index = 0, length = duplicatesIndexes.length; index < length; index += 1)
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object == "object")
        if (index = objects.indexOf(object), index !== -1)
          duplicatesIndexes.indexOf(index) === -1 && duplicatesIndexes.push(index);
        else if (objects.push(object), Array.isArray(object))
          for (index = 0, length = object.length; index < length; index += 1)
            inspectNode(object[index], objects, duplicatesIndexes);
        else
          for (objectKeyList = Object.keys(object), index = 0, length = objectKeyList.length; index < length; index += 1)
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      return state.noRefs || getDuplicateReferences(input, state), writeNode(state, 0, input, !0, !0) ? state.dump + `
` : "";
    }
    function safeDump(input, options) {
      return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    module2.exports.dump = dump;
    module2.exports.safeDump = safeDump;
  }
});

// ../../node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS({
  "../../node_modules/js-yaml/lib/js-yaml.js"(exports2, module2) {
    "use strict";
    var loader = require_loader(), dumper = require_dumper();
    function deprecated(name) {
      return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema4();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json2();
    module2.exports.CORE_SCHEMA = require_core2();
    module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.safeLoad = loader.safeLoad;
    module2.exports.safeLoadAll = loader.safeLoadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.safeDump = dumper.safeDump;
    module2.exports.YAMLException = require_exception();
    module2.exports.MINIMAL_SCHEMA = require_failsafe();
    module2.exports.SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_SCHEMA = require_default_full();
    module2.exports.scan = deprecated("scan");
    module2.exports.parse = deprecated("parse");
    module2.exports.compose = deprecated("compose");
    module2.exports.addConstructor = deprecated("addConstructor");
  }
});

// ../../node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS({
  "../../node_modules/js-yaml/index.js"(exports2, module2) {
    "use strict";
    var yaml = require_js_yaml();
    module2.exports = yaml;
  }
});

// ../../node_modules/@expo/package-manager/build/utils/nodeWorkspaces.js
var require_nodeWorkspaces = __commonJS({
  "../../node_modules/@expo/package-manager/build/utils/nodeWorkspaces.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.findPnpmWorkspaceRoot = exports2.findYarnOrNpmWorkspaceRoot = exports2.BUN_LOCK_FILE = exports2.PNPM_WORKSPACE_FILE = exports2.PNPM_LOCK_FILE = exports2.YARN_LOCK_FILE = exports2.NPM_LOCK_FILE = void 0;
    var find_up_1 = require_find_up(), find_yarn_workspace_root_1 = __importDefault(require_find_yarn_workspace_root()), fs_1 = __importDefault(require("fs")), js_yaml_1 = __importDefault(require_js_yaml2()), micromatch_1 = __importDefault(require_micromatch()), path_1 = __importDefault(require("path"));
    exports2.NPM_LOCK_FILE = "package-lock.json";
    exports2.YARN_LOCK_FILE = "yarn.lock";
    exports2.PNPM_LOCK_FILE = "pnpm-lock.yaml";
    exports2.PNPM_WORKSPACE_FILE = "pnpm-workspace.yaml";
    exports2.BUN_LOCK_FILE = "bun.lockb";
    function findYarnOrNpmWorkspaceRoot(projectRoot) {
      try {
        return (0, find_yarn_workspace_root_1.default)(projectRoot);
      } catch (error) {
        if (error.message.includes("Unexpected end of JSON input"))
          return null;
        throw error;
      }
    }
    exports2.findYarnOrNpmWorkspaceRoot = findYarnOrNpmWorkspaceRoot;
    function findPnpmWorkspaceRoot(projectRoot) {
      let workspaceEnvName = "NPM_CONFIG_WORKSPACE_DIR", workspaceEnvValue = process.env[workspaceEnvName] ?? process.env[workspaceEnvName.toLowerCase()], workspaceFile = workspaceEnvValue ? path_1.default.join(workspaceEnvValue, exports2.PNPM_WORKSPACE_FILE) : (0, find_up_1.sync)(exports2.PNPM_WORKSPACE_FILE, { cwd: projectRoot });
      if (!workspaceFile || !fs_1.default.existsSync(workspaceFile))
        return null;
      try {
        let { packages: workspaces } = js_yaml_1.default.load(fs_1.default.readFileSync(workspaceFile, "utf8")), workspaceRoot = path_1.default.dirname(workspaceFile), relativePath = path_1.default.relative(workspaceRoot, projectRoot);
        if (relativePath === "" || (0, micromatch_1.default)([relativePath], workspaces).length > 0)
          return workspaceRoot;
      } catch {
        return null;
      }
      return null;
    }
    exports2.findPnpmWorkspaceRoot = findPnpmWorkspaceRoot;
  }
});

// ../../node_modules/@expo/package-manager/build/node/NpmPackageManager.js
var require_NpmPackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/node/NpmPackageManager.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.NpmPackageManager = void 0;
    var json_file_1 = __importDefault(require_JsonFile()), npm_package_arg_1 = __importDefault(require_npa()), path_1 = __importDefault(require("path")), BasePackageManager_1 = require_BasePackageManager(), nodeWorkspaces_1 = require_nodeWorkspaces(), spawn_1 = require_spawn(), NpmPackageManager2 = class _NpmPackageManager extends BasePackageManager_1.BasePackageManager {
      name = "npm";
      bin = "npm";
      lockFile = nodeWorkspaces_1.NPM_LOCK_FILE;
      workspaceRoot() {
        let root = (0, nodeWorkspaces_1.findYarnOrNpmWorkspaceRoot)(this.ensureCwdDefined("workspaceRoot"));
        return root ? new _NpmPackageManager({
          ...this.options,
          silent: this.silent,
          log: this.log,
          cwd: root
        }) : null;
      }
      addAsync(namesOrFlags = []) {
        if (!namesOrFlags.length)
          return this.installAsync();
        let { flags, versioned, unversioned } = this.parsePackageSpecs(namesOrFlags);
        return (0, spawn_1.createPendingSpawnAsync)(() => this.updatePackageFileAsync(versioned, "dependencies"), () => unversioned.length ? this.runAsync(["install", "--save", ...flags, ...unversioned.map((spec) => spec.raw)]) : this.runAsync(["install", ...flags]));
      }
      addDevAsync(namesOrFlags = []) {
        if (!namesOrFlags.length)
          return this.installAsync();
        let { flags, versioned, unversioned } = this.parsePackageSpecs(namesOrFlags);
        return (0, spawn_1.createPendingSpawnAsync)(() => this.updatePackageFileAsync(versioned, "devDependencies"), () => unversioned.length ? this.runAsync([
          "install",
          "--save-dev",
          ...flags,
          ...unversioned.map((spec) => spec.raw)
        ]) : this.runAsync(["install", ...flags]));
      }
      addGlobalAsync(namesOrFlags = []) {
        return namesOrFlags.length ? this.runAsync(["install", "--global", ...namesOrFlags]) : this.installAsync();
      }
      removeAsync(namesOrFlags) {
        return this.runAsync(["uninstall", ...namesOrFlags]);
      }
      removeDevAsync(namesOrFlags) {
        return this.runAsync(["uninstall", "--save-dev", ...namesOrFlags]);
      }
      removeGlobalAsync(namesOrFlags) {
        return this.runAsync(["uninstall", "--global", ...namesOrFlags]);
      }
      /**
       * Parse all package specifications from the names or flag list.
       * The result from this method can be used for `.updatePackageFileAsync`.
       */
      parsePackageSpecs(namesOrFlags) {
        let result = { flags: [], versioned: [], unversioned: [] };
        return namesOrFlags.map((name) => name.trim().startsWith("-") ? (result.flags.push(name), null) : (0, npm_package_arg_1.default)(name)).forEach((spec) => {
          spec && spec.rawSpec && spec.type !== "tag" ? result.versioned.push(spec) : spec && result.unversioned.push(spec);
        }), result;
      }
      /**
       * Older npm versions have issues with mismatched nested dependencies when adding exact versions.
       * This propagates as issues like mismatched `@expo/config-pugins` versions.
       * As a workaround, we update the `package.json` directly and run `npm install`.
       */
      async updatePackageFileAsync(packageSpecs, packageType) {
        var _a2;
        if (!packageSpecs.length)
          return;
        let pkgPath = path_1.default.join(((_a2 = this.options.cwd) == null ? void 0 : _a2.toString()) || ".", "package.json"), pkg = await json_file_1.default.readAsync(pkgPath);
        packageSpecs.forEach((spec) => {
          pkg[packageType] = pkg[packageType] || {}, pkg[packageType][spec.name] = spec.rawSpec;
        }), await json_file_1.default.writeAsync(pkgPath, pkg, { json5: !1 });
      }
    };
    exports2.NpmPackageManager = NpmPackageManager2;
  }
});

// ../../node_modules/@expo/package-manager/build/utils/env.js
var require_env = __commonJS({
  "../../node_modules/@expo/package-manager/build/utils/env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var Env = class {
      /** Determine if the package manager is running in a CI environment. */
      get CI() {
        let { CI } = process.env;
        return (CI == null ? void 0 : CI.toLowerCase()) === "true" || CI === "1";
      }
    };
    exports2.default = new Env();
  }
});

// ../../node_modules/@expo/package-manager/build/node/PnpmPackageManager.js
var require_PnpmPackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/node/PnpmPackageManager.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.PnpmPackageManager = void 0;
    var BasePackageManager_1 = require_BasePackageManager(), env_1 = __importDefault(require_env()), nodeWorkspaces_1 = require_nodeWorkspaces(), PnpmPackageManager = class _PnpmPackageManager extends BasePackageManager_1.BasePackageManager {
      name = "pnpm";
      bin = "pnpm";
      lockFile = nodeWorkspaces_1.PNPM_LOCK_FILE;
      workspaceRoot() {
        let root = (0, nodeWorkspaces_1.findPnpmWorkspaceRoot)(this.ensureCwdDefined("workspaceRoot"));
        return root ? new _PnpmPackageManager({
          ...this.options,
          silent: this.silent,
          log: this.log,
          cwd: root
        }) : null;
      }
      installAsync(namesOrFlags = []) {
        return env_1.default.CI && !namesOrFlags.join(" ").includes("frozen-lockfile") && namesOrFlags.unshift("--no-frozen-lockfile"), this.runAsync(["install", ...namesOrFlags]);
      }
      addAsync(namesOrFlags = []) {
        return namesOrFlags.length ? this.runAsync(["add", ...namesOrFlags]) : this.installAsync();
      }
      addDevAsync(namesOrFlags = []) {
        return namesOrFlags.length ? this.runAsync(["add", "--save-dev", ...namesOrFlags]) : this.installAsync();
      }
      addGlobalAsync(namesOrFlags = []) {
        return namesOrFlags.length ? this.runAsync(["add", "--global", ...namesOrFlags]) : this.installAsync();
      }
      removeAsync(namesOrFlags) {
        return this.runAsync(["remove", ...namesOrFlags]);
      }
      removeDevAsync(namesOrFlags) {
        return this.runAsync(["remove", "--save-dev", ...namesOrFlags]);
      }
      removeGlobalAsync(namesOrFlags) {
        return this.runAsync(["remove", "--global", ...namesOrFlags]);
      }
    };
    exports2.PnpmPackageManager = PnpmPackageManager;
  }
});

// ../../node_modules/@expo/package-manager/build/utils/yarn.js
var require_yarn = __commonJS({
  "../../node_modules/@expo/package-manager/build/utils/yarn.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getNpmProxy = exports2.isYarnOfflineAsync = void 0;
    var child_process_1 = require("child_process"), dns_1 = __importDefault(require("dns")), url_1 = __importDefault(require("url"));
    async function isYarnOfflineAsync() {
      if (await isUrlAvailableAsync("registry.yarnpkg.com"))
        return !1;
      let proxy = getNpmProxy();
      if (!proxy)
        return !0;
      let { hostname } = url_1.default.parse(proxy);
      return hostname ? !await isUrlAvailableAsync(hostname) : !0;
    }
    exports2.isYarnOfflineAsync = isYarnOfflineAsync;
    function getNpmProxy() {
      if (process.env.https_proxy)
        return process.env.https_proxy ?? null;
      try {
        let httpsProxy = (0, child_process_1.execSync)("npm config get https-proxy").toString().trim();
        return httpsProxy !== "null" ? httpsProxy : null;
      } catch {
        return null;
      }
    }
    exports2.getNpmProxy = getNpmProxy;
    function isUrlAvailableAsync(url) {
      return new Promise((resolve7) => {
        dns_1.default.lookup(url, (err) => {
          resolve7(!err);
        });
      });
    }
  }
});

// ../../node_modules/@expo/package-manager/build/node/YarnPackageManager.js
var require_YarnPackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/node/YarnPackageManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.YarnPackageManager = void 0;
    var BasePackageManager_1 = require_BasePackageManager(), nodeWorkspaces_1 = require_nodeWorkspaces(), spawn_1 = require_spawn(), yarn_1 = require_yarn(), YarnPackageManager2 = class _YarnPackageManager extends BasePackageManager_1.BasePackageManager {
      name = "yarn";
      bin = "yarnpkg";
      lockFile = nodeWorkspaces_1.YARN_LOCK_FILE;
      /** Check if Yarn is running in offline mode, and add the `--offline` flag */
      async withOfflineFlagAsync(namesOrFlags) {
        return await (0, yarn_1.isYarnOfflineAsync)() ? [...namesOrFlags, "--offline"] : namesOrFlags;
      }
      workspaceRoot() {
        let root = (0, nodeWorkspaces_1.findYarnOrNpmWorkspaceRoot)(this.ensureCwdDefined("workspaceRoot"));
        return root ? new _YarnPackageManager({
          ...this.options,
          silent: this.silent,
          log: this.log,
          cwd: root
        }) : null;
      }
      installAsync(flags = []) {
        return (0, spawn_1.createPendingSpawnAsync)(() => this.withOfflineFlagAsync(["install"]), (args) => this.runAsync([...args, ...flags]));
      }
      addAsync(namesOrFlags = []) {
        return namesOrFlags.length ? (0, spawn_1.createPendingSpawnAsync)(() => this.withOfflineFlagAsync(["add", ...namesOrFlags]), (args) => this.runAsync(args)) : this.installAsync();
      }
      addDevAsync(namesOrFlags = []) {
        return namesOrFlags.length ? (0, spawn_1.createPendingSpawnAsync)(() => this.withOfflineFlagAsync(["add", "--dev", ...namesOrFlags]), (args) => this.runAsync(args)) : this.installAsync();
      }
      addGlobalAsync(namesOrFlags = []) {
        return namesOrFlags.length ? (0, spawn_1.createPendingSpawnAsync)(() => this.withOfflineFlagAsync(["global", "add", ...namesOrFlags]), (args) => this.runAsync(args)) : this.installAsync();
      }
      removeAsync(namesOrFlags) {
        return this.runAsync(["remove", ...namesOrFlags]);
      }
      removeDevAsync(namesOrFlags) {
        return this.runAsync(["remove", ...namesOrFlags]);
      }
      removeGlobalAsync(namesOrFlags) {
        return this.runAsync(["global", "remove", ...namesOrFlags]);
      }
    };
    exports2.YarnPackageManager = YarnPackageManager2;
  }
});

// ../../node_modules/@expo/package-manager/build/node/BunPackageManager.js
var require_BunPackageManager = __commonJS({
  "../../node_modules/@expo/package-manager/build/node/BunPackageManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.BunPackageManager = void 0;
    var BasePackageManager_1 = require_BasePackageManager(), nodeWorkspaces_1 = require_nodeWorkspaces(), BunPackageManager = class _BunPackageManager extends BasePackageManager_1.BasePackageManager {
      name = "bun";
      bin = "bun";
      lockFile = nodeWorkspaces_1.BUN_LOCK_FILE;
      workspaceRoot() {
        let root = (0, nodeWorkspaces_1.findYarnOrNpmWorkspaceRoot)(this.ensureCwdDefined("workspaceRoot"));
        return root ? new _BunPackageManager({
          ...this.options,
          silent: this.silent,
          log: this.log,
          cwd: root
        }) : null;
      }
      installAsync(namesOrFlags = []) {
        return this.runAsync(["install", ...namesOrFlags]);
      }
      addAsync(namesOrFlags = []) {
        return namesOrFlags.length ? this.runAsync(["add", ...namesOrFlags]) : this.installAsync();
      }
      addDevAsync(namesOrFlags = []) {
        return namesOrFlags.length ? this.runAsync(["add", "--dev", ...namesOrFlags]) : this.installAsync();
      }
      addGlobalAsync(namesOrFlags = []) {
        return namesOrFlags.length ? this.runAsync(["add", "--global", ...namesOrFlags]) : this.installAsync();
      }
      removeAsync(namesOrFlags) {
        return this.runAsync(["remove", ...namesOrFlags]);
      }
      removeDevAsync(namesOrFlags) {
        return this.runAsync(["remove", ...namesOrFlags]);
      }
      removeGlobalAsync(namesOrFlags) {
        return this.runAsync(["remove", "--global", ...namesOrFlags]);
      }
    };
    exports2.BunPackageManager = BunPackageManager;
  }
});

// ../../node_modules/@expo/package-manager/build/utils/nodeManagers.js
var require_nodeManagers = __commonJS({
  "../../node_modules/@expo/package-manager/build/utils/nodeManagers.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.createForProject = exports2.resolvePackageManager = exports2.findWorkspaceRoot = exports2.RESOLUTION_ORDER = void 0;
    var fs_1 = __importDefault(require("fs")), path_1 = __importDefault(require("path")), nodeWorkspaces_1 = require_nodeWorkspaces(), BunPackageManager_1 = require_BunPackageManager(), NpmPackageManager_1 = require_NpmPackageManager(), PnpmPackageManager_1 = require_PnpmPackageManager(), YarnPackageManager_1 = require_YarnPackageManager();
    exports2.RESOLUTION_ORDER = ["bun", "yarn", "npm", "pnpm"];
    function findWorkspaceRoot(projectRoot, preferredManager) {
      let strategies = {
        npm: nodeWorkspaces_1.findYarnOrNpmWorkspaceRoot,
        yarn: nodeWorkspaces_1.findYarnOrNpmWorkspaceRoot,
        pnpm: nodeWorkspaces_1.findPnpmWorkspaceRoot,
        bun: nodeWorkspaces_1.findYarnOrNpmWorkspaceRoot
      };
      if (preferredManager)
        return strategies[preferredManager](projectRoot);
      for (let strategy of exports2.RESOLUTION_ORDER) {
        let root = strategies[strategy](projectRoot);
        if (root)
          return root;
      }
      return null;
    }
    exports2.findWorkspaceRoot = findWorkspaceRoot;
    function resolvePackageManager(projectRoot, preferredManager) {
      let root = findWorkspaceRoot(projectRoot, preferredManager) ?? projectRoot, lockFiles = {
        npm: nodeWorkspaces_1.NPM_LOCK_FILE,
        pnpm: nodeWorkspaces_1.PNPM_LOCK_FILE,
        yarn: nodeWorkspaces_1.YARN_LOCK_FILE,
        bun: nodeWorkspaces_1.BUN_LOCK_FILE
      };
      if (preferredManager)
        return fs_1.default.existsSync(path_1.default.join(root, lockFiles[preferredManager])) ? preferredManager : null;
      for (let managerName of exports2.RESOLUTION_ORDER)
        if (fs_1.default.existsSync(path_1.default.join(root, lockFiles[managerName])))
          return managerName;
      return null;
    }
    exports2.resolvePackageManager = resolvePackageManager;
    function createForProject(projectRoot, options = {}) {
      if (options.npm)
        return new NpmPackageManager_1.NpmPackageManager({ cwd: projectRoot, ...options });
      if (options.yarn)
        return new YarnPackageManager_1.YarnPackageManager({ cwd: projectRoot, ...options });
      if (options.pnpm)
        return new PnpmPackageManager_1.PnpmPackageManager({ cwd: projectRoot, ...options });
      if (options.bun)
        return new BunPackageManager_1.BunPackageManager({ cwd: projectRoot, ...options });
      switch (resolvePackageManager(projectRoot)) {
        case "npm":
          return new NpmPackageManager_1.NpmPackageManager({ cwd: projectRoot, ...options });
        case "pnpm":
          return new PnpmPackageManager_1.PnpmPackageManager({ cwd: projectRoot, ...options });
        case "yarn":
          return new YarnPackageManager_1.YarnPackageManager({ cwd: projectRoot, ...options });
        case "bun":
          return new BunPackageManager_1.BunPackageManager({ cwd: projectRoot, ...options });
        default:
          return new NpmPackageManager_1.NpmPackageManager({ cwd: projectRoot, ...options });
      }
    }
    exports2.createForProject = createForProject;
  }
});

// ../../node_modules/@expo/package-manager/build/index.js
var require_build = __commonJS({
  "../../node_modules/@expo/package-manager/build/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p) && __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.isYarnOfflineAsync = void 0;
    __exportStar(require_PackageManager(), exports2);
    __exportStar(require_CocoaPodsPackageManager(), exports2);
    __exportStar(require_NpmPackageManager(), exports2);
    __exportStar(require_PnpmPackageManager(), exports2);
    __exportStar(require_YarnPackageManager(), exports2);
    __exportStar(require_BunPackageManager(), exports2);
    __exportStar(require_nodeManagers(), exports2);
    __exportStar(require_nodeWorkspaces(), exports2);
    var yarn_1 = require_yarn();
    Object.defineProperty(exports2, "isYarnOfflineAsync", { enumerable: !0, get: function() {
      return yarn_1.isYarnOfflineAsync;
    } });
  }
});

// src/index.ts
var import_child_process3 = require("child_process"), import_fs15 = __toESM(require("fs")), import_path12 = __toESM(require("path")), import_process = require("process"), import_chalk14 = __toESM(require_source()), import_commander = __toESM(require_commander());

// ../../node_modules/detect-package-manager/dist/index.mjs
var import_fs = require("fs"), import_path = require("path"), import_execa = __toESM(require_execa(), 1);
async function pathExists(p) {
  try {
    return await import_fs.promises.access(p), !0;
  } catch {
    return !1;
  }
}
var cache = /* @__PURE__ */ new Map();
function hasGlobalInstallation(pm) {
  let key = `has_global_${pm}`;
  return cache.has(key) ? Promise.resolve(cache.get(key)) : (0, import_execa.default)(pm, ["--version"]).then((res) => /^\d+.\d+.\d+$/.test(res.stdout)).then((value) => (cache.set(key, value), value)).catch(() => !1);
}
function getTypeofLockFile(cwd2 = ".") {
  let key = `lockfile_${cwd2}`;
  return cache.has(key) ? Promise.resolve(cache.get(key)) : Promise.all([
    pathExists((0, import_path.resolve)(cwd2, "yarn.lock")),
    pathExists((0, import_path.resolve)(cwd2, "package-lock.json")),
    pathExists((0, import_path.resolve)(cwd2, "pnpm-lock.yaml")),
    pathExists((0, import_path.resolve)(cwd2, "bun.lockb"))
  ]).then(([isYarn, isNpm, isPnpm, isBun]) => {
    let value = null;
    return isYarn ? value = "yarn" : isPnpm ? value = "pnpm" : isBun ? value = "bun" : isNpm && (value = "npm"), cache.set(key, value), value;
  });
}
var detect = async ({
  cwd: cwd2,
  includeGlobalBun
} = {}) => {
  let type = await getTypeofLockFile(cwd2);
  if (type)
    return type;
  let [hasYarn, hasPnpm, hasBun] = await Promise.all([
    hasGlobalInstallation("yarn"),
    hasGlobalInstallation("pnpm"),
    includeGlobalBun && hasGlobalInstallation("bun")
  ]);
  return hasYarn ? "yarn" : hasPnpm ? "pnpm" : hasBun ? "bun" : "npm";
};

// src/index.ts
var import_fs_extra2 = __toESM(require_lib()), import_opener = __toESM(require_opener()), import_prompts5 = __toESM(require_prompts3());

// ../../node_modules/zx/build/core.js
var import_node_assert = __toESM(require("node:assert"), 1), import_node_child_process = require("node:child_process"), import_node_async_hooks = require("node:async_hooks"), import_node_util2 = require("node:util");

// ../../node_modules/zx/node_modules/chalk/source/vendor/ansi-styles/index.js
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`, wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`, wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`, styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, modifierNames = Object.keys(styles.modifier), foregroundColorNames = Object.keys(styles.color), backgroundColorNames = Object.keys(styles.bgColor), colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  let codes2 = /* @__PURE__ */ new Map();
  for (let [groupName, group] of Object.entries(styles)) {
    for (let [styleName, style] of Object.entries(group))
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      }, group[styleName] = styles[styleName], codes2.set(style[0], style[1]);
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: !1
    });
  }
  return Object.defineProperty(styles, "codes", {
    value: codes2,
    enumerable: !1
  }), styles.color.close = "\x1B[39m", styles.bgColor.close = "\x1B[49m", styles.color.ansi = wrapAnsi16(), styles.color.ansi256 = wrapAnsi256(), styles.color.ansi16m = wrapAnsi16m(), styles.bgColor.ansi = wrapAnsi16(10), styles.bgColor.ansi256 = wrapAnsi256(10), styles.bgColor.ansi16m = wrapAnsi16m(10), Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        return red === green && green === blue ? red < 8 ? 16 : red > 248 ? 231 : Math.round((red - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(hex) {
        let matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches)
          return [0, 0, 0];
        let [colorString] = matches;
        colorString.length === 3 && (colorString = [...colorString].map((character) => character + character).join(""));
        let integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8)
          return 30 + code;
        if (code < 16)
          return 90 + (code - 8);
        let red, green, blue;
        if (code >= 232)
          red = ((code - 232) * 10 + 8) / 255, green = red, blue = red;
        else {
          code -= 16;
          let remainder = code % 36;
          red = Math.floor(code / 36) / 5, green = Math.floor(remainder / 6) / 5, blue = remainder % 6 / 5;
        }
        let value = Math.max(red, green, blue) * 2;
        if (value === 0)
          return 30;
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        return value === 2 && (result += 60), result;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: !1
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: !1
    }
  }), styles;
}
var ansiStyles = assembleStyles(), ansi_styles_default = ansiStyles;

// ../../node_modules/zx/node_modules/chalk/source/vendor/supports-color/index.js
var import_node_process = __toESM(require("node:process"), 1), import_node_os = __toESM(require("node:os"), 1), import_node_tty = __toESM(require("node:tty"), 1);
function hasFlag(flag, argv2 = globalThis.Deno ? globalThis.Deno.args : import_node_process.default.argv) {
  let prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--", position = argv2.indexOf(prefix + flag), terminatorPosition = argv2.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = import_node_process.default, flagForceColor;
hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never") ? flagForceColor = 0 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (flagForceColor = 1);
function envForceColor() {
  if ("FORCE_COLOR" in env)
    return env.FORCE_COLOR === "true" ? 1 : env.FORCE_COLOR === "false" ? 0 : env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
}
function translateLevel(level) {
  return level === 0 ? !1 : {
    level,
    hasBasic: !0,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = !0 } = {}) {
  let noFlagForceColor = envForceColor();
  noFlagForceColor !== void 0 && (flagForceColor = noFlagForceColor);
  let forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0)
    return 0;
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor"))
      return 3;
    if (hasFlag("color=256"))
      return 2;
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env)
    return 1;
  if (haveStream && !streamIsTTY && forceColor === void 0)
    return 0;
  let min = forceColor || 0;
  if (env.TERM === "dumb")
    return min;
  if (import_node_process.default.platform === "win32") {
    let osRelease = import_node_os.default.release().split(".");
    return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in env)
    return "GITHUB_ACTIONS" in env ? 3 : ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship" ? 1 : min;
  if ("TEAMCITY_VERSION" in env)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  if (env.COLORTERM === "truecolor" || env.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in env) {
    let version2 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app":
        return version2 >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : min;
}
function createSupportsColor(stream2, options = {}) {
  let level = _supportsColor(stream2, {
    streamIsTTY: stream2 && stream2.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
  stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) })
}, supports_color_default = supportsColor;

// ../../node_modules/zx/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1)
    return string;
  let substringLength = substring.length, endIndex = 0, returnValue = "";
  do
    returnValue += string.slice(endIndex, index) + substring + replacer, endIndex = index + substringLength, index = string.indexOf(substring, endIndex);
  while (index !== -1);
  return returnValue += string.slice(endIndex), returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0, returnValue = "";
  do {
    let gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? `\r
` : `
`) + postfix, endIndex = index + 1, index = string.indexOf(`
`, endIndex);
  } while (index !== -1);
  return returnValue += string.slice(endIndex), returnValue;
}

// ../../node_modules/zx/node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default, GENERATOR = Symbol("GENERATOR"), STYLER = Symbol("STYLER"), IS_EMPTY = Symbol("IS_EMPTY"), levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], styles2 = /* @__PURE__ */ Object.create(null), applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  let colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  let chalk12 = (...strings) => strings.join(" ");
  return applyOptions(chalk12, options), Object.setPrototypeOf(chalk12, createChalk.prototype), chalk12;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (let [styleName, style] of Object.entries(ansi_styles_default))
  styles2[styleName] = {
    get() {
      let builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      return Object.defineProperty(this, styleName, { value: builder }), builder;
    }
  };
styles2.visible = {
  get() {
    let builder = createBuilder(this, this[STYLER], !0);
    return Object.defineProperty(this, "visible", { value: builder }), builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => model === "rgb" ? level === "ansi16m" ? ansi_styles_default[type].ansi16m(...arguments_) : level === "ansi256" ? ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_)) : ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_)) : model === "hex" ? getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_)) : ansi_styles_default[type][model](...arguments_), usedModels = ["rgb", "hex", "ansi256"];
for (let model of usedModels) {
  styles2[model] = {
    get() {
      let { level } = this;
      return function(...arguments_) {
        let styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  let bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      let { level } = this;
      return function(...arguments_) {
        let styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: !0,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
}), createStyler = (open3, close, parent) => {
  let openAll, closeAll;
  return parent === void 0 ? (openAll = open3, closeAll = close) : (openAll = parent.openAll + open3, closeAll = close + parent.closeAll), {
    open: open3,
    close,
    openAll,
    closeAll,
    parent
  };
}, createBuilder = (self, _styler, _isEmpty) => {
  let builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  return Object.setPrototypeOf(builder, proto), builder[GENERATOR] = self, builder[STYLER] = _styler, builder[IS_EMPTY] = _isEmpty, builder;
}, applyStyle = (self, string) => {
  if (self.level <= 0 || !string)
    return self[IS_EMPTY] ? "" : string;
  let styler = self[STYLER];
  if (styler === void 0)
    return string;
  let { openAll, closeAll } = styler;
  if (string.includes("\x1B"))
    for (; styler !== void 0; )
      string = stringReplaceAll(string, styler.close, styler.open), styler = styler.parent;
  let lfIndex = string.indexOf(`
`);
  return lfIndex !== -1 && (string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex)), openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk(), chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// ../../node_modules/zx/build/core.js
var import_which = __toESM(require_lib3(), 1);

// ../../node_modules/zx/build/util.js
var import_node_util = require("node:util"), import_ps_tree = __toESM(require_ps_tree(), 1), psTree = (0, import_node_util.promisify)(import_ps_tree.default);
function noop() {
}
function quote(arg) {
  return /^[a-z0-9/_.\-@:=]+$/i.test(arg) || arg === "" ? arg : "$'" + arg.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/\f/g, "\\f").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t").replace(/\v/g, "\\v").replace(/\0/g, "\\0") + "'";
}
function quotePowerShell(arg) {
  return /^[a-z0-9/_.\-]+$/i.test(arg) || arg === "" ? arg : "'" + arg.replace(/'/g, "''") + "'";
}
function exitCodeInfo(exitCode) {
  return {
    2: "Misuse of shell builtins",
    126: "Invoked command cannot execute",
    127: "Command not found",
    128: "Invalid exit argument",
    129: "Hangup",
    130: "Interrupt",
    131: "Quit and dump core",
    132: "Illegal instruction",
    133: "Trace/breakpoint trap",
    134: "Process aborted",
    135: 'Bus error: "access to undefined portion of memory object"',
    136: 'Floating point exception: "erroneous arithmetic operation"',
    137: "Kill (terminate immediately)",
    138: "User-defined 1",
    139: "Segmentation violation",
    140: "User-defined 2",
    141: "Write to pipe with no one reading",
    142: "Signal raised by alarm",
    143: "Termination (request to terminate)",
    145: "Child process terminated, stopped (or continued*)",
    146: "Continue if stopped",
    147: "Stop executing temporarily",
    148: "Terminal stop signal",
    149: 'Background process attempting to read from tty ("in")',
    150: 'Background process attempting to write to tty ("out")',
    151: "Urgent data available on socket",
    152: "CPU time limit exceeded",
    153: "File size limit exceeded",
    154: 'Signal raised by timer counting virtual time: "virtual timer expired"',
    155: "Profiling timer expired",
    157: "Pollable event",
    159: "Bad syscall"
  }[exitCode || -1];
}
function errnoMessage(errno) {
  return errno === void 0 ? "Unknown error" : {
    0: "Success",
    1: "Not super-user",
    2: "No such file or directory",
    3: "No such process",
    4: "Interrupted system call",
    5: "I/O error",
    6: "No such device or address",
    7: "Arg list too long",
    8: "Exec format error",
    9: "Bad file number",
    10: "No children",
    11: "No more processes",
    12: "Not enough core",
    13: "Permission denied",
    14: "Bad address",
    15: "Block device required",
    16: "Mount device busy",
    17: "File exists",
    18: "Cross-device link",
    19: "No such device",
    20: "Not a directory",
    21: "Is a directory",
    22: "Invalid argument",
    23: "Too many open files in system",
    24: "Too many open files",
    25: "Not a typewriter",
    26: "Text file busy",
    27: "File too large",
    28: "No space left on device",
    29: "Illegal seek",
    30: "Read only file system",
    31: "Too many links",
    32: "Broken pipe",
    33: "Math arg out of domain of func",
    34: "Math result not representable",
    35: "File locking deadlock error",
    36: "File or path name too long",
    37: "No record locks available",
    38: "Function not implemented",
    39: "Directory not empty",
    40: "Too many symbolic links",
    42: "No message of desired type",
    43: "Identifier removed",
    44: "Channel number out of range",
    45: "Level 2 not synchronized",
    46: "Level 3 halted",
    47: "Level 3 reset",
    48: "Link number out of range",
    49: "Protocol driver not attached",
    50: "No CSI structure available",
    51: "Level 2 halted",
    52: "Invalid exchange",
    53: "Invalid request descriptor",
    54: "Exchange full",
    55: "No anode",
    56: "Invalid request code",
    57: "Invalid slot",
    59: "Bad font file fmt",
    60: "Device not a stream",
    61: "No data (for no delay io)",
    62: "Timer expired",
    63: "Out of streams resources",
    64: "Machine is not on the network",
    65: "Package not installed",
    66: "The object is remote",
    67: "The link has been severed",
    68: "Advertise error",
    69: "Srmount error",
    70: "Communication error on send",
    71: "Protocol error",
    72: "Multihop attempted",
    73: "Cross mount point (not really error)",
    74: "Trying to read unreadable message",
    75: "Value too large for defined data type",
    76: "Given log. name not unique",
    77: "f.d. invalid for this operation",
    78: "Remote address changed",
    79: "Can   access a needed shared lib",
    80: "Accessing a corrupted shared lib",
    81: ".lib section in a.out corrupted",
    82: "Attempting to link in too many libs",
    83: "Attempting to exec a shared library",
    84: "Illegal byte sequence",
    86: "Streams pipe error",
    87: "Too many users",
    88: "Socket operation on non-socket",
    89: "Destination address required",
    90: "Message too long",
    91: "Protocol wrong type for socket",
    92: "Protocol not available",
    93: "Unknown protocol",
    94: "Socket type not supported",
    95: "Not supported",
    96: "Protocol family not supported",
    97: "Address family not supported by protocol family",
    98: "Address already in use",
    99: "Address not available",
    100: "Network interface is not configured",
    101: "Network is unreachable",
    102: "Connection reset by network",
    103: "Connection aborted",
    104: "Connection reset by peer",
    105: "No buffer space available",
    106: "Socket is already connected",
    107: "Socket is not connected",
    108: "Can't send after socket shutdown",
    109: "Too many references",
    110: "Connection timed out",
    111: "Connection refused",
    112: "Host is down",
    113: "Host is unreachable",
    114: "Socket already connected",
    115: "Connection already in progress",
    116: "Stale file handle",
    122: "Quota exceeded",
    123: "No medium (in tape drive)",
    125: "Operation canceled",
    130: "Previous owner died",
    131: "State not recoverable"
  }[-errno] || "Unknown error";
}
function parseDuration(d) {
  if (typeof d == "number") {
    if (isNaN(d) || d < 0)
      throw new Error(`Invalid duration: "${d}".`);
    return d;
  } else {
    if (/\d+s/.test(d))
      return +d.slice(0, -1) * 1e3;
    if (/\d+ms/.test(d))
      return +d.slice(0, -2);
  }
  throw new Error(`Unknown duration: "${d}".`);
}
function formatCmd(cmd) {
  if (cmd == null)
    return source_default.grey("undefined");
  let chars = [...cmd], out = "$ ", buf = "", ch, state = root, wordCount = 0;
  for (; state; ) {
    if (ch = chars.shift() || "EOF", ch == `
`) {
      out += style(state, buf) + `
> `, buf = "";
      continue;
    }
    let next = ch == "EOF" ? void 0 : state();
    next != state && (out += style(state, buf), buf = ""), state = next == root ? next() : next, buf += ch;
  }
  function style(state2, s) {
    return s == "" ? "" : reservedWords.includes(s) ? source_default.cyanBright(s) : state2 == word && wordCount == 0 ? (wordCount++, source_default.greenBright(s)) : state2 == syntax ? (wordCount = 0, source_default.cyanBright(s)) : state2 == dollar ? source_default.yellowBright(s) : state2 != null && state2.name.startsWith("str") ? source_default.yellowBright(s) : s;
  }
  function isSyntax(ch2) {
    return "()[]{}<>;:+|&=".includes(ch2);
  }
  function root() {
    return /\s/.test(ch) ? space : isSyntax(ch) ? syntax : /[$]/.test(ch) ? dollar : /["]/.test(ch) ? strDouble : /[']/.test(ch) ? strSingle : word;
  }
  function space() {
    return /\s/.test(ch) ? space : root;
  }
  function word() {
    return /[0-9a-z/_.]/i.test(ch) ? word : root;
  }
  function syntax() {
    return isSyntax(ch) ? syntax : root;
  }
  function dollar() {
    return /[']/.test(ch) ? str : root;
  }
  function str() {
    return /[']/.test(ch) ? strEnd : /[\\]/.test(ch) ? strBackslash : str;
  }
  function strBackslash() {
    return strEscape;
  }
  function strEscape() {
    return str;
  }
  function strDouble() {
    return /["]/.test(ch) ? strEnd : strDouble;
  }
  function strSingle() {
    return /[']/.test(ch) ? strEnd : strSingle;
  }
  function strEnd() {
    return root;
  }
  return out + `
`;
}
var reservedWords = [
  "if",
  "then",
  "else",
  "elif",
  "fi",
  "case",
  "esac",
  "for",
  "select",
  "while",
  "until",
  "do",
  "done",
  "in"
];

// ../../node_modules/zx/build/core.js
var processCwd = Symbol("processCwd"), storage = new import_node_async_hooks.AsyncLocalStorage(), hook = (0, import_node_async_hooks.createHook)({
  init: syncCwd,
  before: syncCwd,
  promiseResolve: syncCwd,
  after: syncCwd,
  destroy: syncCwd
});
hook.enable();
var defaults = {
  [processCwd]: process.cwd(),
  verbose: !0,
  env: process.env,
  shell: !0,
  prefix: "",
  quote: () => {
    throw new Error("No quote function is defined: https://\xEF.at/no-quote-func");
  },
  spawn: import_node_child_process.spawn,
  log
};
try {
  defaults.shell = import_which.default.sync("bash"), defaults.prefix = "set -euo pipefail;", defaults.quote = quote;
} catch {
  process.platform == "win32" && (defaults.shell = import_which.default.sync("powershell.exe"), defaults.quote = quotePowerShell);
}
function getStore() {
  return storage.getStore() || defaults;
}
var $ = new Proxy(function(pieces, ...args) {
  let from = new Error().stack.split(/^\s*at\s/m)[2].trim();
  if (pieces.some((p) => p == null))
    throw new Error(`Malformed command at ${from}`);
  let resolve7, reject, promise = new ProcessPromise((...args2) => [resolve7, reject] = args2), cmd = pieces[0], i = 0;
  for (; i < args.length; ) {
    let s;
    Array.isArray(args[i]) ? s = args[i].map((x) => $.quote(substitute(x))).join(" ") : s = $.quote(substitute(args[i])), cmd += s + pieces[++i];
  }
  return promise._bind(cmd, from, resolve7, reject, getStore()), setImmediate(() => promise.isHalted || promise.run()), promise;
}, {
  set(_, key, value) {
    let target = key in Function.prototype ? _ : getStore();
    return Reflect.set(target, key, value), !0;
  },
  get(_, key) {
    let target = key in Function.prototype ? _ : getStore();
    return Reflect.get(target, key);
  }
});
function substitute(arg) {
  return arg != null && arg.stdout ? arg.stdout.replace(/\n$/, "") : `${arg}`;
}
var ProcessPromise = class _ProcessPromise extends Promise {
  constructor() {
    super(...arguments), this._command = "", this._from = "", this._resolve = noop, this._reject = noop, this._snapshot = getStore(), this._stdio = ["inherit", "pipe", "pipe"], this._nothrow = !1, this._quiet = !1, this._resolved = !1, this._halted = !1, this._piped = !1, this._prerun = noop, this._postrun = noop;
  }
  _bind(cmd, from, resolve7, reject, options) {
    this._command = cmd, this._from = from, this._resolve = resolve7, this._reject = reject, this._snapshot = { ...options };
  }
  run() {
    var _a2, _b;
    let $2 = this._snapshot;
    if (this.child)
      return this;
    this._prerun(), $2.log({
      kind: "cmd",
      cmd: this._command,
      verbose: $2.verbose && !this._quiet
    }), this.child = $2.spawn($2.prefix + this._command, {
      cwd: $2.cwd ?? $2[processCwd],
      shell: typeof $2.shell == "string" ? $2.shell : !0,
      stdio: this._stdio,
      windowsHide: !0,
      env: $2.env
    }), this.child.on("close", (code, signal) => {
      let message = `exit code: ${code}`;
      (code != 0 || signal != null) && (message = `${stderr || `
`}    at ${this._from}`, message += `
    exit code: ${code}${exitCodeInfo(code) ? " (" + exitCodeInfo(code) + ")" : ""}`, signal != null && (message += `
    signal: ${signal}`));
      let output = new ProcessOutput(code, signal, stdout, stderr, combined, message);
      code === 0 || this._nothrow ? this._resolve(output) : this._reject(output), this._resolved = !0;
    }), this.child.on("error", (err) => {
      let message = `${err.message}
    errno: ${err.errno} (${errnoMessage(err.errno)})
    code: ${err.code}
    at ${this._from}`;
      this._reject(new ProcessOutput(null, null, stdout, stderr, combined, message)), this._resolved = !0;
    });
    let stdout = "", stderr = "", combined = "", onStdout = (data) => {
      $2.log({ kind: "stdout", data, verbose: $2.verbose && !this._quiet }), stdout += data, combined += data;
    }, onStderr = (data) => {
      $2.log({ kind: "stderr", data, verbose: $2.verbose && !this._quiet }), stderr += data, combined += data;
    };
    if (this._piped || (_a2 = this.child.stdout) == null || _a2.on("data", onStdout), (_b = this.child.stderr) == null || _b.on("data", onStderr), this._postrun(), this._timeout && this._timeoutSignal) {
      let t = setTimeout(() => this.kill(this._timeoutSignal), this._timeout);
      this.finally(() => clearTimeout(t)).catch(noop);
    }
    return this;
  }
  get stdin() {
    if (this.stdio("pipe"), this.run(), (0, import_node_assert.default)(this.child), this.child.stdin == null)
      throw new Error("The stdin of subprocess is null.");
    return this.child.stdin;
  }
  get stdout() {
    if (this.run(), (0, import_node_assert.default)(this.child), this.child.stdout == null)
      throw new Error("The stdout of subprocess is null.");
    return this.child.stdout;
  }
  get stderr() {
    if (this.run(), (0, import_node_assert.default)(this.child), this.child.stderr == null)
      throw new Error("The stderr of subprocess is null.");
    return this.child.stderr;
  }
  get exitCode() {
    return this.then((p) => p.exitCode, (p) => p.exitCode);
  }
  then(onfulfilled, onrejected) {
    if (this.isHalted && !this.child)
      throw new Error("The process is halted!");
    return super.then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return super.catch(onrejected);
  }
  pipe(dest) {
    if (typeof dest == "string")
      throw new Error("The pipe() method does not take strings. Forgot $?");
    if (this._resolved)
      throw dest instanceof _ProcessPromise && dest.stdin.end(), new Error("The pipe() method shouldn't be called after promise is already resolved!");
    return this._piped = !0, dest instanceof _ProcessPromise ? (dest.stdio("pipe"), dest._prerun = this.run.bind(this), dest._postrun = () => {
      if (!dest.child)
        throw new Error("Access to stdin of pipe destination without creation a subprocess.");
      this.stdout.pipe(dest.stdin);
    }, dest) : (this._postrun = () => this.stdout.pipe(dest), this);
  }
  async kill(signal = "SIGTERM") {
    if (!this.child)
      throw new Error("Trying to kill a process without creating one.");
    if (!this.child.pid)
      throw new Error("The process pid is undefined.");
    let children = await psTree(this.child.pid);
    for (let p of children)
      try {
        process.kill(+p.PID, signal);
      } catch {
      }
    try {
      process.kill(this.child.pid, signal);
    } catch {
    }
  }
  stdio(stdin, stdout = "pipe", stderr = "pipe") {
    return this._stdio = [stdin, stdout, stderr], this;
  }
  nothrow() {
    return this._nothrow = !0, this;
  }
  quiet() {
    return this._quiet = !0, this;
  }
  timeout(d, signal = "SIGTERM") {
    return this._timeout = parseDuration(d), this._timeoutSignal = signal, this;
  }
  halt() {
    return this._halted = !0, this;
  }
  get isHalted() {
    return this._halted;
  }
}, ProcessOutput = class extends Error {
  constructor(code, signal, stdout, stderr, combined, message) {
    super(message), this._code = code, this._signal = signal, this._stdout = stdout, this._stderr = stderr, this._combined = combined;
  }
  toString() {
    return this._combined;
  }
  get stdout() {
    return this._stdout;
  }
  get stderr() {
    return this._stderr;
  }
  get exitCode() {
    return this._code;
  }
  get signal() {
    return this._signal;
  }
  [import_node_util2.inspect.custom]() {
    let stringify = (s, c) => s.length === 0 ? "''" : c((0, import_node_util2.inspect)(s));
    return `ProcessOutput {
  stdout: ${stringify(this.stdout, source_default.green)},
  stderr: ${stringify(this.stderr, source_default.red)},
  signal: ${(0, import_node_util2.inspect)(this.signal)},
  exitCode: ${(this.exitCode === 0 ? source_default.green : source_default.red)(this.exitCode)}${exitCodeInfo(this.exitCode) ? source_default.grey(" (" + exitCodeInfo(this.exitCode) + ")") : ""}
}`;
  }
};
function syncCwd() {
  $[processCwd] != process.cwd() && process.chdir($[processCwd]);
}
function cd(dir) {
  dir instanceof ProcessOutput && (dir = dir.toString().replace(/\n+$/, "")), $.log({ kind: "cd", dir }), process.chdir(dir), $[processCwd] = process.cwd();
}
function log(entry) {
  switch (entry.kind) {
    case "cmd":
      if (!entry.verbose)
        return;
      process.stderr.write(formatCmd(entry.cmd));
      break;
    case "stdout":
    case "stderr":
      if (!entry.verbose)
        return;
      process.stderr.write(entry.data);
      break;
    case "cd":
      if (!$.verbose)
        return;
      process.stderr.write("$ " + source_default.greenBright("cd") + ` ${entry.dir}
`);
      break;
    case "fetch":
      if (!$.verbose)
        return;
      let init = entry.init ? " " + (0, import_node_util2.inspect)(entry.init) : "";
      process.stderr.write("$ " + source_default.greenBright("fetch") + ` ${entry.url}${init}
`);
      break;
    case "retry":
      if (!$.verbose)
        return;
      process.stderr.write(entry.error + `
`);
  }
}

// ../../node_modules/zx/node_modules/globby/index.js
var globby_exports = {};
__export(globby_exports, {
  generateGlobTasks: () => generateGlobTasks,
  generateGlobTasksSync: () => generateGlobTasksSync,
  globby: () => globby,
  globbyStream: () => globbyStream,
  globbySync: () => globbySync,
  isDynamicPattern: () => isDynamicPattern,
  isGitIgnored: () => isGitIgnored,
  isGitIgnoredSync: () => isGitIgnoredSync
});
var import_node_fs2 = __toESM(require("node:fs"), 1), import_node_path2 = __toESM(require("node:path"), 1), import_merge2 = __toESM(require_merge2(), 1), import_fast_glob2 = __toESM(require_out4(), 1), import_dir_glob = __toESM(require_dir_glob(), 1);

// ../../node_modules/zx/node_modules/globby/ignore.js
var import_node_process2 = __toESM(require("node:process"), 1), import_node_fs = __toESM(require("node:fs"), 1), import_node_path = __toESM(require("node:path"), 1), import_fast_glob = __toESM(require_out4(), 1), import_ignore = __toESM(require_ignore(), 1);

// ../../node_modules/zx/node_modules/slash/index.js
function slash(path6) {
  let isExtendedLengthPath = /^\\\\\?\\/.test(path6), hasNonAscii = /[^\u0000-\u0080]+/.test(path6);
  return isExtendedLengthPath || hasNonAscii ? path6 : path6.replace(/\\/g, "/");
}

// ../../node_modules/zx/node_modules/globby/utilities.js
var import_node_url = require("node:url"), import_node_stream = require("node:stream"), toPath = (urlOrPath) => urlOrPath instanceof URL ? (0, import_node_url.fileURLToPath)(urlOrPath) : urlOrPath, FilterStream = class extends import_node_stream.Transform {
  constructor(filter2) {
    super({
      objectMode: !0,
      transform(data, encoding, callback) {
        callback(void 0, filter2(data) ? data : void 0);
      }
    });
  }
}, isNegativePattern = (pattern) => pattern[0] === "!";

// ../../node_modules/zx/node_modules/globby/ignore.js
var ignoreFilesGlobOptions = {
  ignore: [
    "**/node_modules",
    "**/flow-typed",
    "**/coverage",
    "**/.git"
  ],
  absolute: !0,
  dot: !0
}, GITIGNORE_FILES_PATTERN = "**/.gitignore", applyBaseToPattern = (pattern, base) => isNegativePattern(pattern) ? "!" + import_node_path.default.posix.join(base, pattern.slice(1)) : import_node_path.default.posix.join(base, pattern), parseIgnoreFile = (file, cwd2) => {
  let base = slash(import_node_path.default.relative(cwd2, import_node_path.default.dirname(file.filePath)));
  return file.content.split(/\r?\n/).filter((line) => line && !line.startsWith("#")).map((pattern) => applyBaseToPattern(pattern, base));
}, toRelativePath = (fileOrDirectory, cwd2) => {
  if (cwd2 = slash(cwd2), import_node_path.default.isAbsolute(fileOrDirectory)) {
    if (slash(fileOrDirectory).startsWith(cwd2))
      return import_node_path.default.relative(cwd2, fileOrDirectory);
    throw new Error(`Path ${fileOrDirectory} is not in cwd ${cwd2}`);
  }
  return fileOrDirectory;
}, getIsIgnoredPredicate = (files, cwd2) => {
  let patterns = files.flatMap((file) => parseIgnoreFile(file, cwd2)), ignores = (0, import_ignore.default)().add(patterns);
  return (fileOrDirectory) => (fileOrDirectory = toPath(fileOrDirectory), fileOrDirectory = toRelativePath(fileOrDirectory, cwd2), fileOrDirectory ? ignores.ignores(slash(fileOrDirectory)) : !1);
}, normalizeOptions = (options = {}) => ({
  cwd: toPath(options.cwd) || import_node_process2.default.cwd(),
  suppressErrors: !!options.suppressErrors,
  deep: typeof options.deep == "number" ? options.deep : Number.POSITIVE_INFINITY
}), isIgnoredByIgnoreFiles = async (patterns, options) => {
  let { cwd: cwd2, suppressErrors, deep } = normalizeOptions(options), paths = await (0, import_fast_glob.default)(patterns, { cwd: cwd2, suppressErrors, deep, ...ignoreFilesGlobOptions }), files = await Promise.all(
    paths.map(async (filePath) => ({
      filePath,
      content: await import_node_fs.default.promises.readFile(filePath, "utf8")
    }))
  );
  return getIsIgnoredPredicate(files, cwd2);
}, isIgnoredByIgnoreFilesSync = (patterns, options) => {
  let { cwd: cwd2, suppressErrors, deep } = normalizeOptions(options), files = import_fast_glob.default.sync(patterns, { cwd: cwd2, suppressErrors, deep, ...ignoreFilesGlobOptions }).map((filePath) => ({
    filePath,
    content: import_node_fs.default.readFileSync(filePath, "utf8")
  }));
  return getIsIgnoredPredicate(files, cwd2);
}, isGitIgnored = (options) => isIgnoredByIgnoreFiles(GITIGNORE_FILES_PATTERN, options), isGitIgnoredSync = (options) => isIgnoredByIgnoreFilesSync(GITIGNORE_FILES_PATTERN, options);

// ../../node_modules/zx/node_modules/globby/index.js
var assertPatternsInput = (patterns) => {
  if (patterns.some((pattern) => typeof pattern != "string"))
    throw new TypeError("Patterns must be a string or an array of strings");
}, toPatternsArray = (patterns) => (patterns = [...new Set([patterns].flat())], assertPatternsInput(patterns), patterns), checkCwdOption = (options) => {
  if (!options.cwd)
    return;
  let stat3;
  try {
    stat3 = import_node_fs2.default.statSync(options.cwd);
  } catch {
    return;
  }
  if (!stat3.isDirectory())
    throw new Error("The `cwd` option must be a path to a directory");
}, normalizeOptions2 = (options = {}) => (options = {
  ...options,
  ignore: options.ignore || [],
  expandDirectories: options.expandDirectories === void 0 ? !0 : options.expandDirectories,
  cwd: toPath(options.cwd)
}, checkCwdOption(options), options), normalizeArguments = (fn) => async (patterns, options) => fn(toPatternsArray(patterns), normalizeOptions2(options)), normalizeArgumentsSync = (fn) => (patterns, options) => fn(toPatternsArray(patterns), normalizeOptions2(options)), getIgnoreFilesPatterns = (options) => {
  let { ignoreFiles, gitignore } = options, patterns = ignoreFiles ? toPatternsArray(ignoreFiles) : [];
  return gitignore && patterns.push(GITIGNORE_FILES_PATTERN), patterns;
}, getFilter = async (options) => {
  let ignoreFilesPatterns = getIgnoreFilesPatterns(options);
  return createFilterFunction(
    ignoreFilesPatterns.length > 0 && await isIgnoredByIgnoreFiles(ignoreFilesPatterns, options)
  );
}, getFilterSync = (options) => {
  let ignoreFilesPatterns = getIgnoreFilesPatterns(options);
  return createFilterFunction(
    ignoreFilesPatterns.length > 0 && isIgnoredByIgnoreFilesSync(ignoreFilesPatterns, options)
  );
}, createFilterFunction = (isIgnored) => {
  let seen = /* @__PURE__ */ new Set();
  return (fastGlobResult) => {
    let path6 = fastGlobResult.path || fastGlobResult, pathKey = import_node_path2.default.normalize(path6), seenOrIgnored = seen.has(pathKey) || isIgnored && isIgnored(path6);
    return seen.add(pathKey), !seenOrIgnored;
  };
}, unionFastGlobResults = (results, filter2) => results.flat().filter((fastGlobResult) => filter2(fastGlobResult)), unionFastGlobStreams = (streams, filter2) => (0, import_merge2.default)(streams).pipe(new FilterStream((fastGlobResult) => filter2(fastGlobResult))), convertNegativePatterns = (patterns, options) => {
  let tasks = [];
  for (; patterns.length > 0; ) {
    let index = patterns.findIndex((pattern) => isNegativePattern(pattern));
    if (index === -1) {
      tasks.push({ patterns, options });
      break;
    }
    let ignorePattern = patterns[index].slice(1);
    for (let task of tasks)
      task.options.ignore.push(ignorePattern);
    index !== 0 && tasks.push({
      patterns: patterns.slice(0, index),
      options: {
        ...options,
        ignore: [
          ...options.ignore,
          ignorePattern
        ]
      }
    }), patterns = patterns.slice(index + 1);
  }
  return tasks;
}, getDirGlobOptions = (options, cwd2) => ({
  ...cwd2 ? { cwd: cwd2 } : {},
  ...Array.isArray(options) ? { files: options } : options
}), generateTasks = async (patterns, options) => {
  let globTasks = convertNegativePatterns(patterns, options), { cwd: cwd2, expandDirectories } = options;
  if (!expandDirectories)
    return globTasks;
  let patternExpandOptions = getDirGlobOptions(expandDirectories, cwd2), ignoreExpandOptions = cwd2 ? { cwd: cwd2 } : void 0;
  return Promise.all(
    globTasks.map(async (task) => {
      let { patterns: patterns2, options: options2 } = task;
      return [
        patterns2,
        options2.ignore
      ] = await Promise.all([
        (0, import_dir_glob.default)(patterns2, patternExpandOptions),
        (0, import_dir_glob.default)(options2.ignore, ignoreExpandOptions)
      ]), { patterns: patterns2, options: options2 };
    })
  );
}, generateTasksSync = (patterns, options) => {
  let globTasks = convertNegativePatterns(patterns, options), { cwd: cwd2, expandDirectories } = options;
  if (!expandDirectories)
    return globTasks;
  let patternExpandOptions = getDirGlobOptions(expandDirectories, cwd2), ignoreExpandOptions = cwd2 ? { cwd: cwd2 } : void 0;
  return globTasks.map((task) => {
    let { patterns: patterns2, options: options2 } = task;
    return patterns2 = import_dir_glob.default.sync(patterns2, patternExpandOptions), options2.ignore = import_dir_glob.default.sync(options2.ignore, ignoreExpandOptions), { patterns: patterns2, options: options2 };
  });
}, globby = normalizeArguments(async (patterns, options) => {
  let [
    tasks,
    filter2
  ] = await Promise.all([
    generateTasks(patterns, options),
    getFilter(options)
  ]), results = await Promise.all(tasks.map((task) => (0, import_fast_glob2.default)(task.patterns, task.options)));
  return unionFastGlobResults(results, filter2);
}), globbySync = normalizeArgumentsSync((patterns, options) => {
  let tasks = generateTasksSync(patterns, options), filter2 = getFilterSync(options), results = tasks.map((task) => import_fast_glob2.default.sync(task.patterns, task.options));
  return unionFastGlobResults(results, filter2);
}), globbyStream = normalizeArgumentsSync((patterns, options) => {
  let tasks = generateTasksSync(patterns, options), filter2 = getFilterSync(options), streams = tasks.map((task) => import_fast_glob2.default.stream(task.patterns, task.options));
  return unionFastGlobStreams(streams, filter2);
}), isDynamicPattern = normalizeArgumentsSync(
  (patterns, options) => patterns.some((pattern) => import_fast_glob2.default.isDynamicPattern(pattern, options))
), generateGlobTasks = normalizeArguments(generateTasks), generateGlobTasksSync = normalizeArgumentsSync(generateTasksSync);

// ../../node_modules/zx/build/goods.js
var import_minimist = __toESM(require_minimist(), 1);
var import_which2 = __toESM(require_lib3(), 1), import_yaml = __toESM(require_dist2(), 1);
var argv = (0, import_minimist.default)(process.argv.slice(2));
var globby2 = Object.assign(function(patterns, options) {
  return globby(patterns, options);
}, globby_exports);

// package.json
var package_default = {
  name: "create-tamagui",
  version: "1.85.1",
  bin: "./run.js",
  main: "dist",
  files: [
    "run.js",
    "dist"
  ],
  scripts: {
    start: "./run.js",
    test: "NODE_ENV=test node -r esbuild-register ../../node_modules/.bin/playwright test integration.test.ts",
    "test:debug": "yarn test --debug",
    prerelease: "rimraf ./dist/",
    prepublish: "yarn build",
    build: "tamagui-build --skip-types --bundle --bundle-modules",
    watch: "yarn build --watch",
    clean: "tamagui-build clean",
    "clean:build": "tamagui-build clean:build"
  },
  devDependencies: {
    "@expo/package-manager": "^1.1.2",
    "@playwright/test": "^1.40.1",
    "@tamagui/build": "1.85.1",
    "@types/async-retry": "1.4.2",
    "@types/cross-spawn": "^6.0.2",
    "@types/node": "^16.11.9",
    "@types/opener": "^1.4.3",
    "@types/prompts": "2.0.1",
    "@types/rimraf": "3.0.0",
    "@types/tar": "4.0.3",
    "@types/validate-npm-package-name": "3.0.0",
    "async-retry": "1.3.1",
    chalk: "^4.1.2",
    commander: "2.20.0",
    cpy: "7.3.0",
    "cross-spawn": "6.0.5",
    "detect-package-manager": "^3.0.1",
    "esbuild-register": "^3.4.2",
    "fs-extra": "^11.1.0",
    got: "10.7.0",
    opener: "^1.5.2",
    prompts: "2.1.0",
    rimraf: "^5.0.1",
    tar: "4.4.10",
    "update-check": "1.5.4",
    "validate-npm-package-name": "3.0.0",
    "wait-port": "^0.3.0",
    zx: "^7.2.3"
  },
  engines: {
    node: ">=12.22.0"
  },
  publishConfig: {
    access: "public"
  },
  gitHead: "a49cc7ea6b93ba384e77a4880ae48ac4a5635c14"
};

// src/create-tamagui-constants.ts
var IS_TEST = process.env.NODE_ENV === "test";

// src/helpers/asciiArts.ts
var import_chalk6 = __toESM(require_source());

// src/helpers/rainbowChalk.ts
var import_chalk5 = __toESM(require_source()), rainbowColors = [
  "#f76808",
  "#f5d90a",
  "#30a46c",
  "#0091ff",
  "#8e4ec6",
  "#d6409f",
  "#e5484d"
], makeRainbowChalk = (text) => text.split("").map((char, idx) => import_chalk5.default.hex(rainbowColors[idx % rainbowColors.length])(char)).join("");

// src/helpers/asciiArts.ts
var tamaguiRainbowAsciiArt = function() {
  let char0_1 = import_chalk6.default.hex(rainbowColors[0])("\u2580\u2588\u2580"), char0_2 = import_chalk6.default.hex(rainbowColors[0])(" \u2588 "), char1_1 = import_chalk6.default.hex(rainbowColors[1])("\u2584\u2580\u2588"), char1_2 = import_chalk6.default.hex(rainbowColors[1])("\u2588\u2580\u2588"), char2_1 = import_chalk6.default.hex(rainbowColors[2])("\u2588\u2580\u2584\u2580\u2588"), char2_2 = import_chalk6.default.hex(rainbowColors[2])("\u2588 \u2580 \u2588"), char3_1 = import_chalk6.default.hex(rainbowColors[3])("\u2584\u2580\u2588"), char3_2 = import_chalk6.default.hex(rainbowColors[3])("\u2588\u2580\u2588"), char4_1 = import_chalk6.default.hex(rainbowColors[4])("\u2588\u2580\u2580"), char4_2 = import_chalk6.default.hex(rainbowColors[4])("\u2588\u2584\u2588"), char5_1 = import_chalk6.default.hex(rainbowColors[5])("\u2588 \u2588"), char5_2 = import_chalk6.default.hex(rainbowColors[5])("\u2588\u2584\u2588"), char6_1 = import_chalk6.default.hex(rainbowColors[6])("\u2588"), char6_2 = import_chalk6.default.hex(rainbowColors[6])("\u2588");
  return `${char0_1}\u2003${char1_1}\u2003${char2_1}\u2003${char3_1}\u2003${char4_1}\u2003${char5_1}\u2003${char6_1}
${char0_2}\u2003${char1_2}\u2003${char2_2}\u2003${char3_2}\u2003${char4_2}\u2003${char5_2}\u2003${char6_2}
`;
}(), takeoutAsciiArt = `\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557
\u255A\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2588\u2588\u2554\u255D\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255D\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u255A\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255D
\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2550\u255D\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591
\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u2550\u2550\u255D\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591
\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u255A\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255A\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u255A\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255D\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591
\u2591\u2591\u2591\u255A\u2550\u255D\u2591\u2591\u2591\u255A\u2550\u255D\u2591\u2591\u255A\u2550\u255D\u255A\u2550\u255D\u2591\u2591\u255A\u2550\u255D\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u255D\u2591\u255A\u2550\u2550\u2550\u2550\u255D\u2591\u2591\u255A\u2550\u2550\u2550\u2550\u2550\u255D\u2591\u2591\u2591\u2591\u255A\u2550\u255D\u2591\u2591\u2591`, tamaguiDuckAsciiArt = `        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588          
      \u2588\u2588            \u2588\u2588        
    \u2588\u2588            \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  
  \u2588\u2588        \u2588\u2588              \u2588\u2588
  \u2588\u2588                  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588
  \u2588\u2588                        \u2588\u2588
  \u2588\u2588                    \u2588\u2588\u2588\u2588  
\u2588\u2588                    \u2588\u2588      
\u2588\u2588                    \u2588\u2588      
\u2588\u2588                    \u2588\u2588      
  \u2588\u2588                \u2588\u2588        
    \u2588\u2588            \u2588\u2588          
      \u2588\u2588    \u2588\u2588\u2588\u2588  \u2588\u2588          
        \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588            `;

// src/helpers/cloneStarter.ts
var import_child_process = require("child_process"), import_os2 = require("os"), import_path8 = require("path"), import_chalk7 = __toESM(require_source()), import_fs_extra = __toESM(require_lib());

// ../../node_modules/rimraf/dist/mjs/opt-arg.js
var optArgT = (opt) => {
  assertRimrafOptions(opt);
  let { glob: glob2, ...options } = opt;
  if (!glob2)
    return options;
  let globOpt = glob2 === !0 ? opt.signal ? { signal: opt.signal } : {} : opt.signal ? {
    signal: opt.signal,
    ...glob2
  } : glob2;
  return {
    ...options,
    glob: {
      ...globOpt,
      // always get absolute paths from glob, to ensure
      // that we are referencing the correct thing.
      absolute: !0,
      withFileTypes: !1
    }
  };
}, optArg = (opt = {}) => optArgT(opt), optArgSync = (opt = {}) => optArgT(opt);

// ../../node_modules/rimraf/dist/mjs/path-arg.js
var import_path2 = require("path"), import_util4 = require("util");

// ../../node_modules/rimraf/dist/mjs/platform.js
var platform_default = process.env.__TESTING_RIMRAF_PLATFORM__ || process.platform;

// ../../node_modules/rimraf/dist/mjs/path-arg.js
var pathArg = (path6, opt = {}) => {
  let type = typeof path6;
  if (type !== "string") {
    let ctor = path6 && type === "object" && path6.constructor, msg = `The "path" argument must be of type string. Received ${ctor && ctor.name ? `an instance of ${ctor.name}` : type === "object" ? (0, import_util4.inspect)(path6) : `type ${type} ${path6}`}`;
    throw Object.assign(new TypeError(msg), {
      path: path6,
      code: "ERR_INVALID_ARG_TYPE"
    });
  }
  if (/\0/.test(path6)) {
    let msg = "path must be a string without null bytes";
    throw Object.assign(new TypeError(msg), {
      path: path6,
      code: "ERR_INVALID_ARG_VALUE"
    });
  }
  path6 = (0, import_path2.resolve)(path6);
  let { root } = (0, import_path2.parse)(path6);
  if (path6 === root && opt.preserveRoot !== !1) {
    let msg = "refusing to remove root directory without preserveRoot:false";
    throw Object.assign(new Error(msg), {
      path: path6,
      code: "ERR_PRESERVE_ROOT"
    });
  }
  if (platform_default === "win32") {
    let badWinChars = /[*|"<>?:]/, { root: root2 } = (0, import_path2.parse)(path6);
    if (badWinChars.test(path6.substring(root2.length)))
      throw Object.assign(new Error("Illegal characters in path."), {
        path: path6,
        code: "EINVAL"
      });
  }
  return path6;
}, path_arg_default = pathArg;

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/index.js
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/assert-valid-pattern.js
var assertValidPattern = (pattern) => {
  if (typeof pattern != "string")
    throw new TypeError("invalid pattern");
  if (pattern.length > 65536)
    throw new TypeError("pattern is too long");
};

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/brace-expressions.js
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
  "[:alpha:]": ["\\p{L}\\p{Nl}", !0],
  "[:ascii:]": ["\\x00-\\x7f", !1],
  "[:blank:]": ["\\p{Zs}\\t", !0],
  "[:cntrl:]": ["\\p{Cc}", !0],
  "[:digit:]": ["\\p{Nd}", !0],
  "[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
  "[:lower:]": ["\\p{Ll}", !0],
  "[:print:]": ["\\p{C}", !0],
  "[:punct:]": ["\\p{P}", !0],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
  "[:upper:]": ["\\p{Lu}", !0],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
  "[:xdigit:]": ["A-Fa-f0-9", !1]
}, braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&"), regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), rangesToString = (ranges) => ranges.join(""), parseClass = (glob2, position) => {
  let pos = position;
  if (glob2.charAt(pos) !== "[")
    throw new Error("not in a brace expression");
  let ranges = [], negs = [], i = pos + 1, sawStart = !1, uflag = !1, escaping = !1, negate = !1, endPos = pos, rangeStart = "";
  WHILE:
    for (; i < glob2.length; ) {
      let c = glob2.charAt(i);
      if ((c === "!" || c === "^") && i === pos + 1) {
        negate = !0, i++;
        continue;
      }
      if (c === "]" && sawStart && !escaping) {
        endPos = i + 1;
        break;
      }
      if (sawStart = !0, c === "\\" && !escaping) {
        escaping = !0, i++;
        continue;
      }
      if (c === "[" && !escaping) {
        for (let [cls, [unip, u, neg]] of Object.entries(posixClasses))
          if (glob2.startsWith(cls, i)) {
            if (rangeStart)
              return ["$.", !1, glob2.length - pos, !0];
            i += cls.length, neg ? negs.push(unip) : ranges.push(unip), uflag = uflag || u;
            continue WHILE;
          }
      }
      if (escaping = !1, rangeStart) {
        c > rangeStart ? ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c)) : c === rangeStart && ranges.push(braceEscape(c)), rangeStart = "", i++;
        continue;
      }
      if (glob2.startsWith("-]", i + 1)) {
        ranges.push(braceEscape(c + "-")), i += 2;
        continue;
      }
      if (glob2.startsWith("-", i + 1)) {
        rangeStart = c, i += 2;
        continue;
      }
      ranges.push(braceEscape(c)), i++;
    }
  if (endPos < i)
    return ["", !1, 0, !1];
  if (!ranges.length && !negs.length)
    return ["$.", !1, glob2.length - pos, !0];
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    let r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), !1, endPos - pos, !1];
  }
  let sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]", snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  return [ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs, uflag, endPos - pos, !0];
};

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/unescape.js
var unescape = (s, { windowsPathsNoEscape = !1 } = {}) => windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]), isExtglobType = (c) => types.has(c), startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))", startNoDot = "(?!\\.)", addPatternStart = /* @__PURE__ */ new Set(["[", "."]), justDots = /* @__PURE__ */ new Set(["..", "."]), reSpecials = new Set("().*{}+?[]^$\\!"), regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), qmark = "[^/]", star = qmark + "*?", starNoEmpty = qmark + "+?", AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = !1;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = !1;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = !1;
  constructor(type, parent, options = {}) {
    this.type = type, type && (this.#hasMagic = !0), this.#parent = parent, this.#root = this.#parent ? this.#parent.#root : this, this.#options = this.#root === this ? options : this.#root.#options, this.#negs = this.#root === this ? [] : this.#root.#negs, type === "!" && !this.#root.#filledNegs && this.#negs.push(this), this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (let p of this.#parts)
      if (typeof p != "string" && (p.type || p.hasMagic))
        return this.#hasMagic = !0;
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    return this.#toString !== void 0 ? this.#toString : this.type ? this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")" : this.#toString = this.#parts.map((p) => String(p)).join("");
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString(), this.#filledNegs = !0;
    let n;
    for (; n = this.#negs.pop(); ) {
      if (n.type !== "!")
        continue;
      let p = n, pp = p.#parent;
      for (; pp; ) {
        for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++)
          for (let part of n.#parts) {
            if (typeof part == "string")
              throw new Error("string part in extglob AST??");
            part.copyIn(pp.#parts[i]);
          }
        p = pp, pp = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (let p of parts)
      if (p !== "") {
        if (typeof p != "string" && !(p instanceof _AST && p.#parent === this))
          throw new Error("invalid part: " + p);
        this.#parts.push(p);
      }
  }
  toJSON() {
    var _a2;
    let ret = this.type === null ? this.#parts.slice().map((p) => typeof p == "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    return this.isStart() && !this.type && ret.unshift([]), this.isEnd() && (this === this.#root || this.#root.#filledNegs && ((_a2 = this.#parent) == null ? void 0 : _a2.type) === "!") && ret.push({}), ret;
  }
  isStart() {
    var _a2;
    if (this.#root === this)
      return !0;
    if (!((_a2 = this.#parent) != null && _a2.isStart()))
      return !1;
    if (this.#parentIndex === 0)
      return !0;
    let p = this.#parent;
    for (let i = 0; i < this.#parentIndex; i++) {
      let pp = p.#parts[i];
      if (!(pp instanceof _AST && pp.type === "!"))
        return !1;
    }
    return !0;
  }
  isEnd() {
    var _a2, _b, _c;
    if (this.#root === this || ((_a2 = this.#parent) == null ? void 0 : _a2.type) === "!")
      return !0;
    if (!((_b = this.#parent) != null && _b.isEnd()))
      return !1;
    if (!this.type)
      return (_c = this.#parent) == null ? void 0 : _c.isEnd();
    let pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    typeof part == "string" ? this.push(part) : this.push(part.clone(this));
  }
  clone(parent) {
    let c = new _AST(this.type, parent);
    for (let p of this.#parts)
      c.copyIn(p);
    return c;
  }
  static #parseAST(str, ast, pos, opt) {
    let escaping = !1, inBrace = !1, braceStart = -1, braceNeg = !1;
    if (ast.type === null) {
      let i2 = pos, acc2 = "";
      for (; i2 < str.length; ) {
        let c = str.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping, acc2 += c;
          continue;
        }
        if (inBrace) {
          i2 === braceStart + 1 ? (c === "^" || c === "!") && (braceNeg = !0) : c === "]" && !(i2 === braceStart + 2 && braceNeg) && (inBrace = !1), acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = !0, braceStart = i2, braceNeg = !1, acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
          ast.push(acc2), acc2 = "";
          let ext2 = new _AST(c, ast);
          i2 = _AST.#parseAST(str, ext2, i2, opt), ast.push(ext2);
          continue;
        }
        acc2 += c;
      }
      return ast.push(acc2), i2;
    }
    let i = pos + 1, part = new _AST(null, ast), parts = [], acc = "";
    for (; i < str.length; ) {
      let c = str.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping, acc += c;
        continue;
      }
      if (inBrace) {
        i === braceStart + 1 ? (c === "^" || c === "!") && (braceNeg = !0) : c === "]" && !(i === braceStart + 2 && braceNeg) && (inBrace = !1), acc += c;
        continue;
      } else if (c === "[") {
        inBrace = !0, braceStart = i, braceNeg = !1, acc += c;
        continue;
      }
      if (isExtglobType(c) && str.charAt(i) === "(") {
        part.push(acc), acc = "";
        let ext2 = new _AST(c, part);
        part.push(ext2), i = _AST.#parseAST(str, ext2, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc), acc = "", parts.push(part), part = new _AST(null, ast);
        continue;
      }
      if (c === ")")
        return acc === "" && ast.#parts.length === 0 && (ast.#emptyExt = !0), part.push(acc), acc = "", ast.push(...parts, part), i;
      acc += c;
    }
    return ast.type = null, ast.#hasMagic = void 0, ast.#parts = [str.substring(pos - 1)], i;
  }
  static fromGlob(pattern, options = {}) {
    let ast = new _AST(null, void 0, options);
    return _AST.#parseAST(pattern, ast, 0, options), ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    let glob2 = this.toString(), [re, body, hasMagic2, uflag] = this.toRegExpSource();
    if (!(hasMagic2 || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase()))
      return body;
    let flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob2
    });
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    var _a2;
    let dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this && this.#fillNegs(), !this.type) {
      let noEmpty = this.isStart() && this.isEnd(), src = this.#parts.map((p) => {
        let [re, _, hasMagic2, uflag] = typeof p == "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        return this.#hasMagic = this.#hasMagic || hasMagic2, this.#uflag = this.#uflag || uflag, re;
      }).join(""), start2 = "";
      if (this.isStart() && typeof this.#parts[0] == "string" && !(this.#parts.length === 1 && justDots.has(this.#parts[0]))) {
        let aps = addPatternStart, needNoTrav = (
          // dots are allowed, and the pattern starts with [ or .
          dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
          src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
          src.startsWith("\\.\\.") && aps.has(src.charAt(4))
        ), needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
        start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
      }
      let end = "";
      return this.isEnd() && this.#root.#filledNegs && ((_a2 = this.#parent) == null ? void 0 : _a2.type) === "!" && (end = "(?:$|\\/)"), [
        start2 + src + end,
        unescape(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    let repeated = this.type === "*" || this.type === "+", start = this.type === "!" ? "(?:(?!(?:" : "(?:", body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      let s = this.toString();
      return this.#parts = [s], this.type = null, this.#hasMagic = void 0, [s, unescape(this.toString()), !1, !1];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(!0);
    bodyDotAllowed === body && (bodyDotAllowed = ""), bodyDotAllowed && (body = `(?:${body})(?:${bodyDotAllowed})*?`);
    let final = "";
    if (this.type === "!" && this.#emptyExt)
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    else {
      let close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? ")?" : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p) => {
      if (typeof p == "string")
        throw new Error("string type in extglob ast??");
      let [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
      return this.#uflag = this.#uflag || uflag, re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob2, hasMagic2, noEmpty = !1) {
    let escaping = !1, re = "", uflag = !1;
    for (let i = 0; i < glob2.length; i++) {
      let c = glob2.charAt(i);
      if (escaping) {
        escaping = !1, re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        i === glob2.length - 1 ? re += "\\\\" : escaping = !0;
        continue;
      }
      if (c === "[") {
        let [src, needUflag, consumed, magic] = parseClass(glob2, i);
        if (consumed) {
          re += src, uflag = uflag || needUflag, i += consumed - 1, hasMagic2 = hasMagic2 || magic;
          continue;
        }
      }
      if (c === "*") {
        noEmpty && glob2 === "*" ? re += starNoEmpty : re += star, hasMagic2 = !0;
        continue;
      }
      if (c === "?") {
        re += qmark, hasMagic2 = !0;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape(glob2), !!hasMagic2, uflag];
  }
};

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/escape.js
var escape = (s, { windowsPathsNoEscape = !1 } = {}) => windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");

// ../../node_modules/rimraf/node_modules/minimatch/dist/mjs/index.js
var minimatch = (p, pattern, options = {}) => (assertValidPattern(pattern), !options.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch(pattern, options).match(p)), starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/, starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2), starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2), starDotExtTestNocase = (ext2) => (ext2 = ext2.toLowerCase(), (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2)), starDotExtTestNocaseDot = (ext2) => (ext2 = ext2.toLowerCase(), (f) => f.toLowerCase().endsWith(ext2)), starDotStarRE = /^\*+\.\*+$/, starDotStarTest = (f) => !f.startsWith(".") && f.includes("."), starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes("."), dotStarRE = /^\.\*+$/, dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith("."), starRE = /^\*+$/, starTest = (f) => f.length !== 0 && !f.startsWith("."), starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..", qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/, qmarksTestNocase = ([$0, ext2 = ""]) => {
  let noext = qmarksTestNoExt([$0]);
  return ext2 ? (ext2 = ext2.toLowerCase(), (f) => noext(f) && f.toLowerCase().endsWith(ext2)) : noext;
}, qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  let noext = qmarksTestNoExtDot([$0]);
  return ext2 ? (ext2 = ext2.toLowerCase(), (f) => noext(f) && f.toLowerCase().endsWith(ext2)) : noext;
}, qmarksTestDot = ([$0, ext2 = ""]) => {
  let noext = qmarksTestNoExtDot([$0]);
  return ext2 ? (f) => noext(f) && f.endsWith(ext2) : noext;
}, qmarksTest = ([$0, ext2 = ""]) => {
  let noext = qmarksTestNoExt([$0]);
  return ext2 ? (f) => noext(f) && f.endsWith(ext2) : noext;
}, qmarksTestNoExt = ([$0]) => {
  let len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
}, qmarksTestNoExtDot = ([$0]) => {
  let len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
}, defaultPlatform = typeof process == "object" && process ? typeof process.env == "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix", path2 = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
}, sep = defaultPlatform === "win32" ? path2.win32.sep : path2.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]", star2 = qmark2 + "*?", twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?", filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
var ext = (a, b = {}) => Object.assign({}, a, b), defaults2 = (def) => {
  if (!def || typeof def != "object" || !Object.keys(def).length)
    return minimatch;
  let orig = minimatch;
  return Object.assign((p, pattern, options = {}) => orig(p, pattern, ext(def, options)), {
    Minimatch: class extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults2;
var braceExpand = (pattern, options = {}) => (assertValidPattern(pattern), options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [pattern] : (0, import_brace_expansion.default)(pattern));
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  let mm = new Minimatch(pattern, options);
  return list = list.filter((f) => mm.match(f)), mm.options.nonull && !list.length && list.push(pattern), list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/, regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern), options = options || {}, this.options = options, this.pattern = pattern, this.platform = options.platform || defaultPlatform, this.isWindows = this.platform === "win32", this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!options.preserveMultipleSlashes, this.regexp = null, this.negate = !1, this.nonegate = !!options.nonegate, this.comment = !1, this.empty = !1, this.partial = !!options.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1)
      return !0;
    for (let pattern of this.set)
      for (let part of pattern)
        if (typeof part != "string")
          return !0;
    return !1;
  }
  debug(..._) {
  }
  make() {
    let pattern = this.pattern, options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!pattern) {
      this.empty = !0;
      return;
    }
    this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], options.debug && (this.debug = (...args) => console.error(...args)), this.debug(this.pattern, this.globSet);
    let rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts), this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s, _, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        let isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]), isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC)
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        if (isDrive)
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
      }
      return s.map((ss) => this.parse(ss));
    });
    if (this.debug(this.pattern, set), this.set = set.filter((s) => s.indexOf(!1) === -1), this.isWindows)
      for (let i = 0; i < this.set.length; i++) {
        let p = this.set[i];
        p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] == "string" && /^[a-z]:$/i.test(p[3]) && (p[2] = "?");
      }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar)
      for (let i = 0; i < globParts.length; i++)
        for (let j = 0; j < globParts[i].length; j++)
          globParts[i][j] === "**" && (globParts[i][j] = "*");
    let { optimizationLevel = 1 } = this.options;
    return optimizationLevel >= 2 ? (globParts = this.firstPhasePreProcess(globParts), globParts = this.secondPhasePreProcess(globParts)) : optimizationLevel >= 1 ? globParts = this.levelOneOptimize(globParts) : globParts = this.adjascentGlobstarOptimize(globParts), globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      for (; (gs = parts.indexOf("**", gs + 1)) !== -1; ) {
        let i = gs;
        for (; parts[i + 1] === "**"; )
          i++;
        i !== gs && parts.splice(gs, i - gs);
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => (parts = parts.reduce((set, part) => {
      let prev = set[set.length - 1];
      return part === "**" && prev === "**" ? set : part === ".." && prev && prev !== ".." && prev !== "." && prev !== "**" ? (set.pop(), set) : (set.push(part), set);
    }, []), parts.length === 0 ? [""] : parts));
  }
  levelTwoFileOptimize(parts) {
    Array.isArray(parts) || (parts = this.slashSplit(parts));
    let didSomething = !1;
    do {
      if (didSomething = !1, !this.preserveMultipleSlashes) {
        for (let i = 1; i < parts.length - 1; i++) {
          let p = parts[i];
          i === 1 && p === "" && parts[0] === "" || (p === "." || p === "") && (didSomething = !0, parts.splice(i, 1), i--);
        }
        parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
      }
      let dd = 0;
      for (; (dd = parts.indexOf("..", dd + 1)) !== -1; ) {
        let p = parts[dd - 1];
        p && p !== "." && p !== ".." && p !== "**" && (didSomething = !0, parts.splice(dd - 1, 2), dd -= 2);
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = !1;
    do {
      didSomething = !1;
      for (let parts of globParts) {
        let gs = -1;
        for (; (gs = parts.indexOf("**", gs + 1)) !== -1; ) {
          let gss = gs;
          for (; parts[gss + 1] === "**"; )
            gss++;
          gss > gs && parts.splice(gs + 1, gss - gs);
          let next = parts[gs + 1], p = parts[gs + 2], p2 = parts[gs + 3];
          if (next !== ".." || !p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..")
            continue;
          didSomething = !0, parts.splice(gs, 1);
          let other = parts.slice(0);
          other[gs] = "**", globParts.push(other), gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            let p = parts[i];
            i === 1 && p === "" && parts[0] === "" || (p === "." || p === "") && (didSomething = !0, parts.splice(i, 1), i--);
          }
          parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
        }
        let dd = 0;
        for (; (dd = parts.indexOf("..", dd + 1)) !== -1; ) {
          let p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = !0;
            let splin = dd === 1 && parts[dd + 1] === "**" ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin), parts.length === 0 && parts.push(""), dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i = 0; i < globParts.length - 1; i++)
      for (let j = i + 1; j < globParts.length; j++) {
        let matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        matched && (globParts[i] = matched, globParts[j] = []);
      }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = !1) {
    let ai = 0, bi = 0, result = [], which2 = "";
    for (; ai < a.length && bi < b.length; )
      if (a[ai] === b[bi])
        result.push(which2 === "b" ? b[bi] : a[ai]), ai++, bi++;
      else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1])
        result.push(a[ai]), ai++;
      else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1])
        result.push(b[bi]), bi++;
      else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which2 === "b")
          return !1;
        which2 = "a", result.push(a[ai]), ai++, bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which2 === "a")
          return !1;
        which2 = "b", result.push(b[bi]), ai++, bi++;
      } else
        return !1;
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    let pattern = this.pattern, negate = !1, negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++)
      negate = !negate, negateOffset++;
    negateOffset && (this.pattern = pattern.slice(negateOffset)), this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = !1) {
    let options = this.options;
    if (this.isWindows) {
      let fileDrive = typeof file[0] == "string" && /^[a-z]:$/i.test(file[0]), fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]), patternDrive = typeof pattern[0] == "string" && /^[a-z]:$/i.test(pattern[0]), patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] == "string" && /^[a-z]:$/i.test(pattern[3]), fdi = fileUNC ? 3 : fileDrive ? 0 : void 0, pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi == "number" && typeof pdi == "number") {
        let [fd, pd] = [file[fdi], pattern[pdi]];
        fd.toLowerCase() === pd.toLowerCase() && (pattern[pdi] = fd, pdi > fdi ? pattern = pattern.slice(pdi) : fdi > pdi && (file = file.slice(fdi)));
      }
    }
    let { optimizationLevel = 1 } = this.options;
    optimizationLevel >= 2 && (file = this.levelTwoFileOptimize(file)), this.debug("matchOne", this, { file, pattern }), this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi], f = file[fi];
      if (this.debug(pattern, p, f), p === !1)
        return !1;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi, pr = pi + 1;
        if (pr === pl) {
          for (this.debug("** at the end"); fi < fl; fi++)
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return !1;
          return !0;
        }
        for (; fr < fl; ) {
          var swallowee = file[fr];
          if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial))
            return this.debug("globstar found match!", fr, fl, swallowee), !0;
          if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
            this.debug("dot detected!", file, fr, pattern, pr);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), fr++;
        }
        return !!(partial && (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl));
      }
      let hit;
      if (typeof p == "string" ? (hit = f === p, this.debug("string match", p, f, hit)) : (hit = p.test(f), this.debug("pattern match", p, f, hit)), !hit)
        return !1;
    }
    if (fi === fl && pi === pl)
      return !0;
    if (fi === fl)
      return partial;
    if (pi === pl)
      return fi === fl - 1 && file[fi] === "";
    throw new Error("wtf?");
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    let options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m, fastTest = null;
    (m = pattern.match(starRE)) ? fastTest = options.dot ? starTestDot : starTest : (m = pattern.match(starDotExtRE)) ? fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]) : (m = pattern.match(qmarksRE)) ? fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m) : (m = pattern.match(starDotStarRE)) ? fastTest = options.dot ? starDotStarTestDot : starDotStarTest : (m = pattern.match(dotStarRE)) && (fastTest = dotStarTest);
    let re = AST.fromGlob(pattern, this.options).toMMPattern();
    return fastTest ? Object.assign(re, { test: fastTest }) : re;
  }
  makeRe() {
    if (this.regexp || this.regexp === !1)
      return this.regexp;
    let set = this.set;
    if (!set.length)
      return this.regexp = !1, this.regexp;
    let options = this.options, twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot, flags = new Set(options.nocase ? ["i"] : []), re = set.map((pattern) => {
      let pp = pattern.map((p) => {
        if (p instanceof RegExp)
          for (let f of p.flags.split(""))
            flags.add(f);
        return typeof p == "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      return pp.forEach((p, i) => {
        let next = pp[i + 1], prev = pp[i - 1];
        p !== GLOBSTAR || prev === GLOBSTAR || (prev === void 0 ? next !== void 0 && next !== GLOBSTAR ? pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next : pp[i] = twoStar : next === void 0 ? pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?" : next !== GLOBSTAR && (pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next, pp[i + 1] = GLOBSTAR));
      }), pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|"), [open3, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open3 + re + close + "$", this.negate && (re = "^(?!" + re + ").+$");
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  slashSplit(p) {
    return this.preserveMultipleSlashes ? p.split("/") : this.isWindows && /^\/\/[^\/]+/.test(p) ? ["", ...p.split(/\/+/)] : p.split(/\/+/);
  }
  match(f, partial = this.partial) {
    if (this.debug("match", f, this.pattern), this.comment)
      return !1;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return !0;
    let options = this.options;
    this.isWindows && (f = f.split("\\").join("/"));
    let ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    let set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename)
      for (let i = ff.length - 2; !filename && i >= 0; i--)
        filename = ff[i];
    for (let i = 0; i < set.length; i++) {
      let pattern = set[i], file = ff;
      if (options.matchBase && pattern.length === 1 && (file = [filename]), this.matchOne(file, pattern, partial))
        return options.flipNegate ? !0 : !this.negate;
    }
    return options.flipNegate ? !1 : this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;

// ../../node_modules/path-scurry/node_modules/lru-cache/dist/mjs/index.js
var perf = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, warned = /* @__PURE__ */ new Set(), PROCESS = typeof process == "object" && process ? process : {}, emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning == "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
}, AC = globalThis.AbortController, AS = globalThis.AbortSignal, _a;
if (typeof AC > "u") {
  AS = class {
    onabort;
    _onabort = [];
    reason;
    aborted = !1;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  }, AC = class {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      var _a2, _b;
      if (!this.signal.aborted) {
        this.signal.reason = reason, this.signal.aborted = !0;
        for (let fn of this.signal._onabort)
          fn(reason);
        (_b = (_a2 = this.signal).onabort) == null || _b.call(_a2, reason);
      }
    }
  };
  let printACPolyfillWarning = ((_a = PROCESS.env) == null ? void 0 : _a.LRU_CACHE_IGNORE_AC_WARNING) !== "1", warnACPolyfill = () => {
    printACPolyfillWarning && (printACPolyfillWarning = !1, emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill));
  };
}
var shouldWarn = (code) => !warned.has(code), TYPE = Symbol("type"), isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n), getUintArray = (max) => isPosInt(max) ? max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null : null, ZeroArray = class extends Array {
  constructor(size) {
    super(size), this.fill(0);
  }
}, Stack = class _Stack {
  heap;
  length;
  // private constructor
  static #constructing = !1;
  static create(max) {
    let HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    _Stack.#constructing = !0;
    let s = new _Stack(max, HeapCls);
    return _Stack.#constructing = !1, s;
  }
  constructor(max, HeapCls) {
    if (!_Stack.#constructing)
      throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new HeapCls(max), this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}, LRUCache = class _LRUCache {
  // properties coming in from the options of these, only max and maxSize
  // really *need* to be protected. The rest can be modified, as they just
  // set defaults for various methods.
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      // methods
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    let { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max))
      throw new TypeError("max option must be a nonnegative integer");
    let UintArray = max ? getUintArray(max) : Array;
    if (!UintArray)
      throw new Error("invalid max value: " + max);
    if (this.#max = max, this.#maxSize = maxSize, this.maxEntrySize = maxEntrySize || this.#maxSize, this.sizeCalculation = sizeCalculation, this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize)
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (fetchMethod !== void 0 && typeof fetchMethod != "function")
      throw new TypeError("fetchMethod must be a function if specified");
    if (this.#fetchMethod = fetchMethod, this.#hasFetchMethod = !!fetchMethod, this.#keyMap = /* @__PURE__ */ new Map(), this.#keyList = new Array(max).fill(void 0), this.#valList = new Array(max).fill(void 0), this.#next = new UintArray(max), this.#prev = new UintArray(max), this.#head = 0, this.#tail = 0, this.#free = Stack.create(max), this.#size = 0, this.#calculatedSize = 0, typeof dispose == "function" && (this.#dispose = dispose), typeof disposeAfter == "function" ? (this.#disposeAfter = disposeAfter, this.#disposed = []) : (this.#disposeAfter = void 0, this.#disposed = void 0), this.#hasDispose = !!this.#dispose, this.#hasDisposeAfter = !!this.#disposeAfter, this.noDisposeOnSet = !!noDisposeOnSet, this.noUpdateTTL = !!noUpdateTTL, this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection, this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection, this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort, this.ignoreFetchAbort = !!ignoreFetchAbort, this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0 && !isPosInt(this.#maxSize))
        throw new TypeError("maxSize must be a positive integer if specified");
      if (!isPosInt(this.maxEntrySize))
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      this.#initializeSizeTracking();
    }
    if (this.allowStale = !!allowStale, this.noDeleteOnStaleGet = !!noDeleteOnStaleGet, this.updateAgeOnGet = !!updateAgeOnGet, this.updateAgeOnHas = !!updateAgeOnHas, this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1, this.ttlAutopurge = !!ttlAutopurge, this.ttl = ttl || 0, this.ttl) {
      if (!isPosInt(this.ttl))
        throw new TypeError("ttl must be a positive integer if specified");
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0)
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      let code = "LRU_CACHE_UNBOUNDED";
      shouldWarn(code) && (warned.add(code), emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", code, _LRUCache));
    }
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? 1 / 0 : 0;
  }
  #initializeTTLTracking() {
    let ttls = new ZeroArray(this.#max), starts = new ZeroArray(this.#max);
    this.#ttls = ttls, this.#starts = starts, this.#setItemTTL = (index, ttl, start = perf.now()) => {
      if (starts[index] = ttl !== 0 ? start : 0, ttls[index] = ttl, ttl !== 0 && this.ttlAutopurge) {
        let t = setTimeout(() => {
          this.#isStale(index) && this.delete(this.#keyList[index]);
        }, ttl + 1);
        t.unref && t.unref();
      }
    }, this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    }, this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        let ttl = ttls[index], start = starts[index];
        status.ttl = ttl, status.start = start, status.now = cachedNow || getNow();
        let age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0, getNow = () => {
      let n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        let t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        t.unref && t.unref();
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      let index = this.#keyMap.get(key);
      if (index === void 0)
        return 0;
      let ttl = ttls[index], start = starts[index];
      if (ttl === 0 || start === 0)
        return 1 / 0;
      let age = (cachedNow || getNow()) - start;
      return ttl - age;
    }, this.#isStale = (index) => ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => !1;
  #initializeSizeTracking() {
    let sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0, this.#sizes = sizes, this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index], sizes[index] = 0;
    }, this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v))
        return 0;
      if (!isPosInt(size))
        if (sizeCalculation) {
          if (typeof sizeCalculation != "function")
            throw new TypeError("sizeCalculation must be a function");
          if (size = sizeCalculation(v, k), !isPosInt(size))
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        } else
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      return size;
    }, this.#addItemSize = (index, size, status) => {
      if (sizes[index] = size, this.#maxSize) {
        let maxSize = this.#maxSize - sizes[index];
        for (; this.#calculatedSize > maxSize; )
          this.#evict(!0);
      }
      this.#calculatedSize += sizes[index], status && (status.entrySize = size, status.totalCalculatedSize = this.#calculatedSize);
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation)
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size)
      for (let i = this.#tail; !(!this.#isValidIndex(i) || ((allowStale || !this.#isStale(i)) && (yield i), i === this.#head)); )
        i = this.#prev[i];
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size)
      for (let i = this.#head; !(!this.#isValidIndex(i) || ((allowStale || !this.#isStale(i)) && (yield i), i === this.#tail)); )
        i = this.#next[i];
  }
  #isValidIndex(index) {
    return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (let i of this.#indexes())
      this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i]) && (yield [this.#keyList[i], this.#valList[i]]);
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (let i of this.#rindexes())
      this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i]) && (yield [this.#keyList[i], this.#valList[i]]);
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (let i of this.#indexes()) {
      let k = this.#keyList[i];
      k !== void 0 && !this.#isBackgroundFetch(this.#valList[i]) && (yield k);
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (let i of this.#rindexes()) {
      let k = this.#keyList[i];
      k !== void 0 && !this.#isBackgroundFetch(this.#valList[i]) && (yield k);
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (let i of this.#indexes())
      this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i]) && (yield this.#valList[i]);
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (let i of this.#rindexes())
      this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i]) && (yield this.#valList[i]);
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(fn, getOptions = {}) {
    for (let i of this.#indexes()) {
      let v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value !== void 0 && fn(value, this.#keyList[i], this))
        return this.get(this.#keyList[i], getOptions);
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (let i of this.#indexes()) {
      let v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      value !== void 0 && fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (let i of this.#rindexes()) {
      let v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      value !== void 0 && fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = !1;
    for (let i of this.#rindexes({ allowStale: !0 }))
      this.#isStale(i) && (this.delete(this.#keyList[i]), deleted = !0);
    return deleted;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    let arr = [];
    for (let i of this.#indexes({ allowStale: !0 })) {
      let key = this.#keyList[i], v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      let entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        let age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      this.#sizes && (entry.size = this.#sizes[i]), arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(arr) {
    this.clear();
    for (let [key, entry] of arr) {
      if (entry.start) {
        let age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   */
  set(k, v, setOptions = {}) {
    var _a2, _b, _c, _d, _e;
    if (v === void 0)
      return this.delete(k), this;
    let { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions, { noUpdateTTL = this.noUpdateTTL } = setOptions, size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize)
      return status && (status.set = "miss", status.maxEntrySizeExceeded = !0), this.delete(k), this;
    let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
    if (index === void 0)
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(!1) : this.#size, this.#keyList[index] = k, this.#valList[index] = v, this.#keyMap.set(k, index), this.#next[this.#tail] = index, this.#prev[index] = this.#tail, this.#tail = index, this.#size++, this.#addItemSize(index, size, status), status && (status.set = "add"), noUpdateTTL = !1;
    else {
      this.#moveToTail(index);
      let oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          let { __staleWhileFetching: s } = oldVal;
          s !== void 0 && !noDisposeOnSet && (this.#hasDispose && ((_a2 = this.#dispose) == null || _a2.call(this, s, k, "set")), this.#hasDisposeAfter && ((_b = this.#disposed) == null || _b.push([s, k, "set"])));
        } else
          noDisposeOnSet || (this.#hasDispose && ((_c = this.#dispose) == null || _c.call(this, oldVal, k, "set")), this.#hasDisposeAfter && ((_d = this.#disposed) == null || _d.push([oldVal, k, "set"])));
        if (this.#removeItemSize(index), this.#addItemSize(index, size, status), this.#valList[index] = v, status) {
          status.set = "replace";
          let oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          oldValue !== void 0 && (status.oldValue = oldValue);
        }
      } else
        status && (status.set = "update");
    }
    if (ttl !== 0 && !this.#ttls && this.#initializeTTLTracking(), this.#ttls && (noUpdateTTL || this.#setItemTTL(index, ttl, start), status && this.#statusTTL(status, index)), !noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      let dt = this.#disposed, task;
      for (; task = dt == null ? void 0 : dt.shift(); )
        (_e = this.#disposeAfter) == null || _e.call(this, ...task);
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var _a2;
    try {
      for (; this.#size; ) {
        let val = this.#valList[this.#head];
        if (this.#evict(!0), this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching)
            return val.__staleWhileFetching;
        } else if (val !== void 0)
          return val;
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        let dt = this.#disposed, task;
        for (; task = dt == null ? void 0 : dt.shift(); )
          (_a2 = this.#disposeAfter) == null || _a2.call(this, ...task);
      }
    }
  }
  #evict(free) {
    var _a2, _b;
    let head = this.#head, k = this.#keyList[head], v = this.#valList[head];
    return this.#hasFetchMethod && this.#isBackgroundFetch(v) ? v.__abortController.abort(new Error("evicted")) : (this.#hasDispose || this.#hasDisposeAfter) && (this.#hasDispose && ((_a2 = this.#dispose) == null || _a2.call(this, v, k, "evict")), this.#hasDisposeAfter && ((_b = this.#disposed) == null || _b.push([v, k, "evict"]))), this.#removeItemSize(head), free && (this.#keyList[head] = void 0, this.#valList[head] = void 0, this.#free.push(head)), this.#size === 1 ? (this.#head = this.#tail = 0, this.#free.length = 0) : this.#head = this.#next[head], this.#keyMap.delete(k), this.#size--, head;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    let { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions, index = this.#keyMap.get(k);
    if (index !== void 0) {
      let v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0)
        return !1;
      if (this.#isStale(index))
        status && (status.has = "stale", this.#statusTTL(status, index));
      else
        return updateAgeOnHas && this.#updateItemAge(index), status && (status.has = "hit", this.#statusTTL(status, index)), !0;
    } else
      status && (status.has = "miss");
    return !1;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    let { allowStale = this.allowStale } = peekOptions, index = this.#keyMap.get(k);
    if (index !== void 0 && (allowStale || !this.#isStale(index))) {
      let v = this.#valList[index];
      return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
  }
  #backgroundFetch(k, index, options, context) {
    let v = index === void 0 ? void 0 : this.#valList[index];
    if (this.#isBackgroundFetch(v))
      return v;
    let ac = new AC(), { signal } = options;
    signal == null || signal.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    let fetchOpts = {
      signal: ac.signal,
      options,
      context
    }, cb = (v2, updateCache = !1) => {
      let { aborted } = ac.signal, ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
      if (options.status && (aborted && !updateCache ? (options.status.fetchAborted = !0, options.status.fetchError = ac.signal.reason, ignoreAbort && (options.status.fetchAbortIgnored = !0)) : options.status.fetchResolved = !0), aborted && !ignoreAbort && !updateCache)
        return fetchFail(ac.signal.reason);
      let bf2 = p;
      return this.#valList[index] === p && (v2 === void 0 ? bf2.__staleWhileFetching ? this.#valList[index] = bf2.__staleWhileFetching : this.delete(k) : (options.status && (options.status.fetchUpdated = !0), this.set(k, v2, fetchOpts.options))), v2;
    }, eb = (er) => (options.status && (options.status.fetchRejected = !0, options.status.fetchError = er), fetchFail(er)), fetchFail = (er) => {
      let { aborted } = ac.signal, allowStaleAborted = aborted && options.allowStaleOnFetchAbort, allowStale = allowStaleAborted || options.allowStaleOnFetchRejection, noDelete = allowStale || options.noDeleteOnFetchRejection, bf2 = p;
      if (this.#valList[index] === p && (!noDelete || bf2.__staleWhileFetching === void 0 ? this.delete(k) : allowStaleAborted || (this.#valList[index] = bf2.__staleWhileFetching)), allowStale)
        return options.status && bf2.__staleWhileFetching !== void 0 && (options.status.returnedStale = !0), bf2.__staleWhileFetching;
      if (bf2.__returned === bf2)
        throw er;
    }, pcall = (res, rej) => {
      var _a2;
      let fmp = (_a2 = this.#fetchMethod) == null ? void 0 : _a2.call(this, k, v, fetchOpts);
      fmp && fmp instanceof Promise && fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej), ac.signal.addEventListener("abort", () => {
        (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) && (res(void 0), options.allowStaleOnFetchAbort && (res = (v2) => cb(v2, !0)));
      });
    };
    options.status && (options.status.fetchDispatched = !0);
    let p = new Promise(pcall).then(cb, eb), bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: void 0
    });
    return index === void 0 ? (this.set(k, bf, { ...fetchOpts.options, status: void 0 }), index = this.#keyMap.get(k)) : this.#valList[index] = bf, bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return !1;
    let b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    let {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = !1,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod)
      return status && (status.fetch = "get"), this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    let options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    }, index = this.#keyMap.get(k);
    if (index === void 0) {
      status && (status.fetch = "miss");
      let p = this.#backgroundFetch(k, index, options, context);
      return p.__returned = p;
    } else {
      let v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        let stale = allowStale && v.__staleWhileFetching !== void 0;
        return status && (status.fetch = "inflight", stale && (status.returnedStale = !0)), stale ? v.__staleWhileFetching : v.__returned = v;
      }
      let isStale = this.#isStale(index);
      if (!forceRefresh && !isStale)
        return status && (status.fetch = "hit"), this.#moveToTail(index), updateAgeOnGet && this.#updateItemAge(index), status && this.#statusTTL(status, index), v;
      let p = this.#backgroundFetch(k, index, options, context), staleVal = p.__staleWhileFetching !== void 0 && allowStale;
      return status && (status.fetch = isStale ? "stale" : "refresh", staleVal && isStale && (status.returnedStale = !0)), staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    let { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions, index = this.#keyMap.get(k);
    if (index !== void 0) {
      let value = this.#valList[index], fetching = this.#isBackgroundFetch(value);
      return status && this.#statusTTL(status, index), this.#isStale(index) ? (status && (status.get = "stale"), fetching ? (status && allowStale && value.__staleWhileFetching !== void 0 && (status.returnedStale = !0), allowStale ? value.__staleWhileFetching : void 0) : (noDeleteOnStaleGet || this.delete(k), status && allowStale && (status.returnedStale = !0), allowStale ? value : void 0)) : (status && (status.get = "hit"), fetching ? value.__staleWhileFetching : (this.#moveToTail(index), updateAgeOnGet && this.#updateItemAge(index), value));
    } else
      status && (status.get = "miss");
  }
  #connect(p, n) {
    this.#prev[n] = p, this.#next[p] = n;
  }
  #moveToTail(index) {
    index !== this.#tail && (index === this.#head ? this.#head = this.#next[index] : this.#connect(this.#prev[index], this.#next[index]), this.#connect(this.#tail, index), this.#tail = index);
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    var _a2, _b, _c, _d;
    let deleted = !1;
    if (this.#size !== 0) {
      let index = this.#keyMap.get(k);
      if (index !== void 0)
        if (deleted = !0, this.#size === 1)
          this.clear();
        else {
          this.#removeItemSize(index);
          let v = this.#valList[index];
          this.#isBackgroundFetch(v) ? v.__abortController.abort(new Error("deleted")) : (this.#hasDispose || this.#hasDisposeAfter) && (this.#hasDispose && ((_a2 = this.#dispose) == null || _a2.call(this, v, k, "delete")), this.#hasDisposeAfter && ((_b = this.#disposed) == null || _b.push([v, k, "delete"]))), this.#keyMap.delete(k), this.#keyList[index] = void 0, this.#valList[index] = void 0, index === this.#tail ? this.#tail = this.#prev[index] : index === this.#head ? this.#head = this.#next[index] : (this.#next[this.#prev[index]] = this.#next[index], this.#prev[this.#next[index]] = this.#prev[index]), this.#size--, this.#free.push(index);
        }
    }
    if (this.#hasDisposeAfter && ((_c = this.#disposed) != null && _c.length)) {
      let dt = this.#disposed, task;
      for (; task = dt == null ? void 0 : dt.shift(); )
        (_d = this.#disposeAfter) == null || _d.call(this, ...task);
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    var _a2, _b, _c;
    for (let index of this.#rindexes({ allowStale: !0 })) {
      let v = this.#valList[index];
      if (this.#isBackgroundFetch(v))
        v.__abortController.abort(new Error("deleted"));
      else {
        let k = this.#keyList[index];
        this.#hasDispose && ((_a2 = this.#dispose) == null || _a2.call(this, v, k, "delete")), this.#hasDisposeAfter && ((_b = this.#disposed) == null || _b.push([v, k, "delete"]));
      }
    }
    if (this.#keyMap.clear(), this.#valList.fill(void 0), this.#keyList.fill(void 0), this.#ttls && this.#starts && (this.#ttls.fill(0), this.#starts.fill(0)), this.#sizes && this.#sizes.fill(0), this.#head = 0, this.#tail = 0, this.#free.length = 0, this.#calculatedSize = 0, this.#size = 0, this.#hasDisposeAfter && this.#disposed) {
      let dt = this.#disposed, task;
      for (; task = dt == null ? void 0 : dt.shift(); )
        (_c = this.#disposeAfter) == null || _c.call(this, ...task);
    }
  }
};

// ../../node_modules/path-scurry/dist/mjs/index.js
var import_path3 = require("path"), import_url = require("url"), actualFS = __toESM(require("fs"), 1), import_fs2 = require("fs"), import_promises = require("fs/promises");

// ../../node_modules/path-scurry/node_modules/minipass/dist/mjs/index.js
var import_events = require("events"), import_stream = __toESM(require("stream"), 1), import_string_decoder = require("string_decoder"), proc = typeof process == "object" && process ? process : {
  stdout: null,
  stderr: null
}, isStream = (s) => !!s && typeof s == "object" && (s instanceof Minipass || s instanceof import_stream.default || isReadable(s) || isWritable(s)), isReadable = (s) => !!s && typeof s == "object" && s instanceof import_events.EventEmitter && typeof s.pipe == "function" && // node core Writable streams have a pipe() method, but it throws
s.pipe !== import_stream.default.Writable.prototype.pipe, isWritable = (s) => !!s && typeof s == "object" && s instanceof import_events.EventEmitter && typeof s.write == "function" && typeof s.end == "function", EOF = Symbol("EOF"), MAYBE_EMIT_END = Symbol("maybeEmitEnd"), EMITTED_END = Symbol("emittedEnd"), EMITTING_END = Symbol("emittingEnd"), EMITTED_ERROR = Symbol("emittedError"), CLOSED = Symbol("closed"), READ = Symbol("read"), FLUSH = Symbol("flush"), FLUSHCHUNK = Symbol("flushChunk"), ENCODING = Symbol("encoding"), DECODER = Symbol("decoder"), FLOWING = Symbol("flowing"), PAUSED = Symbol("paused"), RESUME = Symbol("resume"), BUFFER = Symbol("buffer"), PIPES = Symbol("pipes"), BUFFERLENGTH = Symbol("bufferLength"), BUFFERPUSH = Symbol("bufferPush"), BUFFERSHIFT = Symbol("bufferShift"), OBJECTMODE = Symbol("objectMode"), DESTROYED = Symbol("destroyed"), ERROR = Symbol("error"), EMITDATA = Symbol("emitData"), EMITEND = Symbol("emitEnd"), EMITEND2 = Symbol("emitEnd2"), ASYNC = Symbol("async"), ABORT = Symbol("abort"), ABORTED = Symbol("aborted"), SIGNAL = Symbol("signal"), DATALISTENERS = Symbol("dataListeners"), DISCARDED = Symbol("discarded"), defer = (fn) => Promise.resolve().then(fn), nodefer = (fn) => fn(), isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish", isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b == "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0, isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b), Pipe = class {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src, this.dest = dest, this.opts = opts, this.ondrain = () => src[RESUME](), this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // only here for the prototype
  /* c8 ignore start */
  proxyErrors(_er) {
  }
  /* c8 ignore stop */
  end() {
    this.unpipe(), this.opts.end && this.dest.end();
  }
}, PipeProxyErrors = class extends Pipe {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors), super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts), this.proxyErrors = (er) => dest.emit("error", er), src.on("error", this.proxyErrors);
  }
}, isObjectModeOptions = (o) => !!o.objectMode, isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer", Minipass = class extends import_events.EventEmitter {
  [FLOWING] = !1;
  [PAUSED] = !1;
  [PIPES] = [];
  [BUFFER] = [];
  [OBJECTMODE];
  [ENCODING];
  [ASYNC];
  [DECODER];
  [EOF] = !1;
  [EMITTED_END] = !1;
  [EMITTING_END] = !1;
  [CLOSED] = !1;
  [EMITTED_ERROR] = null;
  [BUFFERLENGTH] = 0;
  [DESTROYED] = !1;
  [SIGNAL];
  [ABORTED] = !1;
  [DATALISTENERS] = 0;
  [DISCARDED] = !1;
  /**
   * true if the stream can be written
   */
  writable = !0;
  /**
   * true if the stream can be read
   */
  readable = !0;
  /**
   * If `RType` is Buffer, then options do not need to be provided.
   * Otherwise, an options object must be provided to specify either
   * {@link Minipass.SharedOptions.objectMode} or
   * {@link Minipass.SharedOptions.encoding}, as appropriate.
   */
  constructor(...args) {
    let options = args[0] || {};
    if (super(), options.objectMode && typeof options.encoding == "string")
      throw new TypeError("Encoding and objectMode may not be used together");
    isObjectModeOptions(options) ? (this[OBJECTMODE] = !0, this[ENCODING] = null) : isEncodingOptions(options) ? (this[ENCODING] = options.encoding, this[OBJECTMODE] = !1) : (this[OBJECTMODE] = !1, this[ENCODING] = null), this[ASYNC] = !!options.async, this[DECODER] = this[ENCODING] ? new import_string_decoder.StringDecoder(this[ENCODING]) : null, options && options.debugExposeBuffer === !0 && Object.defineProperty(this, "buffer", { get: () => this[BUFFER] }), options && options.debugExposePipes === !0 && Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
    let { signal } = options;
    signal && (this[SIGNAL] = signal, signal.aborted ? this[ABORT]() : signal.addEventListener("abort", () => this[ABORT]()));
  }
  /**
   * The amount of data stored in the buffer waiting to be read.
   *
   * For Buffer strings, this will be the total byte length.
   * For string encoding streams, this will be the string character length,
   * according to JavaScript's `string.length` logic.
   * For objectMode streams, this is a count of the items waiting to be
   * emitted.
   */
  get bufferLength() {
    return this[BUFFERLENGTH];
  }
  /**
   * The `BufferEncoding` currently in use, or `null`
   */
  get encoding() {
    return this[ENCODING];
  }
  /**
   * @deprecated - This is a read only property
   */
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * @deprecated - Encoding may only be set at instantiation time
   */
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * True if this is an objectMode stream
   */
  get objectMode() {
    return this[OBJECTMODE];
  }
  /**
   * @deprecated - This is a read-only property
   */
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  /**
   * true if this is an async stream
   */
  get async() {
    return this[ASYNC];
  }
  /**
   * Set to true to make this stream async.
   *
   * Once set, it cannot be unset, as this would potentially cause incorrect
   * behavior.  Ie, a sync stream can be made async, but an async stream
   * cannot be safely made sync.
   */
  set async(a) {
    this[ASYNC] = this[ASYNC] || !!a;
  }
  // drop everything and get out of the flow completely
  [ABORT]() {
    var _a2, _b;
    this[ABORTED] = !0, this.emit("abort", (_a2 = this[SIGNAL]) == null ? void 0 : _a2.reason), this.destroy((_b = this[SIGNAL]) == null ? void 0 : _b.reason);
  }
  /**
   * True if the stream has been aborted.
   */
  get aborted() {
    return this[ABORTED];
  }
  /**
   * No-op setter. Stream aborted status is set via the AbortSignal provided
   * in the constructor options.
   */
  set aborted(_) {
  }
  write(chunk, encoding, cb) {
    var _a2;
    if (this[ABORTED])
      return !1;
    if (this[EOF])
      throw new Error("write after end");
    if (this[DESTROYED])
      return this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" })), !0;
    typeof encoding == "function" && (cb = encoding, encoding = "utf8"), encoding || (encoding = "utf8");
    let fn = this[ASYNC] ? defer : nodefer;
    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      else if (isArrayBufferLike(chunk))
        chunk = Buffer.from(chunk);
      else if (typeof chunk != "string")
        throw new Error("Non-contiguous data written to non-objectMode stream");
    }
    return this[OBJECTMODE] ? (this[FLOWING] && this[BUFFERLENGTH] !== 0 && this[FLUSH](!0), this[FLOWING] ? this.emit("data", chunk) : this[BUFFERPUSH](chunk), this[BUFFERLENGTH] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING]) : chunk.length ? (typeof chunk == "string" && // unless it is a string already ready for us to use
    !(encoding === this[ENCODING] && !((_a2 = this[DECODER]) != null && _a2.lastNeed)) && (chunk = Buffer.from(chunk, encoding)), Buffer.isBuffer(chunk) && this[ENCODING] && (chunk = this[DECODER].write(chunk)), this[FLOWING] && this[BUFFERLENGTH] !== 0 && this[FLUSH](!0), this[FLOWING] ? this.emit("data", chunk) : this[BUFFERPUSH](chunk), this[BUFFERLENGTH] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING]) : (this[BUFFERLENGTH] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING]);
  }
  /**
   * Low-level explicit read method.
   *
   * In objectMode, the argument is ignored, and one item is returned if
   * available.
   *
   * `n` is the number of bytes (or in the case of encoding streams,
   * characters) to consume. If `n` is not provided, then the entire buffer
   * is returned, or `null` is returned if no data is available.
   *
   * If `n` is greater that the amount of data in the internal buffer,
   * then `null` is returned.
   */
  read(n) {
    if (this[DESTROYED])
      return null;
    if (this[DISCARDED] = !1, this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH])
      return this[MAYBE_EMIT_END](), null;
    this[OBJECTMODE] && (n = null), this[BUFFER].length > 1 && !this[OBJECTMODE] && (this[BUFFER] = [
      this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
    ]);
    let ret = this[READ](n || null, this[BUFFER][0]);
    return this[MAYBE_EMIT_END](), ret;
  }
  [READ](n, chunk) {
    if (this[OBJECTMODE])
      this[BUFFERSHIFT]();
    else {
      let c = chunk;
      n === c.length || n === null ? this[BUFFERSHIFT]() : typeof c == "string" ? (this[BUFFER][0] = c.slice(n), chunk = c.slice(0, n), this[BUFFERLENGTH] -= n) : (this[BUFFER][0] = c.subarray(n), chunk = c.subarray(0, n), this[BUFFERLENGTH] -= n);
    }
    return this.emit("data", chunk), !this[BUFFER].length && !this[EOF] && this.emit("drain"), chunk;
  }
  end(chunk, encoding, cb) {
    return typeof chunk == "function" && (cb = chunk, chunk = void 0), typeof encoding == "function" && (cb = encoding, encoding = "utf8"), chunk !== void 0 && this.write(chunk, encoding), cb && this.once("end", cb), this[EOF] = !0, this.writable = !1, (this[FLOWING] || !this[PAUSED]) && this[MAYBE_EMIT_END](), this;
  }
  // don't let the internal resume be overwritten
  [RESUME]() {
    this[DESTROYED] || (!this[DATALISTENERS] && !this[PIPES].length && (this[DISCARDED] = !0), this[PAUSED] = !1, this[FLOWING] = !0, this.emit("resume"), this[BUFFER].length ? this[FLUSH]() : this[EOF] ? this[MAYBE_EMIT_END]() : this.emit("drain"));
  }
  /**
   * Resume the stream if it is currently in a paused state
   *
   * If called when there are no pipe destinations or `data` event listeners,
   * this will place the stream in a "discarded" state, where all data will
   * be thrown away. The discarded state is removed if a pipe destination or
   * data handler is added, if pause() is called, or if any synchronous or
   * asynchronous iteration is started.
   */
  resume() {
    return this[RESUME]();
  }
  /**
   * Pause the stream
   */
  pause() {
    this[FLOWING] = !1, this[PAUSED] = !0, this[DISCARDED] = !1;
  }
  /**
   * true if the stream has been forcibly destroyed
   */
  get destroyed() {
    return this[DESTROYED];
  }
  /**
   * true if the stream is currently in a flowing state, meaning that
   * any writes will be immediately emitted.
   */
  get flowing() {
    return this[FLOWING];
  }
  /**
   * true if the stream is currently in a paused state
   */
  get paused() {
    return this[PAUSED];
  }
  [BUFFERPUSH](chunk) {
    this[OBJECTMODE] ? this[BUFFERLENGTH] += 1 : this[BUFFERLENGTH] += chunk.length, this[BUFFER].push(chunk);
  }
  [BUFFERSHIFT]() {
    return this[OBJECTMODE] ? this[BUFFERLENGTH] -= 1 : this[BUFFERLENGTH] -= this[BUFFER][0].length, this[BUFFER].shift();
  }
  [FLUSH](noDrain = !1) {
    do
      ;
    while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
    !noDrain && !this[BUFFER].length && !this[EOF] && this.emit("drain");
  }
  [FLUSHCHUNK](chunk) {
    return this.emit("data", chunk), this[FLOWING];
  }
  /**
   * Pipe all data emitted by this stream into the destination provided.
   *
   * Triggers the flow of data.
   */
  pipe(dest, opts) {
    if (this[DESTROYED])
      return dest;
    this[DISCARDED] = !1;
    let ended = this[EMITTED_END];
    return opts = opts || {}, dest === proc.stdout || dest === proc.stderr ? opts.end = !1 : opts.end = opts.end !== !1, opts.proxyErrors = !!opts.proxyErrors, ended ? opts.end && dest.end() : (this[PIPES].push(opts.proxyErrors ? new PipeProxyErrors(this, dest, opts) : new Pipe(this, dest, opts)), this[ASYNC] ? defer(() => this[RESUME]()) : this[RESUME]()), dest;
  }
  /**
   * Fully unhook a piped destination stream.
   *
   * If the destination stream was the only consumer of this stream (ie,
   * there are no other piped destinations or `'data'` event listeners)
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  unpipe(dest) {
    let p = this[PIPES].find((p2) => p2.dest === dest);
    p && (this[PIPES].length === 1 ? (this[FLOWING] && this[DATALISTENERS] === 0 && (this[FLOWING] = !1), this[PIPES] = []) : this[PIPES].splice(this[PIPES].indexOf(p), 1), p.unpipe());
  }
  /**
   * Alias for {@link Minipass#on}
   */
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.on`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * - Adding a 'data' event handler will trigger the flow of data
   *
   * - Adding a 'readable' event handler when there is data waiting to be read
   *   will cause 'readable' to be emitted immediately.
   *
   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
   *   already passed will cause the event to be emitted immediately and all
   *   handlers removed.
   *
   * - Adding an 'error' event handler after an error has been emitted will
   *   cause the event to be re-emitted immediately with the error previously
   *   raised.
   */
  on(ev, handler) {
    let ret = super.on(ev, handler);
    if (ev === "data")
      this[DISCARDED] = !1, this[DATALISTENERS]++, !this[PIPES].length && !this[FLOWING] && this[RESUME]();
    else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
      super.emit("readable");
    else if (isEndish(ev) && this[EMITTED_END])
      super.emit(ev), this.removeAllListeners(ev);
    else if (ev === "error" && this[EMITTED_ERROR]) {
      let h = handler;
      this[ASYNC] ? defer(() => h.call(this, this[EMITTED_ERROR])) : h.call(this, this[EMITTED_ERROR]);
    }
    return ret;
  }
  /**
   * Alias for {@link Minipass#off}
   */
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.off`
   *
   * If a 'data' event handler is removed, and it was the last consumer
   * (ie, there are no pipe destinations or other 'data' event listeners),
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  off(ev, handler) {
    let ret = super.off(ev, handler);
    return ev === "data" && (this[DATALISTENERS] = this.listeners("data").length, this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length && (this[FLOWING] = !1)), ret;
  }
  /**
   * Mostly identical to `EventEmitter.removeAllListeners`
   *
   * If all 'data' event handlers are removed, and they were the last consumer
   * (ie, there are no pipe destinations), then the flow of data will stop
   * until there is another consumer or {@link Minipass#resume} is explicitly
   * called.
   */
  removeAllListeners(ev) {
    let ret = super.removeAllListeners(ev);
    return (ev === "data" || ev === void 0) && (this[DATALISTENERS] = 0, !this[DISCARDED] && !this[PIPES].length && (this[FLOWING] = !1)), ret;
  }
  /**
   * true if the 'end' event has been emitted
   */
  get emittedEnd() {
    return this[EMITTED_END];
  }
  [MAYBE_EMIT_END]() {
    !this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF] && (this[EMITTING_END] = !0, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[CLOSED] && this.emit("close"), this[EMITTING_END] = !1);
  }
  /**
   * Mostly identical to `EventEmitter.emit`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * If the stream has been destroyed, and the event is something other
   * than 'close' or 'error', then `false` is returned and no handlers
   * are called.
   *
   * If the event is 'end', and has already been emitted, then the event
   * is ignored. If the stream is in a paused or non-flowing state, then
   * the event will be deferred until data flow resumes. If the stream is
   * async, then handlers will be called on the next tick rather than
   * immediately.
   *
   * If the event is 'close', and 'end' has not yet been emitted, then
   * the event will be deferred until after 'end' is emitted.
   *
   * If the event is 'error', and an AbortSignal was provided for the stream,
   * and there are no listeners, then the event is ignored, matching the
   * behavior of node core streams in the presense of an AbortSignal.
   *
   * If the event is 'finish' or 'prefinish', then all listeners will be
   * removed after emitting the event, to prevent double-firing.
   */
  emit(ev, ...args) {
    let data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
      return !1;
    if (ev === "data")
      return !this[OBJECTMODE] && !data ? !1 : this[ASYNC] ? (defer(() => this[EMITDATA](data)), !0) : this[EMITDATA](data);
    if (ev === "end")
      return this[EMITEND]();
    if (ev === "close") {
      if (this[CLOSED] = !0, !this[EMITTED_END] && !this[DESTROYED])
        return !1;
      let ret2 = super.emit("close");
      return this.removeAllListeners("close"), ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR] = data, super.emit(ERROR, data);
      let ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : !1;
      return this[MAYBE_EMIT_END](), ret2;
    } else if (ev === "resume") {
      let ret2 = super.emit("resume");
      return this[MAYBE_EMIT_END](), ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      let ret2 = super.emit(ev);
      return this.removeAllListeners(ev), ret2;
    }
    let ret = super.emit(ev, ...args);
    return this[MAYBE_EMIT_END](), ret;
  }
  [EMITDATA](data) {
    for (let p of this[PIPES])
      p.dest.write(data) === !1 && this.pause();
    let ret = this[DISCARDED] ? !1 : super.emit("data", data);
    return this[MAYBE_EMIT_END](), ret;
  }
  [EMITEND]() {
    return this[EMITTED_END] ? !1 : (this[EMITTED_END] = !0, this.readable = !1, this[ASYNC] ? (defer(() => this[EMITEND2]()), !0) : this[EMITEND2]());
  }
  [EMITEND2]() {
    if (this[DECODER]) {
      let data = this[DECODER].end();
      if (data) {
        for (let p of this[PIPES])
          p.dest.write(data);
        this[DISCARDED] || super.emit("data", data);
      }
    }
    for (let p of this[PIPES])
      p.end();
    let ret = super.emit("end");
    return this.removeAllListeners("end"), ret;
  }
  /**
   * Return a Promise that resolves to an array of all emitted data once
   * the stream ends.
   */
  async collect() {
    let buf = Object.assign([], {
      dataLength: 0
    });
    this[OBJECTMODE] || (buf.dataLength = 0);
    let p = this.promise();
    return this.on("data", (c) => {
      buf.push(c), this[OBJECTMODE] || (buf.dataLength += c.length);
    }), await p, buf;
  }
  /**
   * Return a Promise that resolves to the concatenation of all emitted data
   * once the stream ends.
   *
   * Not allowed on objectMode streams.
   */
  async concat() {
    if (this[OBJECTMODE])
      throw new Error("cannot concat in objectMode");
    let buf = await this.collect();
    return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  /**
   * Return a void Promise that resolves once the stream ends.
   */
  async promise() {
    return new Promise((resolve7, reject) => {
      this.on(DESTROYED, () => reject(new Error("stream destroyed"))), this.on("error", (er) => reject(er)), this.on("end", () => resolve7());
    });
  }
  /**
   * Asynchronous `for await of` iteration.
   *
   * This will continue emitting all chunks until the stream terminates.
   */
  [Symbol.asyncIterator]() {
    this[DISCARDED] = !1;
    let stopped = !1, stop = async () => (this.pause(), stopped = !0, { value: void 0, done: !0 });
    return {
      next: () => {
        if (stopped)
          return stop();
        let res = this.read();
        if (res !== null)
          return Promise.resolve({ done: !1, value: res });
        if (this[EOF])
          return stop();
        let resolve7, reject, onerr = (er) => {
          this.off("data", ondata), this.off("end", onend), this.off(DESTROYED, ondestroy), stop(), reject(er);
        }, ondata = (value) => {
          this.off("error", onerr), this.off("end", onend), this.off(DESTROYED, ondestroy), this.pause(), resolve7({ value, done: !!this[EOF] });
        }, onend = () => {
          this.off("error", onerr), this.off("data", ondata), this.off(DESTROYED, ondestroy), stop(), resolve7({ done: !0, value: void 0 });
        }, ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej, resolve7 = res2, this.once(DESTROYED, ondestroy), this.once("error", onerr), this.once("end", onend), this.once("data", ondata);
        });
      },
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  /**
   * Synchronous `for of` iteration.
   *
   * The iteration will terminate when the internal buffer runs out, even
   * if the stream has not yet terminated.
   */
  [Symbol.iterator]() {
    this[DISCARDED] = !1;
    let stopped = !1, stop = () => (this.pause(), this.off(ERROR, stop), this.off(DESTROYED, stop), this.off("end", stop), stopped = !0, { done: !0, value: void 0 }), next = () => {
      if (stopped)
        return stop();
      let value = this.read();
      return value === null ? stop() : { done: !1, value };
    };
    return this.once("end", stop), this.once(ERROR, stop), this.once(DESTROYED, stop), {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  /**
   * Destroy a stream, preventing it from being used for any further purpose.
   *
   * If the stream has a `close()` method, then it will be called on
   * destruction.
   *
   * After destruction, any attempt to write data, read data, or emit most
   * events will be ignored.
   *
   * If an error argument is provided, then it will be emitted in an
   * 'error' event.
   */
  destroy(er) {
    if (this[DESTROYED])
      return er ? this.emit("error", er) : this.emit(DESTROYED), this;
    this[DESTROYED] = !0, this[DISCARDED] = !0, this[BUFFER].length = 0, this[BUFFERLENGTH] = 0;
    let wc = this;
    return typeof wc.close == "function" && !this[CLOSED] && wc.close(), er ? this.emit("error", er) : this.emit(DESTROYED), this;
  }
  /**
   * Alias for {@link isStream}
   *
   * Former export location, maintained for backwards compatibility.
   *
   * @deprecated
   */
  static get isStream() {
    return isStream;
  }
};

// ../../node_modules/path-scurry/dist/mjs/index.js
var realpathSync = import_fs2.realpathSync.native, defaultFS = {
  lstatSync: import_fs2.lstatSync,
  readdir: import_fs2.readdir,
  readdirSync: import_fs2.readdirSync,
  readlinkSync: import_fs2.readlinkSync,
  realpathSync,
  promises: {
    lstat: import_promises.lstat,
    readdir: import_promises.readdir,
    readlink: import_promises.readlink,
    realpath: import_promises.realpath
  }
}, fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
  ...defaultFS,
  ...fsOption,
  promises: {
    ...defaultFS.promises,
    ...fsOption.promises || {}
  }
}, uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i, uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\"), eitherSep = /[\\\/]/, UNKNOWN = 0, IFIFO = 1, IFCHR = 2, IFDIR = 4, IFBLK = 6, IFREG = 8, IFLNK = 10, IFSOCK = 12, IFMT = 15, IFMT_UNKNOWN = ~IFMT, READDIR_CALLED = 16, LSTAT_CALLED = 32, ENOTDIR = 64, ENOENT = 128, ENOREADLINK = 256, ENOREALPATH = 512, ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH, TYPEMASK = 1023, entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN, normalizeCache = /* @__PURE__ */ new Map(), normalize = (s) => {
  let c = normalizeCache.get(s);
  if (c)
    return c;
  let n = s.normalize("NFKD");
  return normalizeCache.set(s, n), n;
}, normalizeNocaseCache = /* @__PURE__ */ new Map(), normalizeNocase = (s) => {
  let c = normalizeNocaseCache.get(s);
  if (c)
    return c;
  let n = normalize(s.toLowerCase());
  return normalizeNocaseCache.set(s, n), n;
}, ResolveCache = class extends LRUCache {
  constructor() {
    super({ max: 256 });
  }
}, ChildrenCache = class extends LRUCache {
  constructor(maxSize = 16 * 1024) {
    super({
      maxSize,
      // parent + children
      sizeCalculation: (a) => a.length + 1
    });
  }
}, setAsCwd = Symbol("PathScurry setAsCwd"), PathBase = class {
  /**
   * the basename of this path
   *
   * **Important**: *always* test the path name against any test string
   * usingthe {@link isNamed} method, and not by directly comparing this
   * string. Otherwise, unicode path strings that the system sees as identical
   * will not be properly treated as the same path, leading to incorrect
   * behavior and possible security issues.
   */
  name;
  /**
   * the Path entry corresponding to the path root.
   *
   * @internal
   */
  root;
  /**
   * All roots found within the current PathScurry family
   *
   * @internal
   */
  roots;
  /**
   * a reference to the parent path, or undefined in the case of root entries
   *
   * @internal
   */
  parent;
  /**
   * boolean indicating whether paths are compared case-insensitively
   * @internal
   */
  nocase;
  // potential default fs override
  #fs;
  // Stats fields
  #dev;
  get dev() {
    return this.#dev;
  }
  #mode;
  get mode() {
    return this.#mode;
  }
  #nlink;
  get nlink() {
    return this.#nlink;
  }
  #uid;
  get uid() {
    return this.#uid;
  }
  #gid;
  get gid() {
    return this.#gid;
  }
  #rdev;
  get rdev() {
    return this.#rdev;
  }
  #blksize;
  get blksize() {
    return this.#blksize;
  }
  #ino;
  get ino() {
    return this.#ino;
  }
  #size;
  get size() {
    return this.#size;
  }
  #blocks;
  get blocks() {
    return this.#blocks;
  }
  #atimeMs;
  get atimeMs() {
    return this.#atimeMs;
  }
  #mtimeMs;
  get mtimeMs() {
    return this.#mtimeMs;
  }
  #ctimeMs;
  get ctimeMs() {
    return this.#ctimeMs;
  }
  #birthtimeMs;
  get birthtimeMs() {
    return this.#birthtimeMs;
  }
  #atime;
  get atime() {
    return this.#atime;
  }
  #mtime;
  get mtime() {
    return this.#mtime;
  }
  #ctime;
  get ctime() {
    return this.#ctime;
  }
  #birthtime;
  get birthtime() {
    return this.#birthtime;
  }
  #matchName;
  #depth;
  #fullpath;
  #fullpathPosix;
  #relative;
  #relativePosix;
  #type;
  #children;
  #linkTarget;
  #realpath;
  /**
   * This property is for compatibility with the Dirent class as of
   * Node v20, where Dirent['path'] refers to the path of the directory
   * that was passed to readdir.  So, somewhat counterintuitively, this
   * property refers to the *parent* path, not the path object itself.
   * For root entries, it's the path to the entry itself.
   */
  get path() {
    return (this.parent || this).fullpath();
  }
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
    this.name = name, this.#matchName = nocase ? normalizeNocase(name) : normalize(name), this.#type = type & TYPEMASK, this.nocase = nocase, this.roots = roots, this.root = root || this, this.#children = children, this.#fullpath = opts.fullpath, this.#relative = opts.relative, this.#relativePosix = opts.relativePosix, this.parent = opts.parent, this.parent ? this.#fs = this.parent.#fs : this.#fs = fsFromOption(opts.fs);
  }
  /**
   * Returns the depth of the Path object from its root.
   *
   * For example, a path at `/foo/bar` would have a depth of 2.
   */
  depth() {
    return this.#depth !== void 0 ? this.#depth : this.parent ? this.#depth = this.parent.depth() + 1 : this.#depth = 0;
  }
  /**
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Get the Path object referenced by the string path, resolved from this Path
   */
  resolve(path6) {
    if (!path6)
      return this;
    let rootPath = this.getRootString(path6), dirParts = path6.substring(rootPath.length).split(this.splitSep);
    return rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
  }
  #resolveParts(dirParts) {
    let p = this;
    for (let part of dirParts)
      p = p.child(part);
    return p;
  }
  /**
   * Returns the cached children Path objects, if still available.  If they
   * have fallen out of the cache, then returns an empty array, and resets the
   * READDIR_CALLED bit, so that future calls to readdir() will require an fs
   * lookup.
   *
   * @internal
   */
  children() {
    let cached = this.#children.get(this);
    if (cached)
      return cached;
    let children = Object.assign([], { provisional: 0 });
    return this.#children.set(this, children), this.#type &= ~READDIR_CALLED, children;
  }
  /**
   * Resolves a path portion and returns or creates the child Path.
   *
   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
   * `'..'`.
   *
   * This should not be called directly.  If `pathPart` contains any path
   * separators, it will lead to unsafe undefined behavior.
   *
   * Use `Path.resolve()` instead.
   *
   * @internal
   */
  child(pathPart, opts) {
    if (pathPart === "" || pathPart === ".")
      return this;
    if (pathPart === "..")
      return this.parent || this;
    let children = this.children(), name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
    for (let p of children)
      if (p.#matchName === name)
        return p;
    let s = this.parent ? this.sep : "", fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0, pchild = this.newChild(pathPart, UNKNOWN, {
      ...opts,
      parent: this,
      fullpath
    });
    return this.canReaddir() || (pchild.#type |= ENOENT), children.push(pchild), pchild;
  }
  /**
   * The relative path from the cwd. If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpath()
   */
  relative() {
    if (this.#relative !== void 0)
      return this.#relative;
    let name = this.name, p = this.parent;
    if (!p)
      return this.#relative = this.name;
    let pv = p.relative();
    return pv + (!pv || !p.parent ? "" : this.sep) + name;
  }
  /**
   * The relative path from the cwd, using / as the path separator.
   * If it does not share an ancestor with
   * the cwd, then this ends up being equivalent to the fullpathPosix()
   * On posix systems, this is identical to relative().
   */
  relativePosix() {
    if (this.sep === "/")
      return this.relative();
    if (this.#relativePosix !== void 0)
      return this.#relativePosix;
    let name = this.name, p = this.parent;
    if (!p)
      return this.#relativePosix = this.fullpathPosix();
    let pv = p.relativePosix();
    return pv + (!pv || !p.parent ? "" : "/") + name;
  }
  /**
   * The fully resolved path string for this Path entry
   */
  fullpath() {
    if (this.#fullpath !== void 0)
      return this.#fullpath;
    let name = this.name, p = this.parent;
    if (!p)
      return this.#fullpath = this.name;
    let fp = p.fullpath() + (p.parent ? this.sep : "") + name;
    return this.#fullpath = fp;
  }
  /**
   * On platforms other than windows, this is identical to fullpath.
   *
   * On windows, this is overridden to return the forward-slash form of the
   * full UNC path.
   */
  fullpathPosix() {
    if (this.#fullpathPosix !== void 0)
      return this.#fullpathPosix;
    if (this.sep === "/")
      return this.#fullpathPosix = this.fullpath();
    if (!this.parent) {
      let p2 = this.fullpath().replace(/\\/g, "/");
      return /^[a-z]:\//i.test(p2) ? this.#fullpathPosix = `//?/${p2}` : this.#fullpathPosix = p2;
    }
    let p = this.parent, pfpp = p.fullpathPosix(), fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
    return this.#fullpathPosix = fpp;
  }
  /**
   * Is the Path of an unknown type?
   *
   * Note that we might know *something* about it if there has been a previous
   * filesystem operation, for example that it does not exist, or is not a
   * link, or whether it has child entries.
   */
  isUnknown() {
    return (this.#type & IFMT) === UNKNOWN;
  }
  isType(type) {
    return this[`is${type}`]();
  }
  getType() {
    return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
      /* c8 ignore start */
      this.isSocket() ? "Socket" : "Unknown"
    );
  }
  /**
   * Is the Path a regular file?
   */
  isFile() {
    return (this.#type & IFMT) === IFREG;
  }
  /**
   * Is the Path a directory?
   */
  isDirectory() {
    return (this.#type & IFMT) === IFDIR;
  }
  /**
   * Is the path a character device?
   */
  isCharacterDevice() {
    return (this.#type & IFMT) === IFCHR;
  }
  /**
   * Is the path a block device?
   */
  isBlockDevice() {
    return (this.#type & IFMT) === IFBLK;
  }
  /**
   * Is the path a FIFO pipe?
   */
  isFIFO() {
    return (this.#type & IFMT) === IFIFO;
  }
  /**
   * Is the path a socket?
   */
  isSocket() {
    return (this.#type & IFMT) === IFSOCK;
  }
  /**
   * Is the path a symbolic link?
   */
  isSymbolicLink() {
    return (this.#type & IFLNK) === IFLNK;
  }
  /**
   * Return the entry if it has been subject of a successful lstat, or
   * undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* simply
   * mean that we haven't called lstat on it.
   */
  lstatCached() {
    return this.#type & LSTAT_CALLED ? this : void 0;
  }
  /**
   * Return the cached link target if the entry has been the subject of a
   * successful readlink, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readlink() has been called at some point.
   */
  readlinkCached() {
    return this.#linkTarget;
  }
  /**
   * Returns the cached realpath target if the entry has been the subject
   * of a successful realpath, or undefined otherwise.
   *
   * Does not read the filesystem, so an undefined result *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * realpath() has been called at some point.
   */
  realpathCached() {
    return this.#realpath;
  }
  /**
   * Returns the cached child Path entries array if the entry has been the
   * subject of a successful readdir(), or [] otherwise.
   *
   * Does not read the filesystem, so an empty array *could* just mean we
   * don't have any cached data. Only use it if you are very sure that a
   * readdir() has been called recently enough to still be valid.
   */
  readdirCached() {
    let children = this.children();
    return children.slice(0, children.provisional);
  }
  /**
   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
   * any indication that readlink will definitely fail.
   *
   * Returns false if the path is known to not be a symlink, if a previous
   * readlink failed, or if the entry does not exist.
   */
  canReadlink() {
    if (this.#linkTarget)
      return !0;
    if (!this.parent)
      return !1;
    let ifmt = this.#type & IFMT;
    return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
  }
  /**
   * Return true if readdir has previously been successfully called on this
   * path, indicating that cachedReaddir() is likely valid.
   */
  calledReaddir() {
    return !!(this.#type & READDIR_CALLED);
  }
  /**
   * Returns true if the path is known to not exist. That is, a previous lstat
   * or readdir failed to verify its existence when that would have been
   * expected, or a parent entry was marked either enoent or enotdir.
   */
  isENOENT() {
    return !!(this.#type & ENOENT);
  }
  /**
   * Return true if the path is a match for the given path name.  This handles
   * case sensitivity and unicode normalization.
   *
   * Note: even on case-sensitive systems, it is **not** safe to test the
   * equality of the `.name` property to determine whether a given pathname
   * matches, due to unicode normalization mismatches.
   *
   * Always use this method instead of testing the `path.name` property
   * directly.
   */
  isNamed(n) {
    return this.nocase ? this.#matchName === normalizeNocase(n) : this.#matchName === normalize(n);
  }
  /**
   * Return the Path object corresponding to the target of a symbolic link.
   *
   * If the Path is not a symbolic link, or if the readlink call fails for any
   * reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   */
  async readlink() {
    let target = this.#linkTarget;
    if (target)
      return target;
    if (this.canReadlink() && this.parent)
      try {
        let read = await this.#fs.promises.readlink(this.fullpath()), linkTarget = this.parent.resolve(read);
        if (linkTarget)
          return this.#linkTarget = linkTarget;
      } catch (er) {
        this.#readlinkFail(er.code);
        return;
      }
  }
  /**
   * Synchronous {@link PathBase.readlink}
   */
  readlinkSync() {
    let target = this.#linkTarget;
    if (target)
      return target;
    if (this.canReadlink() && this.parent)
      try {
        let read = this.#fs.readlinkSync(this.fullpath()), linkTarget = this.parent.resolve(read);
        if (linkTarget)
          return this.#linkTarget = linkTarget;
      } catch (er) {
        this.#readlinkFail(er.code);
        return;
      }
  }
  #readdirSuccess(children) {
    this.#type |= READDIR_CALLED;
    for (let p = children.provisional; p < children.length; p++)
      children[p].#markENOENT();
  }
  #markENOENT() {
    this.#type & ENOENT || (this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN, this.#markChildrenENOENT());
  }
  #markChildrenENOENT() {
    let children = this.children();
    children.provisional = 0;
    for (let p of children)
      p.#markENOENT();
  }
  #markENOREALPATH() {
    this.#type |= ENOREALPATH, this.#markENOTDIR();
  }
  // save the information when we know the entry is not a dir
  #markENOTDIR() {
    if (this.#type & ENOTDIR)
      return;
    let t = this.#type;
    (t & IFMT) === IFDIR && (t &= IFMT_UNKNOWN), this.#type = t | ENOTDIR, this.#markChildrenENOENT();
  }
  #readdirFail(code = "") {
    code === "ENOTDIR" || code === "EPERM" ? this.#markENOTDIR() : code === "ENOENT" ? this.#markENOENT() : this.children().provisional = 0;
  }
  #lstatFail(code = "") {
    code === "ENOTDIR" ? this.parent.#markENOTDIR() : code === "ENOENT" && this.#markENOENT();
  }
  #readlinkFail(code = "") {
    let ter = this.#type;
    ter |= ENOREADLINK, code === "ENOENT" && (ter |= ENOENT), (code === "EINVAL" || code === "UNKNOWN") && (ter &= IFMT_UNKNOWN), this.#type = ter, code === "ENOTDIR" && this.parent && this.parent.#markENOTDIR();
  }
  #readdirAddChild(e, c) {
    return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
  }
  #readdirAddNewChild(e, c) {
    let type = entToType(e), child = this.newChild(e.name, type, { parent: this }), ifmt = child.#type & IFMT;
    return ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN && (child.#type |= ENOTDIR), c.unshift(child), c.provisional++, child;
  }
  #readdirMaybePromoteChild(e, c) {
    for (let p = c.provisional; p < c.length; p++) {
      let pchild = c[p];
      if ((this.nocase ? normalizeNocase(e.name) : normalize(e.name)) === pchild.#matchName)
        return this.#readdirPromoteChild(e, pchild, p, c);
    }
  }
  #readdirPromoteChild(e, p, index, c) {
    let v = p.name;
    return p.#type = p.#type & IFMT_UNKNOWN | entToType(e), v !== e.name && (p.name = e.name), index !== c.provisional && (index === c.length - 1 ? c.pop() : c.splice(index, 1), c.unshift(p)), c.provisional++, p;
  }
  /**
   * Call lstat() on this Path, and update all known information that can be
   * determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat() {
    if (!(this.#type & ENOENT))
      try {
        return this.#applyStat(await this.#fs.promises.lstat(this.fullpath())), this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
  }
  /**
   * synchronous {@link PathBase.lstat}
   */
  lstatSync() {
    if (!(this.#type & ENOENT))
      try {
        return this.#applyStat(this.#fs.lstatSync(this.fullpath())), this;
      } catch (er) {
        this.#lstatFail(er.code);
      }
  }
  #applyStat(st) {
    let { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
    this.#atime = atime, this.#atimeMs = atimeMs, this.#birthtime = birthtime, this.#birthtimeMs = birthtimeMs, this.#blksize = blksize, this.#blocks = blocks, this.#ctime = ctime, this.#ctimeMs = ctimeMs, this.#dev = dev, this.#gid = gid, this.#ino = ino, this.#mode = mode, this.#mtime = mtime, this.#mtimeMs = mtimeMs, this.#nlink = nlink, this.#rdev = rdev, this.#size = size, this.#uid = uid;
    let ifmt = entToType(st);
    this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED, ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK && (this.#type |= ENOTDIR);
  }
  #onReaddirCB = [];
  #readdirCBInFlight = !1;
  #callOnReaddirCB(children) {
    this.#readdirCBInFlight = !1;
    let cbs = this.#onReaddirCB.slice();
    this.#onReaddirCB.length = 0, cbs.forEach((cb) => cb(null, children));
  }
  /**
   * Standard node-style callback interface to get list of directory entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   *
   * @param cb The callback called with (er, entries).  Note that the `er`
   * param is somewhat extraneous, as all readdir() errors are handled and
   * simply result in an empty set of entries being returned.
   * @param allowZalgo Boolean indicating that immediately known results should
   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
   * zalgo at your peril, the dark pony lord is devious and unforgiving.
   */
  readdirCB(cb, allowZalgo = !1) {
    if (!this.canReaddir()) {
      allowZalgo ? cb(null, []) : queueMicrotask(() => cb(null, []));
      return;
    }
    let children = this.children();
    if (this.calledReaddir()) {
      let c = children.slice(0, children.provisional);
      allowZalgo ? cb(null, c) : queueMicrotask(() => cb(null, c));
      return;
    }
    if (this.#onReaddirCB.push(cb), this.#readdirCBInFlight)
      return;
    this.#readdirCBInFlight = !0;
    let fullpath = this.fullpath();
    this.#fs.readdir(fullpath, { withFileTypes: !0 }, (er, entries) => {
      if (er)
        this.#readdirFail(er.code), children.provisional = 0;
      else {
        for (let e of entries)
          this.#readdirAddChild(e, children);
        this.#readdirSuccess(children);
      }
      this.#callOnReaddirCB(children.slice(0, children.provisional));
    });
  }
  #asyncReaddirInFlight;
  /**
   * Return an array of known child entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async readdir() {
    if (!this.canReaddir())
      return [];
    let children = this.children();
    if (this.calledReaddir())
      return children.slice(0, children.provisional);
    let fullpath = this.fullpath();
    if (this.#asyncReaddirInFlight)
      await this.#asyncReaddirInFlight;
    else {
      let resolve7 = () => {
      };
      this.#asyncReaddirInFlight = new Promise((res) => resolve7 = res);
      try {
        for (let e of await this.#fs.promises.readdir(fullpath, {
          withFileTypes: !0
        }))
          this.#readdirAddChild(e, children);
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code), children.provisional = 0;
      }
      this.#asyncReaddirInFlight = void 0, resolve7();
    }
    return children.slice(0, children.provisional);
  }
  /**
   * synchronous {@link PathBase.readdir}
   */
  readdirSync() {
    if (!this.canReaddir())
      return [];
    let children = this.children();
    if (this.calledReaddir())
      return children.slice(0, children.provisional);
    let fullpath = this.fullpath();
    try {
      for (let e of this.#fs.readdirSync(fullpath, {
        withFileTypes: !0
      }))
        this.#readdirAddChild(e, children);
      this.#readdirSuccess(children);
    } catch (er) {
      this.#readdirFail(er.code), children.provisional = 0;
    }
    return children.slice(0, children.provisional);
  }
  canReaddir() {
    if (this.#type & ENOCHILD)
      return !1;
    let ifmt = IFMT & this.#type;
    return ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK;
  }
  shouldWalk(dirs, walkFilter) {
    return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
  }
  /**
   * Return the Path object corresponding to path as resolved
   * by realpath(3).
   *
   * If the realpath call fails for any reason, `undefined` is returned.
   *
   * Result is cached, and thus may be outdated if the filesystem is mutated.
   * On success, returns a Path object.
   */
  async realpath() {
    if (this.#realpath)
      return this.#realpath;
    if (!((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type))
      try {
        let rp = await this.#fs.promises.realpath(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch {
        this.#markENOREALPATH();
      }
  }
  /**
   * Synchronous {@link realpath}
   */
  realpathSync() {
    if (this.#realpath)
      return this.#realpath;
    if (!((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type))
      try {
        let rp = this.#fs.realpathSync(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch {
        this.#markENOREALPATH();
      }
  }
  /**
   * Internal method to mark this Path object as the scurry cwd,
   * called by {@link PathScurry#chdir}
   *
   * @internal
   */
  [setAsCwd](oldCwd) {
    if (oldCwd === this)
      return;
    let changed = /* @__PURE__ */ new Set([]), rp = [], p = this;
    for (; p && p.parent; )
      changed.add(p), p.#relative = rp.join(this.sep), p.#relativePosix = rp.join("/"), p = p.parent, rp.push("..");
    for (p = oldCwd; p && p.parent && !changed.has(p); )
      p.#relative = void 0, p.#relativePosix = void 0, p = p.parent;
  }
}, PathWin32 = class _PathWin32 extends PathBase {
  /**
   * Separator for generating path strings.
   */
  sep = "\\";
  /**
   * Separator for parsing path strings.
   */
  splitSep = eitherSep;
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
    super(name, type, root, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  newChild(name, type = UNKNOWN, opts = {}) {
    return new _PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
  /**
   * @internal
   */
  getRootString(path6) {
    return import_path3.win32.parse(path6).root;
  }
  /**
   * @internal
   */
  getRoot(rootPath) {
    if (rootPath = uncToDrive(rootPath.toUpperCase()), rootPath === this.root.name)
      return this.root;
    for (let [compare, root] of Object.entries(this.roots))
      if (this.sameRoot(rootPath, compare))
        return this.roots[rootPath] = root;
    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
  }
  /**
   * @internal
   */
  sameRoot(rootPath, compare = this.root.name) {
    return rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\"), rootPath === compare;
  }
}, PathPosix = class _PathPosix extends PathBase {
  /**
   * separator for parsing path strings
   */
  splitSep = "/";
  /**
   * separator for generating path strings
   */
  sep = "/";
  /**
   * Do not create new Path objects directly.  They should always be accessed
   * via the PathScurry class or other methods on the Path class.
   *
   * @internal
   */
  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
    super(name, type, root, roots, nocase, children, opts);
  }
  /**
   * @internal
   */
  getRootString(path6) {
    return path6.startsWith("/") ? "/" : "";
  }
  /**
   * @internal
   */
  getRoot(_rootPath) {
    return this.root;
  }
  /**
   * @internal
   */
  newChild(name, type = UNKNOWN, opts = {}) {
    return new _PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
  }
}, PathScurryBase = class {
  /**
   * The root Path entry for the current working directory of this Scurry
   */
  root;
  /**
   * The string path for the root of this Scurry's current working directory
   */
  rootPath;
  /**
   * A collection of all roots encountered, referenced by rootPath
   */
  roots;
  /**
   * The Path entry corresponding to this PathScurry's current working directory.
   */
  cwd;
  #resolveCache;
  #resolvePosixCache;
  #children;
  /**
   * Perform path comparisons case-insensitively.
   *
   * Defaults true on Darwin and Windows systems, false elsewhere.
   */
  nocase;
  #fs;
  /**
   * This class should not be instantiated directly.
   *
   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
   *
   * @internal
   */
  constructor(cwd2 = process.cwd(), pathImpl, sep2, { nocase, childrenCacheSize = 16 * 1024, fs: fs7 = defaultFS } = {}) {
    this.#fs = fsFromOption(fs7), (cwd2 instanceof URL || cwd2.startsWith("file://")) && (cwd2 = (0, import_url.fileURLToPath)(cwd2));
    let cwdPath = pathImpl.resolve(cwd2);
    this.roots = /* @__PURE__ */ Object.create(null), this.rootPath = this.parseRootPath(cwdPath), this.#resolveCache = new ResolveCache(), this.#resolvePosixCache = new ResolveCache(), this.#children = new ChildrenCache(childrenCacheSize);
    let split = cwdPath.substring(this.rootPath.length).split(sep2);
    if (split.length === 1 && !split[0] && split.pop(), nocase === void 0)
      throw new TypeError("must provide nocase setting to PathScurryBase ctor");
    this.nocase = nocase, this.root = this.newRoot(this.#fs), this.roots[this.rootPath] = this.root;
    let prev = this.root, len = split.length - 1, joinSep = pathImpl.sep, abs = this.rootPath, sawFirst = !1;
    for (let part of split) {
      let l = len--;
      prev = prev.child(part, {
        relative: new Array(l).fill("..").join(joinSep),
        relativePosix: new Array(l).fill("..").join("/"),
        fullpath: abs += (sawFirst ? "" : joinSep) + part
      }), sawFirst = !0;
    }
    this.cwd = prev;
  }
  /**
   * Get the depth of a provided path, string, or the cwd
   */
  depth(path6 = this.cwd) {
    return typeof path6 == "string" && (path6 = this.cwd.resolve(path6)), path6.depth();
  }
  /**
   * Return the cache of child entries.  Exposed so subclasses can create
   * child Path objects in a platform-specific way.
   *
   * @internal
   */
  childrenCache() {
    return this.#children;
  }
  /**
   * Resolve one or more path strings to a resolved string
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolve(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      let p = paths[i];
      if (!(!p || p === ".") && (r = r ? `${p}/${r}` : p, this.isAbsolute(p)))
        break;
    }
    let cached = this.#resolveCache.get(r);
    if (cached !== void 0)
      return cached;
    let result = this.cwd.resolve(r).fullpath();
    return this.#resolveCache.set(r, result), result;
  }
  /**
   * Resolve one or more path strings to a resolved string, returning
   * the posix path.  Identical to .resolve() on posix systems, but on
   * windows will return a forward-slash separated UNC path.
   *
   * Same interface as require('path').resolve.
   *
   * Much faster than path.resolve() when called multiple times for the same
   * path, because the resolved Path objects are cached.  Much slower
   * otherwise.
   */
  resolvePosix(...paths) {
    let r = "";
    for (let i = paths.length - 1; i >= 0; i--) {
      let p = paths[i];
      if (!(!p || p === ".") && (r = r ? `${p}/${r}` : p, this.isAbsolute(p)))
        break;
    }
    let cached = this.#resolvePosixCache.get(r);
    if (cached !== void 0)
      return cached;
    let result = this.cwd.resolve(r).fullpathPosix();
    return this.#resolvePosixCache.set(r, result), result;
  }
  /**
   * find the relative path from the cwd to the supplied path string or entry
   */
  relative(entry = this.cwd) {
    return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.relative();
  }
  /**
   * find the relative path from the cwd to the supplied path string or
   * entry, using / as the path delimiter, even on Windows.
   */
  relativePosix(entry = this.cwd) {
    return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.relativePosix();
  }
  /**
   * Return the basename for the provided string or Path object
   */
  basename(entry = this.cwd) {
    return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.name;
  }
  /**
   * Return the dirname for the provided string or Path object
   */
  dirname(entry = this.cwd) {
    return typeof entry == "string" && (entry = this.cwd.resolve(entry)), (entry.parent || entry).fullpath();
  }
  async readdir(entry = this.cwd, opts = {
    withFileTypes: !0
  }) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    let { withFileTypes } = opts;
    if (entry.canReaddir()) {
      let p = await entry.readdir();
      return withFileTypes ? p : p.map((e) => e.name);
    } else
      return [];
  }
  readdirSync(entry = this.cwd, opts = {
    withFileTypes: !0
  }) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    let { withFileTypes = !0 } = opts;
    return entry.canReaddir() ? withFileTypes ? entry.readdirSync() : entry.readdirSync().map((e) => e.name) : [];
  }
  /**
   * Call lstat() on the string or Path object, and update all known
   * information that can be determined.
   *
   * Note that unlike `fs.lstat()`, the returned value does not contain some
   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
   * information is required, you will need to call `fs.lstat` yourself.
   *
   * If the Path refers to a nonexistent file, or if the lstat call fails for
   * any reason, `undefined` is returned.  Otherwise the updated Path object is
   * returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   */
  async lstat(entry = this.cwd) {
    return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.lstat();
  }
  /**
   * synchronous {@link PathScurryBase.lstat}
   */
  lstatSync(entry = this.cwd) {
    return typeof entry == "string" && (entry = this.cwd.resolve(entry)), entry.lstatSync();
  }
  async readlink(entry = this.cwd, { withFileTypes } = {
    withFileTypes: !1
  }) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (withFileTypes = entry.withFileTypes, entry = this.cwd);
    let e = await entry.readlink();
    return withFileTypes ? e : e == null ? void 0 : e.fullpath();
  }
  readlinkSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: !1
  }) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (withFileTypes = entry.withFileTypes, entry = this.cwd);
    let e = entry.readlinkSync();
    return withFileTypes ? e : e == null ? void 0 : e.fullpath();
  }
  async realpath(entry = this.cwd, { withFileTypes } = {
    withFileTypes: !1
  }) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (withFileTypes = entry.withFileTypes, entry = this.cwd);
    let e = await entry.realpath();
    return withFileTypes ? e : e == null ? void 0 : e.fullpath();
  }
  realpathSync(entry = this.cwd, { withFileTypes } = {
    withFileTypes: !1
  }) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (withFileTypes = entry.withFileTypes, entry = this.cwd);
    let e = entry.realpathSync();
    return withFileTypes ? e : e == null ? void 0 : e.fullpath();
  }
  async walk(entry = this.cwd, opts = {}) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    let { withFileTypes = !0, follow = !1, filter: filter2, walkFilter } = opts, results = [];
    (!filter2 || filter2(entry)) && results.push(withFileTypes ? entry : entry.fullpath());
    let dirs = /* @__PURE__ */ new Set(), walk = (dir, cb) => {
      dirs.add(dir), dir.readdirCB((er, entries) => {
        if (er)
          return cb(er);
        let len = entries.length;
        if (!len)
          return cb();
        let next = () => {
          --len === 0 && cb();
        };
        for (let e of entries)
          (!filter2 || filter2(e)) && results.push(withFileTypes ? e : e.fullpath()), follow && e.isSymbolicLink() ? e.realpath().then((r) => r != null && r.isUnknown() ? r.lstat() : r).then((r) => r != null && r.shouldWalk(dirs, walkFilter) ? walk(r, next) : next()) : e.shouldWalk(dirs, walkFilter) ? walk(e, next) : next();
      }, !0);
    }, start = entry;
    return new Promise((res, rej) => {
      walk(start, (er) => {
        if (er)
          return rej(er);
        res(results);
      });
    });
  }
  walkSync(entry = this.cwd, opts = {}) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    let { withFileTypes = !0, follow = !1, filter: filter2, walkFilter } = opts, results = [];
    (!filter2 || filter2(entry)) && results.push(withFileTypes ? entry : entry.fullpath());
    let dirs = /* @__PURE__ */ new Set([entry]);
    for (let dir of dirs) {
      let entries = dir.readdirSync();
      for (let e of entries) {
        (!filter2 || filter2(e)) && results.push(withFileTypes ? e : e.fullpath());
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          r.isUnknown() && r.lstatSync();
        }
        r.shouldWalk(dirs, walkFilter) && dirs.add(r);
      }
    }
    return results;
  }
  /**
   * Support for `for await`
   *
   * Alias for {@link PathScurryBase.iterate}
   *
   * Note: As of Node 19, this is very slow, compared to other methods of
   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
   */
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
  iterate(entry = this.cwd, options = {}) {
    return typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (options = entry, entry = this.cwd), this.stream(entry, options)[Symbol.asyncIterator]();
  }
  /**
   * Iterating over a PathScurry performs a synchronous walk.
   *
   * Alias for {@link PathScurryBase.iterateSync}
   */
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  *iterateSync(entry = this.cwd, opts = {}) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    let { withFileTypes = !0, follow = !1, filter: filter2, walkFilter } = opts;
    (!filter2 || filter2(entry)) && (yield withFileTypes ? entry : entry.fullpath());
    let dirs = /* @__PURE__ */ new Set([entry]);
    for (let dir of dirs) {
      let entries = dir.readdirSync();
      for (let e of entries) {
        (!filter2 || filter2(e)) && (yield withFileTypes ? e : e.fullpath());
        let r = e;
        if (e.isSymbolicLink()) {
          if (!(follow && (r = e.realpathSync())))
            continue;
          r.isUnknown() && r.lstatSync();
        }
        r.shouldWalk(dirs, walkFilter) && dirs.add(r);
      }
    }
  }
  stream(entry = this.cwd, opts = {}) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    let { withFileTypes = !0, follow = !1, filter: filter2, walkFilter } = opts, results = new Minipass({ objectMode: !0 });
    (!filter2 || filter2(entry)) && results.write(withFileTypes ? entry : entry.fullpath());
    let dirs = /* @__PURE__ */ new Set(), queue = [entry], processing = 0, process4 = () => {
      let paused = !1;
      for (; !paused; ) {
        let dir = queue.shift();
        if (!dir) {
          processing === 0 && results.end();
          return;
        }
        processing++, dirs.add(dir);
        let onReaddir = (er, entries, didRealpaths = !1) => {
          if (er)
            return results.emit("error", er);
          if (follow && !didRealpaths) {
            let promises2 = [];
            for (let e of entries)
              e.isSymbolicLink() && promises2.push(e.realpath().then((r) => r != null && r.isUnknown() ? r.lstat() : r));
            if (promises2.length) {
              Promise.all(promises2).then(() => onReaddir(null, entries, !0));
              return;
            }
          }
          for (let e of entries)
            e && (!filter2 || filter2(e)) && (results.write(withFileTypes ? e : e.fullpath()) || (paused = !0));
          processing--;
          for (let e of entries) {
            let r = e.realpathCached() || e;
            r.shouldWalk(dirs, walkFilter) && queue.push(r);
          }
          paused && !results.flowing ? results.once("drain", process4) : sync2 || process4();
        }, sync2 = !0;
        dir.readdirCB(onReaddir, !0), sync2 = !1;
      }
    };
    return process4(), results;
  }
  streamSync(entry = this.cwd, opts = {}) {
    typeof entry == "string" ? entry = this.cwd.resolve(entry) : entry instanceof PathBase || (opts = entry, entry = this.cwd);
    let { withFileTypes = !0, follow = !1, filter: filter2, walkFilter } = opts, results = new Minipass({ objectMode: !0 }), dirs = /* @__PURE__ */ new Set();
    (!filter2 || filter2(entry)) && results.write(withFileTypes ? entry : entry.fullpath());
    let queue = [entry], processing = 0, process4 = () => {
      let paused = !1;
      for (; !paused; ) {
        let dir = queue.shift();
        if (!dir) {
          processing === 0 && results.end();
          return;
        }
        processing++, dirs.add(dir);
        let entries = dir.readdirSync();
        for (let e of entries)
          (!filter2 || filter2(e)) && (results.write(withFileTypes ? e : e.fullpath()) || (paused = !0));
        processing--;
        for (let e of entries) {
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            r.isUnknown() && r.lstatSync();
          }
          r.shouldWalk(dirs, walkFilter) && queue.push(r);
        }
      }
      paused && !results.flowing && results.once("drain", process4);
    };
    return process4(), results;
  }
  chdir(path6 = this.cwd) {
    let oldCwd = this.cwd;
    this.cwd = typeof path6 == "string" ? this.cwd.resolve(path6) : path6, this.cwd[setAsCwd](oldCwd);
  }
}, PathScurryWin32 = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "\\";
  constructor(cwd2 = process.cwd(), opts = {}) {
    let { nocase = !0 } = opts;
    super(cwd2, import_path3.win32, "\\", { ...opts, nocase }), this.nocase = nocase;
    for (let p = this.cwd; p; p = p.parent)
      p.nocase = this.nocase;
  }
  /**
   * @internal
   */
  parseRootPath(dir) {
    return import_path3.win32.parse(dir).root.toUpperCase();
  }
  /**
   * @internal
   */
  newRoot(fs7) {
    return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs7 });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
  }
}, PathScurryPosix = class extends PathScurryBase {
  /**
   * separator for generating path strings
   */
  sep = "/";
  constructor(cwd2 = process.cwd(), opts = {}) {
    let { nocase = !1 } = opts;
    super(cwd2, import_path3.posix, "/", { ...opts, nocase }), this.nocase = nocase;
  }
  /**
   * @internal
   */
  parseRootPath(_dir) {
    return "/";
  }
  /**
   * @internal
   */
  newRoot(fs7) {
    return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs7 });
  }
  /**
   * Return true if the provided path string is an absolute path
   */
  isAbsolute(p) {
    return p.startsWith("/");
  }
}, PathScurryDarwin = class extends PathScurryPosix {
  constructor(cwd2 = process.cwd(), opts = {}) {
    let { nocase = !0 } = opts;
    super(cwd2, { ...opts, nocase });
  }
}, Path = process.platform === "win32" ? PathWin32 : PathPosix, PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/glob.js
var import_url2 = require("url");

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/pattern.js
var isPatternList = (pl) => pl.length >= 1, isGlobList = (gl) => gl.length >= 1, Pattern = class _Pattern {
  #patternList;
  #globList;
  #index;
  length;
  #platform;
  #rest;
  #globString;
  #isDrive;
  #isUNC;
  #isAbsolute;
  #followGlobstar = !0;
  constructor(patternList, globList, index, platform) {
    if (!isPatternList(patternList))
      throw new TypeError("empty pattern list");
    if (!isGlobList(globList))
      throw new TypeError("empty glob list");
    if (globList.length !== patternList.length)
      throw new TypeError("mismatched pattern list and glob list lengths");
    if (this.length = patternList.length, index < 0 || index >= this.length)
      throw new TypeError("index out of range");
    if (this.#patternList = patternList, this.#globList = globList, this.#index = index, this.#platform = platform, this.#index === 0) {
      if (this.isUNC()) {
        let [p0, p1, p2, p3, ...prest] = this.#patternList, [g0, g1, g2, g3, ...grest] = this.#globList;
        prest[0] === "" && (prest.shift(), grest.shift());
        let p = [p0, p1, p2, p3, ""].join("/"), g = [g0, g1, g2, g3, ""].join("/");
        this.#patternList = [p, ...prest], this.#globList = [g, ...grest], this.length = this.#patternList.length;
      } else if (this.isDrive() || this.isAbsolute()) {
        let [p1, ...prest] = this.#patternList, [g1, ...grest] = this.#globList;
        prest[0] === "" && (prest.shift(), grest.shift());
        let p = p1 + "/", g = g1 + "/";
        this.#patternList = [p, ...prest], this.#globList = [g, ...grest], this.length = this.#patternList.length;
      }
    }
  }
  /**
   * The first entry in the parsed list of patterns
   */
  pattern() {
    return this.#patternList[this.#index];
  }
  /**
   * true of if pattern() returns a string
   */
  isString() {
    return typeof this.#patternList[this.#index] == "string";
  }
  /**
   * true of if pattern() returns GLOBSTAR
   */
  isGlobstar() {
    return this.#patternList[this.#index] === GLOBSTAR;
  }
  /**
   * true if pattern() returns a regexp
   */
  isRegExp() {
    return this.#patternList[this.#index] instanceof RegExp;
  }
  /**
   * The /-joined set of glob parts that make up this pattern
   */
  globString() {
    return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
  }
  /**
   * true if there are more pattern parts after this one
   */
  hasMore() {
    return this.length > this.#index + 1;
  }
  /**
   * The rest of the pattern after this part, or null if this is the end
   */
  rest() {
    return this.#rest !== void 0 ? this.#rest : this.hasMore() ? (this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform), this.#rest.#isAbsolute = this.#isAbsolute, this.#rest.#isUNC = this.#isUNC, this.#rest.#isDrive = this.#isDrive, this.#rest) : this.#rest = null;
  }
  /**
   * true if the pattern represents a //unc/path/ on windows
   */
  isUNC() {
    let pl = this.#patternList;
    return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] == "string" && !!pl[2] && typeof pl[3] == "string" && !!pl[3];
  }
  // pattern like C:/...
  // split = ['C:', ...]
  // XXX: would be nice to handle patterns like `c:*` to test the cwd
  // in c: for *, but I don't know of a way to even figure out what that
  // cwd is without actually chdir'ing into it?
  /**
   * True if the pattern starts with a drive letter on Windows
   */
  isDrive() {
    let pl = this.#patternList;
    return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] == "string" && /^[a-z]:$/i.test(pl[0]);
  }
  // pattern = '/' or '/...' or '/x/...'
  // split = ['', ''] or ['', ...] or ['', 'x', ...]
  // Drive and UNC both considered absolute on windows
  /**
   * True if the pattern is rooted on an absolute path
   */
  isAbsolute() {
    let pl = this.#patternList;
    return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
  }
  /**
   * consume the root of the pattern, and return it
   */
  root() {
    let p = this.#patternList[0];
    return typeof p == "string" && this.isAbsolute() && this.#index === 0 ? p : "";
  }
  /**
   * Check to see if the current globstar pattern is allowed to follow
   * a symbolic link.
   */
  checkFollowGlobstar() {
    return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
  }
  /**
   * Mark that the current globstar pattern is following a symbolic link
   */
  markFollowGlobstar() {
    return this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar ? !1 : (this.#followGlobstar = !1, !0);
  }
};

// ../../node_modules/rimraf/node_modules/minipass/dist/mjs/index.js
var import_events2 = require("events"), import_stream2 = __toESM(require("stream"), 1), import_string_decoder2 = require("string_decoder"), proc2 = typeof process == "object" && process ? process : {
  stdout: null,
  stderr: null
}, isStream2 = (s) => !!s && typeof s == "object" && (s instanceof Minipass2 || s instanceof import_stream2.default || isReadable2(s) || isWritable2(s)), isReadable2 = (s) => !!s && typeof s == "object" && s instanceof import_events2.EventEmitter && typeof s.pipe == "function" && // node core Writable streams have a pipe() method, but it throws
s.pipe !== import_stream2.default.Writable.prototype.pipe, isWritable2 = (s) => !!s && typeof s == "object" && s instanceof import_events2.EventEmitter && typeof s.write == "function" && typeof s.end == "function", EOF2 = Symbol("EOF"), MAYBE_EMIT_END2 = Symbol("maybeEmitEnd"), EMITTED_END2 = Symbol("emittedEnd"), EMITTING_END2 = Symbol("emittingEnd"), EMITTED_ERROR2 = Symbol("emittedError"), CLOSED2 = Symbol("closed"), READ2 = Symbol("read"), FLUSH2 = Symbol("flush"), FLUSHCHUNK2 = Symbol("flushChunk"), ENCODING2 = Symbol("encoding"), DECODER2 = Symbol("decoder"), FLOWING2 = Symbol("flowing"), PAUSED2 = Symbol("paused"), RESUME2 = Symbol("resume"), BUFFER2 = Symbol("buffer"), PIPES2 = Symbol("pipes"), BUFFERLENGTH2 = Symbol("bufferLength"), BUFFERPUSH2 = Symbol("bufferPush"), BUFFERSHIFT2 = Symbol("bufferShift"), OBJECTMODE2 = Symbol("objectMode"), DESTROYED2 = Symbol("destroyed"), ERROR2 = Symbol("error"), EMITDATA2 = Symbol("emitData"), EMITEND3 = Symbol("emitEnd"), EMITEND22 = Symbol("emitEnd2"), ASYNC2 = Symbol("async"), ABORT2 = Symbol("abort"), ABORTED2 = Symbol("aborted"), SIGNAL2 = Symbol("signal"), DATALISTENERS2 = Symbol("dataListeners"), DISCARDED2 = Symbol("discarded"), defer2 = (fn) => Promise.resolve().then(fn), nodefer2 = (fn) => fn(), isEndish2 = (ev) => ev === "end" || ev === "finish" || ev === "prefinish", isArrayBufferLike2 = (b) => b instanceof ArrayBuffer || !!b && typeof b == "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0, isArrayBufferView2 = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b), Pipe2 = class {
  src;
  dest;
  opts;
  ondrain;
  constructor(src, dest, opts) {
    this.src = src, this.dest = dest, this.opts = opts, this.ondrain = () => src[RESUME2](), this.dest.on("drain", this.ondrain);
  }
  unpipe() {
    this.dest.removeListener("drain", this.ondrain);
  }
  // only here for the prototype
  /* c8 ignore start */
  proxyErrors(_er) {
  }
  /* c8 ignore stop */
  end() {
    this.unpipe(), this.opts.end && this.dest.end();
  }
}, PipeProxyErrors2 = class extends Pipe2 {
  unpipe() {
    this.src.removeListener("error", this.proxyErrors), super.unpipe();
  }
  constructor(src, dest, opts) {
    super(src, dest, opts), this.proxyErrors = (er) => dest.emit("error", er), src.on("error", this.proxyErrors);
  }
}, isObjectModeOptions2 = (o) => !!o.objectMode, isEncodingOptions2 = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer", Minipass2 = class extends import_events2.EventEmitter {
  [FLOWING2] = !1;
  [PAUSED2] = !1;
  [PIPES2] = [];
  [BUFFER2] = [];
  [OBJECTMODE2];
  [ENCODING2];
  [ASYNC2];
  [DECODER2];
  [EOF2] = !1;
  [EMITTED_END2] = !1;
  [EMITTING_END2] = !1;
  [CLOSED2] = !1;
  [EMITTED_ERROR2] = null;
  [BUFFERLENGTH2] = 0;
  [DESTROYED2] = !1;
  [SIGNAL2];
  [ABORTED2] = !1;
  [DATALISTENERS2] = 0;
  [DISCARDED2] = !1;
  /**
   * true if the stream can be written
   */
  writable = !0;
  /**
   * true if the stream can be read
   */
  readable = !0;
  /**
   * If `RType` is Buffer, then options do not need to be provided.
   * Otherwise, an options object must be provided to specify either
   * {@link Minipass.SharedOptions.objectMode} or
   * {@link Minipass.SharedOptions.encoding}, as appropriate.
   */
  constructor(...args) {
    let options = args[0] || {};
    if (super(), options.objectMode && typeof options.encoding == "string")
      throw new TypeError("Encoding and objectMode may not be used together");
    isObjectModeOptions2(options) ? (this[OBJECTMODE2] = !0, this[ENCODING2] = null) : isEncodingOptions2(options) ? (this[ENCODING2] = options.encoding, this[OBJECTMODE2] = !1) : (this[OBJECTMODE2] = !1, this[ENCODING2] = null), this[ASYNC2] = !!options.async, this[DECODER2] = this[ENCODING2] ? new import_string_decoder2.StringDecoder(this[ENCODING2]) : null, options && options.debugExposeBuffer === !0 && Object.defineProperty(this, "buffer", { get: () => this[BUFFER2] }), options && options.debugExposePipes === !0 && Object.defineProperty(this, "pipes", { get: () => this[PIPES2] });
    let { signal } = options;
    signal && (this[SIGNAL2] = signal, signal.aborted ? this[ABORT2]() : signal.addEventListener("abort", () => this[ABORT2]()));
  }
  /**
   * The amount of data stored in the buffer waiting to be read.
   *
   * For Buffer strings, this will be the total byte length.
   * For string encoding streams, this will be the string character length,
   * according to JavaScript's `string.length` logic.
   * For objectMode streams, this is a count of the items waiting to be
   * emitted.
   */
  get bufferLength() {
    return this[BUFFERLENGTH2];
  }
  /**
   * The `BufferEncoding` currently in use, or `null`
   */
  get encoding() {
    return this[ENCODING2];
  }
  /**
   * @deprecated - This is a read only property
   */
  set encoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * @deprecated - Encoding may only be set at instantiation time
   */
  setEncoding(_enc) {
    throw new Error("Encoding must be set at instantiation time");
  }
  /**
   * True if this is an objectMode stream
   */
  get objectMode() {
    return this[OBJECTMODE2];
  }
  /**
   * @deprecated - This is a read-only property
   */
  set objectMode(_om) {
    throw new Error("objectMode must be set at instantiation time");
  }
  /**
   * true if this is an async stream
   */
  get async() {
    return this[ASYNC2];
  }
  /**
   * Set to true to make this stream async.
   *
   * Once set, it cannot be unset, as this would potentially cause incorrect
   * behavior.  Ie, a sync stream can be made async, but an async stream
   * cannot be safely made sync.
   */
  set async(a) {
    this[ASYNC2] = this[ASYNC2] || !!a;
  }
  // drop everything and get out of the flow completely
  [ABORT2]() {
    var _a2, _b;
    this[ABORTED2] = !0, this.emit("abort", (_a2 = this[SIGNAL2]) == null ? void 0 : _a2.reason), this.destroy((_b = this[SIGNAL2]) == null ? void 0 : _b.reason);
  }
  /**
   * True if the stream has been aborted.
   */
  get aborted() {
    return this[ABORTED2];
  }
  /**
   * No-op setter. Stream aborted status is set via the AbortSignal provided
   * in the constructor options.
   */
  set aborted(_) {
  }
  write(chunk, encoding, cb) {
    var _a2;
    if (this[ABORTED2])
      return !1;
    if (this[EOF2])
      throw new Error("write after end");
    if (this[DESTROYED2])
      return this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" })), !0;
    typeof encoding == "function" && (cb = encoding, encoding = "utf8"), encoding || (encoding = "utf8");
    let fn = this[ASYNC2] ? defer2 : nodefer2;
    if (!this[OBJECTMODE2] && !Buffer.isBuffer(chunk)) {
      if (isArrayBufferView2(chunk))
        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      else if (isArrayBufferLike2(chunk))
        chunk = Buffer.from(chunk);
      else if (typeof chunk != "string")
        throw new Error("Non-contiguous data written to non-objectMode stream");
    }
    return this[OBJECTMODE2] ? (this[FLOWING2] && this[BUFFERLENGTH2] !== 0 && this[FLUSH2](!0), this[FLOWING2] ? this.emit("data", chunk) : this[BUFFERPUSH2](chunk), this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING2]) : chunk.length ? (typeof chunk == "string" && // unless it is a string already ready for us to use
    !(encoding === this[ENCODING2] && !((_a2 = this[DECODER2]) != null && _a2.lastNeed)) && (chunk = Buffer.from(chunk, encoding)), Buffer.isBuffer(chunk) && this[ENCODING2] && (chunk = this[DECODER2].write(chunk)), this[FLOWING2] && this[BUFFERLENGTH2] !== 0 && this[FLUSH2](!0), this[FLOWING2] ? this.emit("data", chunk) : this[BUFFERPUSH2](chunk), this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING2]) : (this[BUFFERLENGTH2] !== 0 && this.emit("readable"), cb && fn(cb), this[FLOWING2]);
  }
  /**
   * Low-level explicit read method.
   *
   * In objectMode, the argument is ignored, and one item is returned if
   * available.
   *
   * `n` is the number of bytes (or in the case of encoding streams,
   * characters) to consume. If `n` is not provided, then the entire buffer
   * is returned, or `null` is returned if no data is available.
   *
   * If `n` is greater that the amount of data in the internal buffer,
   * then `null` is returned.
   */
  read(n) {
    if (this[DESTROYED2])
      return null;
    if (this[DISCARDED2] = !1, this[BUFFERLENGTH2] === 0 || n === 0 || n && n > this[BUFFERLENGTH2])
      return this[MAYBE_EMIT_END2](), null;
    this[OBJECTMODE2] && (n = null), this[BUFFER2].length > 1 && !this[OBJECTMODE2] && (this[BUFFER2] = [
      this[ENCODING2] ? this[BUFFER2].join("") : Buffer.concat(this[BUFFER2], this[BUFFERLENGTH2])
    ]);
    let ret = this[READ2](n || null, this[BUFFER2][0]);
    return this[MAYBE_EMIT_END2](), ret;
  }
  [READ2](n, chunk) {
    if (this[OBJECTMODE2])
      this[BUFFERSHIFT2]();
    else {
      let c = chunk;
      n === c.length || n === null ? this[BUFFERSHIFT2]() : typeof c == "string" ? (this[BUFFER2][0] = c.slice(n), chunk = c.slice(0, n), this[BUFFERLENGTH2] -= n) : (this[BUFFER2][0] = c.subarray(n), chunk = c.subarray(0, n), this[BUFFERLENGTH2] -= n);
    }
    return this.emit("data", chunk), !this[BUFFER2].length && !this[EOF2] && this.emit("drain"), chunk;
  }
  end(chunk, encoding, cb) {
    return typeof chunk == "function" && (cb = chunk, chunk = void 0), typeof encoding == "function" && (cb = encoding, encoding = "utf8"), chunk !== void 0 && this.write(chunk, encoding), cb && this.once("end", cb), this[EOF2] = !0, this.writable = !1, (this[FLOWING2] || !this[PAUSED2]) && this[MAYBE_EMIT_END2](), this;
  }
  // don't let the internal resume be overwritten
  [RESUME2]() {
    this[DESTROYED2] || (!this[DATALISTENERS2] && !this[PIPES2].length && (this[DISCARDED2] = !0), this[PAUSED2] = !1, this[FLOWING2] = !0, this.emit("resume"), this[BUFFER2].length ? this[FLUSH2]() : this[EOF2] ? this[MAYBE_EMIT_END2]() : this.emit("drain"));
  }
  /**
   * Resume the stream if it is currently in a paused state
   *
   * If called when there are no pipe destinations or `data` event listeners,
   * this will place the stream in a "discarded" state, where all data will
   * be thrown away. The discarded state is removed if a pipe destination or
   * data handler is added, if pause() is called, or if any synchronous or
   * asynchronous iteration is started.
   */
  resume() {
    return this[RESUME2]();
  }
  /**
   * Pause the stream
   */
  pause() {
    this[FLOWING2] = !1, this[PAUSED2] = !0, this[DISCARDED2] = !1;
  }
  /**
   * true if the stream has been forcibly destroyed
   */
  get destroyed() {
    return this[DESTROYED2];
  }
  /**
   * true if the stream is currently in a flowing state, meaning that
   * any writes will be immediately emitted.
   */
  get flowing() {
    return this[FLOWING2];
  }
  /**
   * true if the stream is currently in a paused state
   */
  get paused() {
    return this[PAUSED2];
  }
  [BUFFERPUSH2](chunk) {
    this[OBJECTMODE2] ? this[BUFFERLENGTH2] += 1 : this[BUFFERLENGTH2] += chunk.length, this[BUFFER2].push(chunk);
  }
  [BUFFERSHIFT2]() {
    return this[OBJECTMODE2] ? this[BUFFERLENGTH2] -= 1 : this[BUFFERLENGTH2] -= this[BUFFER2][0].length, this[BUFFER2].shift();
  }
  [FLUSH2](noDrain = !1) {
    do
      ;
    while (this[FLUSHCHUNK2](this[BUFFERSHIFT2]()) && this[BUFFER2].length);
    !noDrain && !this[BUFFER2].length && !this[EOF2] && this.emit("drain");
  }
  [FLUSHCHUNK2](chunk) {
    return this.emit("data", chunk), this[FLOWING2];
  }
  /**
   * Pipe all data emitted by this stream into the destination provided.
   *
   * Triggers the flow of data.
   */
  pipe(dest, opts) {
    if (this[DESTROYED2])
      return dest;
    this[DISCARDED2] = !1;
    let ended = this[EMITTED_END2];
    return opts = opts || {}, dest === proc2.stdout || dest === proc2.stderr ? opts.end = !1 : opts.end = opts.end !== !1, opts.proxyErrors = !!opts.proxyErrors, ended ? opts.end && dest.end() : (this[PIPES2].push(opts.proxyErrors ? new PipeProxyErrors2(this, dest, opts) : new Pipe2(this, dest, opts)), this[ASYNC2] ? defer2(() => this[RESUME2]()) : this[RESUME2]()), dest;
  }
  /**
   * Fully unhook a piped destination stream.
   *
   * If the destination stream was the only consumer of this stream (ie,
   * there are no other piped destinations or `'data'` event listeners)
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  unpipe(dest) {
    let p = this[PIPES2].find((p2) => p2.dest === dest);
    p && (this[PIPES2].length === 1 ? (this[FLOWING2] && this[DATALISTENERS2] === 0 && (this[FLOWING2] = !1), this[PIPES2] = []) : this[PIPES2].splice(this[PIPES2].indexOf(p), 1), p.unpipe());
  }
  /**
   * Alias for {@link Minipass#on}
   */
  addListener(ev, handler) {
    return this.on(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.on`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * - Adding a 'data' event handler will trigger the flow of data
   *
   * - Adding a 'readable' event handler when there is data waiting to be read
   *   will cause 'readable' to be emitted immediately.
   *
   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
   *   already passed will cause the event to be emitted immediately and all
   *   handlers removed.
   *
   * - Adding an 'error' event handler after an error has been emitted will
   *   cause the event to be re-emitted immediately with the error previously
   *   raised.
   */
  on(ev, handler) {
    let ret = super.on(ev, handler);
    if (ev === "data")
      this[DISCARDED2] = !1, this[DATALISTENERS2]++, !this[PIPES2].length && !this[FLOWING2] && this[RESUME2]();
    else if (ev === "readable" && this[BUFFERLENGTH2] !== 0)
      super.emit("readable");
    else if (isEndish2(ev) && this[EMITTED_END2])
      super.emit(ev), this.removeAllListeners(ev);
    else if (ev === "error" && this[EMITTED_ERROR2]) {
      let h = handler;
      this[ASYNC2] ? defer2(() => h.call(this, this[EMITTED_ERROR2])) : h.call(this, this[EMITTED_ERROR2]);
    }
    return ret;
  }
  /**
   * Alias for {@link Minipass#off}
   */
  removeListener(ev, handler) {
    return this.off(ev, handler);
  }
  /**
   * Mostly identical to `EventEmitter.off`
   *
   * If a 'data' event handler is removed, and it was the last consumer
   * (ie, there are no pipe destinations or other 'data' event listeners),
   * then the flow of data will stop until there is another consumer or
   * {@link Minipass#resume} is explicitly called.
   */
  off(ev, handler) {
    let ret = super.off(ev, handler);
    return ev === "data" && (this[DATALISTENERS2] = this.listeners("data").length, this[DATALISTENERS2] === 0 && !this[DISCARDED2] && !this[PIPES2].length && (this[FLOWING2] = !1)), ret;
  }
  /**
   * Mostly identical to `EventEmitter.removeAllListeners`
   *
   * If all 'data' event handlers are removed, and they were the last consumer
   * (ie, there are no pipe destinations), then the flow of data will stop
   * until there is another consumer or {@link Minipass#resume} is explicitly
   * called.
   */
  removeAllListeners(ev) {
    let ret = super.removeAllListeners(ev);
    return (ev === "data" || ev === void 0) && (this[DATALISTENERS2] = 0, !this[DISCARDED2] && !this[PIPES2].length && (this[FLOWING2] = !1)), ret;
  }
  /**
   * true if the 'end' event has been emitted
   */
  get emittedEnd() {
    return this[EMITTED_END2];
  }
  [MAYBE_EMIT_END2]() {
    !this[EMITTING_END2] && !this[EMITTED_END2] && !this[DESTROYED2] && this[BUFFER2].length === 0 && this[EOF2] && (this[EMITTING_END2] = !0, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[CLOSED2] && this.emit("close"), this[EMITTING_END2] = !1);
  }
  /**
   * Mostly identical to `EventEmitter.emit`, with the following
   * behavior differences to prevent data loss and unnecessary hangs:
   *
   * If the stream has been destroyed, and the event is something other
   * than 'close' or 'error', then `false` is returned and no handlers
   * are called.
   *
   * If the event is 'end', and has already been emitted, then the event
   * is ignored. If the stream is in a paused or non-flowing state, then
   * the event will be deferred until data flow resumes. If the stream is
   * async, then handlers will be called on the next tick rather than
   * immediately.
   *
   * If the event is 'close', and 'end' has not yet been emitted, then
   * the event will be deferred until after 'end' is emitted.
   *
   * If the event is 'error', and an AbortSignal was provided for the stream,
   * and there are no listeners, then the event is ignored, matching the
   * behavior of node core streams in the presense of an AbortSignal.
   *
   * If the event is 'finish' or 'prefinish', then all listeners will be
   * removed after emitting the event, to prevent double-firing.
   */
  emit(ev, ...args) {
    let data = args[0];
    if (ev !== "error" && ev !== "close" && ev !== DESTROYED2 && this[DESTROYED2])
      return !1;
    if (ev === "data")
      return !this[OBJECTMODE2] && !data ? !1 : this[ASYNC2] ? (defer2(() => this[EMITDATA2](data)), !0) : this[EMITDATA2](data);
    if (ev === "end")
      return this[EMITEND3]();
    if (ev === "close") {
      if (this[CLOSED2] = !0, !this[EMITTED_END2] && !this[DESTROYED2])
        return !1;
      let ret2 = super.emit("close");
      return this.removeAllListeners("close"), ret2;
    } else if (ev === "error") {
      this[EMITTED_ERROR2] = data, super.emit(ERROR2, data);
      let ret2 = !this[SIGNAL2] || this.listeners("error").length ? super.emit("error", data) : !1;
      return this[MAYBE_EMIT_END2](), ret2;
    } else if (ev === "resume") {
      let ret2 = super.emit("resume");
      return this[MAYBE_EMIT_END2](), ret2;
    } else if (ev === "finish" || ev === "prefinish") {
      let ret2 = super.emit(ev);
      return this.removeAllListeners(ev), ret2;
    }
    let ret = super.emit(ev, ...args);
    return this[MAYBE_EMIT_END2](), ret;
  }
  [EMITDATA2](data) {
    for (let p of this[PIPES2])
      p.dest.write(data) === !1 && this.pause();
    let ret = this[DISCARDED2] ? !1 : super.emit("data", data);
    return this[MAYBE_EMIT_END2](), ret;
  }
  [EMITEND3]() {
    return this[EMITTED_END2] ? !1 : (this[EMITTED_END2] = !0, this.readable = !1, this[ASYNC2] ? (defer2(() => this[EMITEND22]()), !0) : this[EMITEND22]());
  }
  [EMITEND22]() {
    if (this[DECODER2]) {
      let data = this[DECODER2].end();
      if (data) {
        for (let p of this[PIPES2])
          p.dest.write(data);
        this[DISCARDED2] || super.emit("data", data);
      }
    }
    for (let p of this[PIPES2])
      p.end();
    let ret = super.emit("end");
    return this.removeAllListeners("end"), ret;
  }
  /**
   * Return a Promise that resolves to an array of all emitted data once
   * the stream ends.
   */
  async collect() {
    let buf = Object.assign([], {
      dataLength: 0
    });
    this[OBJECTMODE2] || (buf.dataLength = 0);
    let p = this.promise();
    return this.on("data", (c) => {
      buf.push(c), this[OBJECTMODE2] || (buf.dataLength += c.length);
    }), await p, buf;
  }
  /**
   * Return a Promise that resolves to the concatenation of all emitted data
   * once the stream ends.
   *
   * Not allowed on objectMode streams.
   */
  async concat() {
    if (this[OBJECTMODE2])
      throw new Error("cannot concat in objectMode");
    let buf = await this.collect();
    return this[ENCODING2] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
  }
  /**
   * Return a void Promise that resolves once the stream ends.
   */
  async promise() {
    return new Promise((resolve7, reject) => {
      this.on(DESTROYED2, () => reject(new Error("stream destroyed"))), this.on("error", (er) => reject(er)), this.on("end", () => resolve7());
    });
  }
  /**
   * Asynchronous `for await of` iteration.
   *
   * This will continue emitting all chunks until the stream terminates.
   */
  [Symbol.asyncIterator]() {
    this[DISCARDED2] = !1;
    let stopped = !1, stop = async () => (this.pause(), stopped = !0, { value: void 0, done: !0 });
    return {
      next: () => {
        if (stopped)
          return stop();
        let res = this.read();
        if (res !== null)
          return Promise.resolve({ done: !1, value: res });
        if (this[EOF2])
          return stop();
        let resolve7, reject, onerr = (er) => {
          this.off("data", ondata), this.off("end", onend), this.off(DESTROYED2, ondestroy), stop(), reject(er);
        }, ondata = (value) => {
          this.off("error", onerr), this.off("end", onend), this.off(DESTROYED2, ondestroy), this.pause(), resolve7({ value, done: !!this[EOF2] });
        }, onend = () => {
          this.off("error", onerr), this.off("data", ondata), this.off(DESTROYED2, ondestroy), stop(), resolve7({ done: !0, value: void 0 });
        }, ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej, resolve7 = res2, this.once(DESTROYED2, ondestroy), this.once("error", onerr), this.once("end", onend), this.once("data", ondata);
        });
      },
      throw: stop,
      return: stop,
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  /**
   * Synchronous `for of` iteration.
   *
   * The iteration will terminate when the internal buffer runs out, even
   * if the stream has not yet terminated.
   */
  [Symbol.iterator]() {
    this[DISCARDED2] = !1;
    let stopped = !1, stop = () => (this.pause(), this.off(ERROR2, stop), this.off(DESTROYED2, stop), this.off("end", stop), stopped = !0, { done: !0, value: void 0 }), next = () => {
      if (stopped)
        return stop();
      let value = this.read();
      return value === null ? stop() : { done: !1, value };
    };
    return this.once("end", stop), this.once(ERROR2, stop), this.once(DESTROYED2, stop), {
      next,
      throw: stop,
      return: stop,
      [Symbol.iterator]() {
        return this;
      }
    };
  }
  /**
   * Destroy a stream, preventing it from being used for any further purpose.
   *
   * If the stream has a `close()` method, then it will be called on
   * destruction.
   *
   * After destruction, any attempt to write data, read data, or emit most
   * events will be ignored.
   *
   * If an error argument is provided, then it will be emitted in an
   * 'error' event.
   */
  destroy(er) {
    if (this[DESTROYED2])
      return er ? this.emit("error", er) : this.emit(DESTROYED2), this;
    this[DESTROYED2] = !0, this[DISCARDED2] = !0, this[BUFFER2].length = 0, this[BUFFERLENGTH2] = 0;
    let wc = this;
    return typeof wc.close == "function" && !this[CLOSED2] && wc.close(), er ? this.emit("error", er) : this.emit(DESTROYED2), this;
  }
  /**
   * Alias for {@link isStream}
   *
   * Former export location, maintained for backwards compatibility.
   *
   * @deprecated
   */
  static get isStream() {
    return isStream2;
  }
};

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/ignore.js
var defaultPlatform2 = typeof process == "object" && process && typeof process.platform == "string" ? process.platform : "linux", Ignore = class {
  relative;
  relativeChildren;
  absolute;
  absoluteChildren;
  constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform2 }) {
    this.relative = [], this.absolute = [], this.relativeChildren = [], this.absoluteChildren = [];
    let mmopts = {
      dot: !0,
      nobrace,
      nocase,
      noext,
      noglobstar,
      optimizationLevel: 2,
      platform,
      nocomment: !0,
      nonegate: !0
    };
    for (let ign of ignored) {
      let mm = new Minimatch(ign, mmopts);
      for (let i = 0; i < mm.set.length; i++) {
        let parsed = mm.set[i], globParts = mm.globParts[i], p = new Pattern(parsed, globParts, 0, platform), m = new Minimatch(p.globString(), mmopts), children = globParts[globParts.length - 1] === "**", absolute = p.isAbsolute();
        absolute ? this.absolute.push(m) : this.relative.push(m), children && (absolute ? this.absoluteChildren.push(m) : this.relativeChildren.push(m));
      }
    }
  }
  ignored(p) {
    let fullpath = p.fullpath(), fullpaths = `${fullpath}/`, relative = p.relative() || ".", relatives = `${relative}/`;
    for (let m of this.relative)
      if (m.match(relative) || m.match(relatives))
        return !0;
    for (let m of this.absolute)
      if (m.match(fullpath) || m.match(fullpaths))
        return !0;
    return !1;
  }
  childrenIgnored(p) {
    let fullpath = p.fullpath() + "/", relative = (p.relative() || ".") + "/";
    for (let m of this.relativeChildren)
      if (m.match(relative))
        return !0;
    for (let m of this.absoluteChildren)
      m.match(fullpath);
    return !1;
  }
};

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/processor.js
var HasWalkedCache = class _HasWalkedCache {
  store;
  constructor(store = /* @__PURE__ */ new Map()) {
    this.store = store;
  }
  copy() {
    return new _HasWalkedCache(new Map(this.store));
  }
  hasWalked(target, pattern) {
    var _a2;
    return (_a2 = this.store.get(target.fullpath())) == null ? void 0 : _a2.has(pattern.globString());
  }
  storeWalked(target, pattern) {
    let fullpath = target.fullpath(), cached = this.store.get(fullpath);
    cached ? cached.add(pattern.globString()) : this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
  }
}, MatchRecord = class {
  store = /* @__PURE__ */ new Map();
  add(target, absolute, ifDir) {
    let n = (absolute ? 2 : 0) | (ifDir ? 1 : 0), current = this.store.get(target);
    this.store.set(target, current === void 0 ? n : n & current);
  }
  // match, absolute, ifdir
  entries() {
    return [...this.store.entries()].map(([path6, n]) => [
      path6,
      !!(n & 2),
      !!(n & 1)
    ]);
  }
}, SubWalks = class {
  store = /* @__PURE__ */ new Map();
  add(target, pattern) {
    if (!target.canReaddir())
      return;
    let subs = this.store.get(target);
    subs ? subs.find((p) => p.globString() === pattern.globString()) || subs.push(pattern) : this.store.set(target, [pattern]);
  }
  get(target) {
    let subs = this.store.get(target);
    if (!subs)
      throw new Error("attempting to walk unknown path");
    return subs;
  }
  entries() {
    return this.keys().map((k) => [k, this.store.get(k)]);
  }
  keys() {
    return [...this.store.keys()].filter((t) => t.canReaddir());
  }
}, Processor = class _Processor {
  hasWalkedCache;
  matches = new MatchRecord();
  subwalks = new SubWalks();
  patterns;
  follow;
  dot;
  opts;
  constructor(opts, hasWalkedCache) {
    this.opts = opts, this.follow = !!opts.follow, this.dot = !!opts.dot, this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
  }
  processPatterns(target, patterns) {
    this.patterns = patterns;
    let processingSet = patterns.map((p) => [target, p]);
    for (let [t, pattern] of processingSet) {
      this.hasWalkedCache.storeWalked(t, pattern);
      let root = pattern.root(), absolute = pattern.isAbsolute() && this.opts.absolute !== !1;
      if (root) {
        t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
        let rest2 = pattern.rest();
        if (rest2)
          pattern = rest2;
        else {
          this.matches.add(t, !0, !1);
          continue;
        }
      }
      if (t.isENOENT())
        continue;
      let p, rest, changed = !1;
      for (; typeof (p = pattern.pattern()) == "string" && (rest = pattern.rest()); ) {
        let c = t.resolve(p);
        if (c.isUnknown() && p !== "..")
          break;
        t = c, pattern = rest, changed = !0;
      }
      if (p = pattern.pattern(), rest = pattern.rest(), changed) {
        if (this.hasWalkedCache.hasWalked(t, pattern))
          continue;
        this.hasWalkedCache.storeWalked(t, pattern);
      }
      if (typeof p == "string") {
        if (rest)
          this.subwalks.add(t, pattern);
        else {
          let ifDir = p === ".." || p === "" || p === ".";
          this.matches.add(t.resolve(p), absolute, ifDir);
        }
        continue;
      } else if (p === GLOBSTAR) {
        (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) && this.subwalks.add(t, pattern);
        let rp = rest == null ? void 0 : rest.pattern(), rrest = rest == null ? void 0 : rest.rest();
        if (!rest || (rp === "" || rp === ".") && !rrest)
          this.matches.add(t, absolute, rp === "" || rp === ".");
        else if (rp === "..") {
          let tp = t.parent || t;
          rrest ? this.hasWalkedCache.hasWalked(tp, rrest) || this.subwalks.add(tp, rrest) : this.matches.add(tp, absolute, !0);
        }
      } else
        p instanceof RegExp && this.subwalks.add(t, pattern);
    }
    return this;
  }
  subwalkTargets() {
    return this.subwalks.keys();
  }
  child() {
    return new _Processor(this.opts, this.hasWalkedCache);
  }
  // return a new Processor containing the subwalks for each
  // child entry, and a set of matches, and
  // a hasWalkedCache that's a copy of this one
  // then we're going to call
  filterEntries(parent, entries) {
    let patterns = this.subwalks.get(parent), results = this.child();
    for (let e of entries)
      for (let pattern of patterns) {
        let absolute = pattern.isAbsolute(), p = pattern.pattern(), rest = pattern.rest();
        p === GLOBSTAR ? results.testGlobstar(e, pattern, rest, absolute) : p instanceof RegExp ? results.testRegExp(e, p, rest, absolute) : results.testString(e, p, rest, absolute);
      }
    return results;
  }
  testGlobstar(e, pattern, rest, absolute) {
    if ((this.dot || !e.name.startsWith(".")) && (pattern.hasMore() || this.matches.add(e, absolute, !1), e.canReaddir() && (this.follow || !e.isSymbolicLink() ? this.subwalks.add(e, pattern) : e.isSymbolicLink() && (rest && pattern.checkFollowGlobstar() ? this.subwalks.add(e, rest) : pattern.markFollowGlobstar() && this.subwalks.add(e, pattern)))), rest) {
      let rp = rest.pattern();
      if (typeof rp == "string" && // dots and empty were handled already
      rp !== ".." && rp !== "" && rp !== ".")
        this.testString(e, rp, rest.rest(), absolute);
      else if (rp === "..") {
        let ep = e.parent || e;
        this.subwalks.add(ep, rest);
      } else
        rp instanceof RegExp && this.testRegExp(e, rp, rest.rest(), absolute);
    }
  }
  testRegExp(e, p, rest, absolute) {
    p.test(e.name) && (rest ? this.subwalks.add(e, rest) : this.matches.add(e, absolute, !1));
  }
  testString(e, p, rest, absolute) {
    e.isNamed(p) && (rest ? this.subwalks.add(e, rest) : this.matches.add(e, absolute, !1));
  }
};

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/walker.js
var makeIgnore = (ignore, opts) => typeof ignore == "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore, GlobUtil = class {
  path;
  patterns;
  opts;
  seen = /* @__PURE__ */ new Set();
  paused = !1;
  aborted = !1;
  #onResume = [];
  #ignore;
  #sep;
  signal;
  maxDepth;
  constructor(patterns, path6, opts) {
    this.patterns = patterns, this.path = path6, this.opts = opts, this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/", opts.ignore && (this.#ignore = makeIgnore(opts.ignore, opts)), this.maxDepth = opts.maxDepth || 1 / 0, opts.signal && (this.signal = opts.signal, this.signal.addEventListener("abort", () => {
      this.#onResume.length = 0;
    }));
  }
  #ignored(path6) {
    var _a2, _b;
    return this.seen.has(path6) || !!((_b = (_a2 = this.#ignore) == null ? void 0 : _a2.ignored) != null && _b.call(_a2, path6));
  }
  #childrenIgnored(path6) {
    var _a2, _b;
    return !!((_b = (_a2 = this.#ignore) == null ? void 0 : _a2.childrenIgnored) != null && _b.call(_a2, path6));
  }
  // backpressure mechanism
  pause() {
    this.paused = !0;
  }
  resume() {
    var _a2;
    if ((_a2 = this.signal) != null && _a2.aborted)
      return;
    this.paused = !1;
    let fn;
    for (; !this.paused && (fn = this.#onResume.shift()); )
      fn();
  }
  onResume(fn) {
    var _a2;
    (_a2 = this.signal) != null && _a2.aborted || (this.paused ? this.#onResume.push(fn) : fn());
  }
  // do the requisite realpath/stat checking, and return the path
  // to add or undefined to filter it out.
  async matchCheck(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return;
    let rpc;
    if (this.opts.realpath) {
      if (rpc = e.realpathCached() || await e.realpath(), !rpc)
        return;
      e = rpc;
    }
    let needStat = e.isUnknown() || this.opts.stat;
    return this.matchCheckTest(needStat ? await e.lstat() : e, ifDir);
  }
  matchCheckTest(e, ifDir) {
    return e && (this.maxDepth === 1 / 0 || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && !this.#ignored(e) ? e : void 0;
  }
  matchCheckSync(e, ifDir) {
    if (ifDir && this.opts.nodir)
      return;
    let rpc;
    if (this.opts.realpath) {
      if (rpc = e.realpathCached() || e.realpathSync(), !rpc)
        return;
      e = rpc;
    }
    let needStat = e.isUnknown() || this.opts.stat;
    return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir);
  }
  matchFinish(e, absolute) {
    if (this.#ignored(e))
      return;
    let abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
    this.seen.add(e);
    let mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
    if (this.opts.withFileTypes)
      this.matchEmit(e);
    else if (abs) {
      let abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
      this.matchEmit(abs2 + mark);
    } else {
      let rel = this.opts.posix ? e.relativePosix() : e.relative(), pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
      this.matchEmit(rel ? pre + rel + mark : "." + mark);
    }
  }
  async match(e, absolute, ifDir) {
    let p = await this.matchCheck(e, ifDir);
    p && this.matchFinish(p, absolute);
  }
  matchSync(e, absolute, ifDir) {
    let p = this.matchCheckSync(e, ifDir);
    p && this.matchFinish(p, absolute);
  }
  walkCB(target, patterns, cb) {
    var _a2;
    (_a2 = this.signal) != null && _a2.aborted && cb(), this.walkCB2(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2(target, patterns, processor, cb) {
    var _a2;
    if (this.#childrenIgnored(target))
      return cb();
    if ((_a2 = this.signal) != null && _a2.aborted && cb(), this.paused) {
      this.onResume(() => this.walkCB2(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1, next = () => {
      --tasks === 0 && cb();
    };
    for (let [m, absolute, ifDir] of processor.matches.entries())
      this.#ignored(m) || (tasks++, this.match(m, absolute, ifDir).then(() => next()));
    for (let t of processor.subwalkTargets()) {
      if (this.maxDepth !== 1 / 0 && t.depth() >= this.maxDepth)
        continue;
      tasks++;
      let childrenCached = t.readdirCached();
      t.calledReaddir() ? this.walkCB3(t, childrenCached, processor, next) : t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), !0);
    }
    next();
  }
  walkCB3(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1, next = () => {
      --tasks === 0 && cb();
    };
    for (let [m, absolute, ifDir] of processor.matches.entries())
      this.#ignored(m) || (tasks++, this.match(m, absolute, ifDir).then(() => next()));
    for (let [target2, patterns] of processor.subwalks.entries())
      tasks++, this.walkCB2(target2, patterns, processor.child(), next);
    next();
  }
  walkCBSync(target, patterns, cb) {
    var _a2;
    (_a2 = this.signal) != null && _a2.aborted && cb(), this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
  }
  walkCB2Sync(target, patterns, processor, cb) {
    var _a2;
    if (this.#childrenIgnored(target))
      return cb();
    if ((_a2 = this.signal) != null && _a2.aborted && cb(), this.paused) {
      this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
      return;
    }
    processor.processPatterns(target, patterns);
    let tasks = 1, next = () => {
      --tasks === 0 && cb();
    };
    for (let [m, absolute, ifDir] of processor.matches.entries())
      this.#ignored(m) || this.matchSync(m, absolute, ifDir);
    for (let t of processor.subwalkTargets()) {
      if (this.maxDepth !== 1 / 0 && t.depth() >= this.maxDepth)
        continue;
      tasks++;
      let children = t.readdirSync();
      this.walkCB3Sync(t, children, processor, next);
    }
    next();
  }
  walkCB3Sync(target, entries, processor, cb) {
    processor = processor.filterEntries(target, entries);
    let tasks = 1, next = () => {
      --tasks === 0 && cb();
    };
    for (let [m, absolute, ifDir] of processor.matches.entries())
      this.#ignored(m) || this.matchSync(m, absolute, ifDir);
    for (let [target2, patterns] of processor.subwalks.entries())
      tasks++, this.walkCB2Sync(target2, patterns, processor.child(), next);
    next();
  }
}, GlobWalker = class extends GlobUtil {
  matches;
  constructor(patterns, path6, opts) {
    super(patterns, path6, opts), this.matches = /* @__PURE__ */ new Set();
  }
  matchEmit(e) {
    this.matches.add(e);
  }
  async walk() {
    var _a2;
    if ((_a2 = this.signal) != null && _a2.aborted)
      throw this.signal.reason;
    return this.path.isUnknown() && await this.path.lstat(), await new Promise((res, rej) => {
      this.walkCB(this.path, this.patterns, () => {
        var _a3;
        (_a3 = this.signal) != null && _a3.aborted ? rej(this.signal.reason) : res(this.matches);
      });
    }), this.matches;
  }
  walkSync() {
    var _a2;
    if ((_a2 = this.signal) != null && _a2.aborted)
      throw this.signal.reason;
    return this.path.isUnknown() && this.path.lstatSync(), this.walkCBSync(this.path, this.patterns, () => {
      var _a3;
      if ((_a3 = this.signal) != null && _a3.aborted)
        throw this.signal.reason;
    }), this.matches;
  }
}, GlobStream = class extends GlobUtil {
  results;
  constructor(patterns, path6, opts) {
    super(patterns, path6, opts), this.results = new Minipass2({
      signal: this.signal,
      objectMode: !0
    }), this.results.on("drain", () => this.resume()), this.results.on("resume", () => this.resume());
  }
  matchEmit(e) {
    this.results.write(e), this.results.flowing || this.pause();
  }
  stream() {
    let target = this.path;
    return target.isUnknown() ? target.lstat().then(() => {
      this.walkCB(target, this.patterns, () => this.results.end());
    }) : this.walkCB(target, this.patterns, () => this.results.end()), this.results;
  }
  streamSync() {
    return this.path.isUnknown() && this.path.lstatSync(), this.walkCBSync(this.path, this.patterns, () => this.results.end()), this.results;
  }
};

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/glob.js
var defaultPlatform3 = typeof process == "object" && process && typeof process.platform == "string" ? process.platform : "linux", Glob = class {
  absolute;
  cwd;
  root;
  dot;
  dotRelative;
  follow;
  ignore;
  magicalBraces;
  mark;
  matchBase;
  maxDepth;
  nobrace;
  nocase;
  nodir;
  noext;
  noglobstar;
  pattern;
  platform;
  realpath;
  scurry;
  stat;
  signal;
  windowsPathsNoEscape;
  withFileTypes;
  /**
   * The options provided to the constructor.
   */
  opts;
  /**
   * An array of parsed immutable {@link Pattern} objects.
   */
  patterns;
  /**
   * All options are stored as properties on the `Glob` object.
   *
   * See {@link GlobOptions} for full options descriptions.
   *
   * Note that a previous `Glob` object can be passed as the
   * `GlobOptions` to another `Glob` instantiation to re-use settings
   * and caches with a new pattern.
   *
   * Traversal functions can be called multiple times to run the walk
   * again.
   */
  constructor(pattern, opts) {
    if (!opts)
      throw new TypeError("glob options required");
    if (this.withFileTypes = !!opts.withFileTypes, this.signal = opts.signal, this.follow = !!opts.follow, this.dot = !!opts.dot, this.dotRelative = !!opts.dotRelative, this.nodir = !!opts.nodir, this.mark = !!opts.mark, opts.cwd ? (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) && (opts.cwd = (0, import_url2.fileURLToPath)(opts.cwd)) : this.cwd = "", this.cwd = opts.cwd || "", this.root = opts.root, this.magicalBraces = !!opts.magicalBraces, this.nobrace = !!opts.nobrace, this.noext = !!opts.noext, this.realpath = !!opts.realpath, this.absolute = opts.absolute, this.noglobstar = !!opts.noglobstar, this.matchBase = !!opts.matchBase, this.maxDepth = typeof opts.maxDepth == "number" ? opts.maxDepth : 1 / 0, this.stat = !!opts.stat, this.ignore = opts.ignore, this.withFileTypes && this.absolute !== void 0)
      throw new Error("cannot set absolute and withFileTypes:true");
    if (typeof pattern == "string" && (pattern = [pattern]), this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === !1, this.windowsPathsNoEscape && (pattern = pattern.map((p) => p.replace(/\\/g, "/"))), this.matchBase) {
      if (opts.noglobstar)
        throw new TypeError("base matching requires globstar");
      pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
    }
    if (this.pattern = pattern, this.platform = opts.platform || defaultPlatform3, this.opts = { ...opts, platform: this.platform }, opts.scurry) {
      if (this.scurry = opts.scurry, opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase)
        throw new Error("nocase option contradicts provided scurry option");
    } else {
      let Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
      this.scurry = new Scurry(this.cwd, {
        nocase: opts.nocase,
        fs: opts.fs
      });
    }
    this.nocase = this.scurry.nocase;
    let nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32", mmo = {
      // default nocase based on platform
      ...opts,
      dot: this.dot,
      matchBase: this.matchBase,
      nobrace: this.nobrace,
      nocase: this.nocase,
      nocaseMagicOnly,
      nocomment: !0,
      noext: this.noext,
      nonegate: !0,
      optimizationLevel: 2,
      platform: this.platform,
      windowsPathsNoEscape: this.windowsPathsNoEscape,
      debug: !!this.opts.debug
    }, mms = this.pattern.map((p) => new Minimatch(p, mmo)), [matchSet, globParts] = mms.reduce((set, m) => (set[0].push(...m.set), set[1].push(...m.globParts), set), [[], []]);
    this.patterns = matchSet.map((set, i) => new Pattern(set, globParts[i], 0, this.platform));
  }
  async walk() {
    return [
      ...await new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
        platform: this.platform,
        nocase: this.nocase
      }).walk()
    ];
  }
  walkSync() {
    return [
      ...new GlobWalker(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
        platform: this.platform,
        nocase: this.nocase
      }).walkSync()
    ];
  }
  stream() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
      platform: this.platform,
      nocase: this.nocase
    }).stream();
  }
  streamSync() {
    return new GlobStream(this.patterns, this.scurry.cwd, {
      ...this.opts,
      maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
      platform: this.platform,
      nocase: this.nocase
    }).streamSync();
  }
  /**
   * Default sync iteration function. Returns a Generator that
   * iterates over the results.
   */
  iterateSync() {
    return this.streamSync()[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this.iterateSync();
  }
  /**
   * Default async iteration function. Returns an AsyncGenerator that
   * iterates over the results.
   */
  iterate() {
    return this.stream()[Symbol.asyncIterator]();
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
};

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/has-magic.js
var hasMagic = (pattern, options = {}) => {
  Array.isArray(pattern) || (pattern = [pattern]);
  for (let p of pattern)
    if (new Minimatch(p, options).hasMagic())
      return !0;
  return !1;
};

// ../../node_modules/rimraf/node_modules/glob/dist/mjs/index.js
function globStreamSync(pattern, options = {}) {
  return new Glob(pattern, options).streamSync();
}
function globStream(pattern, options = {}) {
  return new Glob(pattern, options).stream();
}
function globSync(pattern, options = {}) {
  return new Glob(pattern, options).walkSync();
}
async function glob_(pattern, options = {}) {
  return new Glob(pattern, options).walk();
}
function globIterateSync(pattern, options = {}) {
  return new Glob(pattern, options).iterateSync();
}
function globIterate(pattern, options = {}) {
  return new Glob(pattern, options).iterate();
}
var streamSync = globStreamSync, stream = Object.assign(globStream, { sync: globStreamSync }), iterateSync = globIterateSync, iterate = Object.assign(globIterate, {
  sync: globIterateSync
}), sync = Object.assign(globSync, {
  stream: globStreamSync,
  iterate: globIterateSync
}), glob = Object.assign(glob_, {
  glob: glob_,
  globSync,
  sync,
  globStream,
  stream,
  globStreamSync,
  streamSync,
  globIterate,
  iterate,
  globIterateSync,
  iterateSync,
  Glob,
  hasMagic,
  escape,
  unescape
});
glob.glob = glob;

// ../../node_modules/rimraf/dist/mjs/fs.js
var import_fs3 = __toESM(require("fs"), 1), import_fs4 = require("fs"), import_fs5 = require("fs"), readdirSync2 = (path6) => (0, import_fs5.readdirSync)(path6, { withFileTypes: !0 }), chmod = (path6, mode) => new Promise((res, rej) => import_fs3.default.chmod(path6, mode, (er, ...d) => er ? rej(er) : res(...d))), mkdir = (path6, options) => new Promise((res, rej) => import_fs3.default.mkdir(path6, options, (er, made) => er ? rej(er) : res(made))), readdir2 = (path6) => new Promise((res, rej) => import_fs3.default.readdir(path6, { withFileTypes: !0 }, (er, data) => er ? rej(er) : res(data))), rename = (oldPath, newPath) => new Promise((res, rej) => import_fs3.default.rename(oldPath, newPath, (er, ...d) => er ? rej(er) : res(...d))), rm = (path6, options) => new Promise((res, rej) => import_fs3.default.rm(path6, options, (er, ...d) => er ? rej(er) : res(...d))), rmdir = (path6) => new Promise((res, rej) => import_fs3.default.rmdir(path6, (er, ...d) => er ? rej(er) : res(...d))), stat = (path6) => new Promise((res, rej) => import_fs3.default.stat(path6, (er, data) => er ? rej(er) : res(data))), lstat2 = (path6) => new Promise((res, rej) => import_fs3.default.lstat(path6, (er, data) => er ? rej(er) : res(data))), unlink = (path6) => new Promise((res, rej) => import_fs3.default.unlink(path6, (er, ...d) => er ? rej(er) : res(...d))), promises = {
  chmod,
  mkdir,
  readdir: readdir2,
  rename,
  rm,
  rmdir,
  stat,
  lstat: lstat2,
  unlink
};

// ../../node_modules/rimraf/dist/mjs/rimraf-posix.js
var import_path4 = require("path");

// ../../node_modules/rimraf/dist/mjs/readdir-or-error.js
var { readdir: readdir3 } = promises, readdirOrError = (path6) => readdir3(path6).catch((er) => er), readdirOrErrorSync = (path6) => {
  try {
    return readdirSync2(path6);
  } catch (er) {
    return er;
  }
};

// ../../node_modules/rimraf/dist/mjs/ignore-enoent.js
var ignoreENOENT = async (p) => p.catch((er) => {
  if (er.code !== "ENOENT")
    throw er;
}), ignoreENOENTSync = (fn) => {
  try {
    return fn();
  } catch (er) {
    if ((er == null ? void 0 : er.code) !== "ENOENT")
      throw er;
  }
};

// ../../node_modules/rimraf/dist/mjs/rimraf-posix.js
var { lstat: lstat3, rmdir: rmdir2, unlink: unlink2 } = promises, rimrafPosix = async (path6, opt) => {
  var _a2;
  if ((_a2 = opt == null ? void 0 : opt.signal) != null && _a2.aborted)
    throw opt.signal.reason;
  try {
    return await rimrafPosixDir(path6, opt, await lstat3(path6));
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafPosixSync = (path6, opt) => {
  var _a2;
  if ((_a2 = opt == null ? void 0 : opt.signal) != null && _a2.aborted)
    throw opt.signal.reason;
  try {
    return rimrafPosixDirSync(path6, opt, (0, import_fs4.lstatSync)(path6));
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafPosixDir = async (path6, opt, ent) => {
  var _a2;
  if ((_a2 = opt == null ? void 0 : opt.signal) != null && _a2.aborted)
    throw opt.signal.reason;
  let entries = ent.isDirectory() ? await readdirOrError(path6) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !await opt.filter(path6, ent) ? !1 : (await ignoreENOENT(unlink2(path6)), !0);
  }
  return !(await Promise.all(entries.map((ent2) => rimrafPosixDir((0, import_path4.resolve)(path6, ent2.name), opt, ent2)))).reduce((a, b) => a && b, !0) || opt.preserveRoot === !1 && path6 === (0, import_path4.parse)(path6).root || opt.filter && !await opt.filter(path6, ent) ? !1 : (await ignoreENOENT(rmdir2(path6)), !0);
}, rimrafPosixDirSync = (path6, opt, ent) => {
  var _a2;
  if ((_a2 = opt == null ? void 0 : opt.signal) != null && _a2.aborted)
    throw opt.signal.reason;
  let entries = ent.isDirectory() ? readdirOrErrorSync(path6) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !opt.filter(path6, ent) ? !1 : (ignoreENOENTSync(() => (0, import_fs4.unlinkSync)(path6)), !0);
  }
  let removedAll = !0;
  for (let ent2 of entries) {
    let p = (0, import_path4.resolve)(path6, ent2.name);
    removedAll = rimrafPosixDirSync(p, opt, ent2) && removedAll;
  }
  return opt.preserveRoot === !1 && path6 === (0, import_path4.parse)(path6).root || !removedAll || opt.filter && !opt.filter(path6, ent) ? !1 : (ignoreENOENTSync(() => (0, import_fs4.rmdirSync)(path6)), !0);
};

// ../../node_modules/rimraf/dist/mjs/rimraf-windows.js
var import_path7 = require("path");

// ../../node_modules/rimraf/dist/mjs/fix-eperm.js
var { chmod: chmod2 } = promises, fixEPERM = (fn) => async (path6) => {
  try {
    return await fn(path6);
  } catch (er) {
    let fer = er;
    if ((fer == null ? void 0 : fer.code) === "ENOENT")
      return;
    if ((fer == null ? void 0 : fer.code) === "EPERM") {
      try {
        await chmod2(path6, 438);
      } catch (er2) {
        let fer2 = er2;
        if ((fer2 == null ? void 0 : fer2.code) === "ENOENT")
          return;
        throw er;
      }
      return await fn(path6);
    }
    throw er;
  }
}, fixEPERMSync = (fn) => (path6) => {
  try {
    return fn(path6);
  } catch (er) {
    let fer = er;
    if ((fer == null ? void 0 : fer.code) === "ENOENT")
      return;
    if ((fer == null ? void 0 : fer.code) === "EPERM") {
      try {
        (0, import_fs4.chmodSync)(path6, 438);
      } catch (er2) {
        let fer2 = er2;
        if ((fer2 == null ? void 0 : fer2.code) === "ENOENT")
          return;
        throw er;
      }
      return fn(path6);
    }
    throw er;
  }
};

// ../../node_modules/rimraf/dist/mjs/retry-busy.js
var codes = /* @__PURE__ */ new Set(["EMFILE", "ENFILE", "EBUSY"]), retryBusy = (fn) => {
  let method = async (path6, opt, backoff = 1, total = 0) => {
    let mbo = opt.maxBackoff || 200, rate = opt.backoff || 1.2, max = opt.maxRetries || 10, retries = 0;
    for (; ; )
      try {
        return await fn(path6);
      } catch (er) {
        let fer = er;
        if ((fer == null ? void 0 : fer.path) === path6 && (fer != null && fer.code) && codes.has(fer.code)) {
          if (backoff = Math.ceil(backoff * rate), total = backoff + total, total < mbo)
            return new Promise((res, rej) => {
              setTimeout(() => {
                method(path6, opt, backoff, total).then(res, rej);
              }, backoff);
            });
          if (retries < max) {
            retries++;
            continue;
          }
        }
        throw er;
      }
  };
  return method;
}, retryBusySync = (fn) => (path6, opt) => {
  let max = opt.maxRetries || 10, retries = 0;
  for (; ; )
    try {
      return fn(path6);
    } catch (er) {
      let fer = er;
      if ((fer == null ? void 0 : fer.path) === path6 && (fer != null && fer.code) && codes.has(fer.code) && retries < max) {
        retries++;
        continue;
      }
      throw er;
    }
};

// ../../node_modules/rimraf/dist/mjs/rimraf-move-remove.js
var import_path6 = require("path");

// ../../node_modules/rimraf/dist/mjs/default-tmp.js
var import_os = require("os"), import_path5 = require("path");
var { stat: stat2 } = promises, isDirSync = (path6) => {
  try {
    return (0, import_fs4.statSync)(path6).isDirectory();
  } catch {
    return !1;
  }
}, isDir = (path6) => stat2(path6).then((st) => st.isDirectory(), () => !1), win32DefaultTmp = async (path6) => {
  let { root } = (0, import_path5.parse)(path6), tmp = (0, import_os.tmpdir)(), { root: tmpRoot } = (0, import_path5.parse)(tmp);
  if (root.toLowerCase() === tmpRoot.toLowerCase())
    return tmp;
  let driveTmp = (0, import_path5.resolve)(root, "/temp");
  return await isDir(driveTmp) ? driveTmp : root;
}, win32DefaultTmpSync = (path6) => {
  let { root } = (0, import_path5.parse)(path6), tmp = (0, import_os.tmpdir)(), { root: tmpRoot } = (0, import_path5.parse)(tmp);
  if (root.toLowerCase() === tmpRoot.toLowerCase())
    return tmp;
  let driveTmp = (0, import_path5.resolve)(root, "/temp");
  return isDirSync(driveTmp) ? driveTmp : root;
}, posixDefaultTmp = async () => (0, import_os.tmpdir)(), posixDefaultTmpSync = () => (0, import_os.tmpdir)(), defaultTmp = platform_default === "win32" ? win32DefaultTmp : posixDefaultTmp, defaultTmpSync = platform_default === "win32" ? win32DefaultTmpSync : posixDefaultTmpSync;

// ../../node_modules/rimraf/dist/mjs/rimraf-move-remove.js
var { lstat: lstat4, rename: rename2, unlink: unlink3, rmdir: rmdir3, chmod: chmod3 } = promises, uniqueFilename = (path6) => `.${(0, import_path6.basename)(path6)}.${Math.random()}`, unlinkFixEPERM = async (path6) => unlink3(path6).catch((er) => {
  if (er.code === "EPERM")
    return chmod3(path6, 438).then(() => unlink3(path6), (er2) => {
      if (er2.code !== "ENOENT")
        throw er;
    });
  if (er.code === "ENOENT")
    return;
  throw er;
}), unlinkFixEPERMSync = (path6) => {
  try {
    (0, import_fs4.unlinkSync)(path6);
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "EPERM")
      try {
        return (0, import_fs4.chmodSync)(path6, 438);
      } catch (er2) {
        if ((er2 == null ? void 0 : er2.code) === "ENOENT")
          return;
        throw er;
      }
    else if ((er == null ? void 0 : er.code) === "ENOENT")
      return;
    throw er;
  }
}, rimrafMoveRemove = async (path6, opt) => {
  var _a2;
  if ((_a2 = opt == null ? void 0 : opt.signal) != null && _a2.aborted)
    throw opt.signal.reason;
  try {
    return await rimrafMoveRemoveDir(path6, opt, await lstat4(path6));
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafMoveRemoveDir = async (path6, opt, ent) => {
  var _a2;
  if ((_a2 = opt == null ? void 0 : opt.signal) != null && _a2.aborted)
    throw opt.signal.reason;
  if (!opt.tmp)
    return rimrafMoveRemoveDir(path6, { ...opt, tmp: await defaultTmp(path6) }, ent);
  if (path6 === opt.tmp && (0, import_path6.parse)(path6).root !== path6)
    throw new Error("cannot delete temp directory used for deletion");
  let entries = ent.isDirectory() ? await readdirOrError(path6) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !await opt.filter(path6, ent) ? !1 : (await ignoreENOENT(tmpUnlink(path6, opt.tmp, unlinkFixEPERM)), !0);
  }
  return !(await Promise.all(entries.map((ent2) => rimrafMoveRemoveDir((0, import_path6.resolve)(path6, ent2.name), opt, ent2)))).reduce((a, b) => a && b, !0) || opt.preserveRoot === !1 && path6 === (0, import_path6.parse)(path6).root || opt.filter && !await opt.filter(path6, ent) ? !1 : (await ignoreENOENT(tmpUnlink(path6, opt.tmp, rmdir3)), !0);
}, tmpUnlink = async (path6, tmp, rm3) => {
  let tmpFile = (0, import_path6.resolve)(tmp, uniqueFilename(path6));
  return await rename2(path6, tmpFile), await rm3(tmpFile);
}, rimrafMoveRemoveSync = (path6, opt) => {
  var _a2;
  if ((_a2 = opt == null ? void 0 : opt.signal) != null && _a2.aborted)
    throw opt.signal.reason;
  try {
    return rimrafMoveRemoveDirSync(path6, opt, (0, import_fs4.lstatSync)(path6));
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafMoveRemoveDirSync = (path6, opt, ent) => {
  var _a2;
  if ((_a2 = opt == null ? void 0 : opt.signal) != null && _a2.aborted)
    throw opt.signal.reason;
  if (!opt.tmp)
    return rimrafMoveRemoveDirSync(path6, { ...opt, tmp: defaultTmpSync(path6) }, ent);
  let tmp = opt.tmp;
  if (path6 === opt.tmp && (0, import_path6.parse)(path6).root !== path6)
    throw new Error("cannot delete temp directory used for deletion");
  let entries = ent.isDirectory() ? readdirOrErrorSync(path6) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !opt.filter(path6, ent) ? !1 : (ignoreENOENTSync(() => tmpUnlinkSync(path6, tmp, unlinkFixEPERMSync)), !0);
  }
  let removedAll = !0;
  for (let ent2 of entries) {
    let p = (0, import_path6.resolve)(path6, ent2.name);
    removedAll = rimrafMoveRemoveDirSync(p, opt, ent2) && removedAll;
  }
  return !removedAll || opt.preserveRoot === !1 && path6 === (0, import_path6.parse)(path6).root || opt.filter && !opt.filter(path6, ent) ? !1 : (ignoreENOENTSync(() => tmpUnlinkSync(path6, tmp, import_fs4.rmdirSync)), !0);
}, tmpUnlinkSync = (path6, tmp, rmSync2) => {
  let tmpFile = (0, import_path6.resolve)(tmp, uniqueFilename(path6));
  return (0, import_fs4.renameSync)(path6, tmpFile), rmSync2(tmpFile);
};

// ../../node_modules/rimraf/dist/mjs/rimraf-windows.js
var { unlink: unlink4, rmdir: rmdir4, lstat: lstat5 } = promises, rimrafWindowsFile = retryBusy(fixEPERM(unlink4)), rimrafWindowsFileSync = retryBusySync(fixEPERMSync(import_fs4.unlinkSync)), rimrafWindowsDirRetry = retryBusy(fixEPERM(rmdir4)), rimrafWindowsDirRetrySync = retryBusySync(fixEPERMSync(import_fs4.rmdirSync)), rimrafWindowsDirMoveRemoveFallback = async (path6, opt) => {
  var _a2;
  if ((_a2 = opt == null ? void 0 : opt.signal) != null && _a2.aborted)
    throw opt.signal.reason;
  let { filter: filter2, ...options } = opt;
  try {
    return await rimrafWindowsDirRetry(path6, options);
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "ENOTEMPTY")
      return await rimrafMoveRemove(path6, options);
    throw er;
  }
}, rimrafWindowsDirMoveRemoveFallbackSync = (path6, opt) => {
  var _a2;
  if ((_a2 = opt == null ? void 0 : opt.signal) != null && _a2.aborted)
    throw opt.signal.reason;
  let { filter: filter2, ...options } = opt;
  try {
    return rimrafWindowsDirRetrySync(path6, options);
  } catch (er) {
    let fer = er;
    if ((fer == null ? void 0 : fer.code) === "ENOTEMPTY")
      return rimrafMoveRemoveSync(path6, options);
    throw er;
  }
}, START = Symbol("start"), CHILD = Symbol("child"), FINISH = Symbol("finish"), rimrafWindows = async (path6, opt) => {
  var _a2;
  if ((_a2 = opt == null ? void 0 : opt.signal) != null && _a2.aborted)
    throw opt.signal.reason;
  try {
    return await rimrafWindowsDir(path6, opt, await lstat5(path6), START);
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafWindowsSync = (path6, opt) => {
  var _a2;
  if ((_a2 = opt == null ? void 0 : opt.signal) != null && _a2.aborted)
    throw opt.signal.reason;
  try {
    return rimrafWindowsDirSync(path6, opt, (0, import_fs4.lstatSync)(path6), START);
  } catch (er) {
    if ((er == null ? void 0 : er.code) === "ENOENT")
      return !0;
    throw er;
  }
}, rimrafWindowsDir = async (path6, opt, ent, state = START) => {
  var _a2;
  if ((_a2 = opt == null ? void 0 : opt.signal) != null && _a2.aborted)
    throw opt.signal.reason;
  let entries = ent.isDirectory() ? await readdirOrError(path6) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !await opt.filter(path6, ent) ? !1 : (await ignoreENOENT(rimrafWindowsFile(path6, opt)), !0);
  }
  let s = state === START ? CHILD : state, removedAll = (await Promise.all(entries.map((ent2) => rimrafWindowsDir((0, import_path7.resolve)(path6, ent2.name), opt, ent2, s)))).reduce((a, b) => a && b, !0);
  if (state === START)
    return rimrafWindowsDir(path6, opt, ent, FINISH);
  if (state === FINISH) {
    if (opt.preserveRoot === !1 && path6 === (0, import_path7.parse)(path6).root || !removedAll || opt.filter && !await opt.filter(path6, ent))
      return !1;
    await ignoreENOENT(rimrafWindowsDirMoveRemoveFallback(path6, opt));
  }
  return !0;
}, rimrafWindowsDirSync = (path6, opt, ent, state = START) => {
  let entries = ent.isDirectory() ? readdirOrErrorSync(path6) : null;
  if (!Array.isArray(entries)) {
    if (entries) {
      if (entries.code === "ENOENT")
        return !0;
      if (entries.code !== "ENOTDIR")
        throw entries;
    }
    return opt.filter && !opt.filter(path6, ent) ? !1 : (ignoreENOENTSync(() => rimrafWindowsFileSync(path6, opt)), !0);
  }
  let removedAll = !0;
  for (let ent2 of entries) {
    let s = state === START ? CHILD : state, p = (0, import_path7.resolve)(path6, ent2.name);
    removedAll = rimrafWindowsDirSync(p, opt, ent2, s) && removedAll;
  }
  if (state === START)
    return rimrafWindowsDirSync(path6, opt, ent, FINISH);
  if (state === FINISH) {
    if (opt.preserveRoot === !1 && path6 === (0, import_path7.parse)(path6).root || !removedAll || opt.filter && !opt.filter(path6, ent))
      return !1;
    ignoreENOENTSync(() => {
      rimrafWindowsDirMoveRemoveFallbackSync(path6, opt);
    });
  }
  return !0;
};

// ../../node_modules/rimraf/dist/mjs/rimraf-manual.js
var rimrafManual = platform_default === "win32" ? rimrafWindows : rimrafPosix, rimrafManualSync = platform_default === "win32" ? rimrafWindowsSync : rimrafPosixSync;

// ../../node_modules/rimraf/dist/mjs/rimraf-native.js
var { rm: rm2 } = promises, rimrafNative = async (path6, opt) => (await rm2(path6, {
  ...opt,
  force: !0,
  recursive: !0
}), !0), rimrafNativeSync = (path6, opt) => ((0, import_fs4.rmSync)(path6, {
  ...opt,
  force: !0,
  recursive: !0
}), !0);

// ../../node_modules/rimraf/dist/mjs/use-native.js
var version = process.env.__TESTING_RIMRAF_NODE_VERSION__ || process.version, versArr = version.replace(/^v/, "").split("."), hasNative = +versArr[0] > 14 || +versArr[0] == 14 && +versArr[1] >= 14, useNative = !hasNative || platform_default === "win32" ? () => !1 : (opt) => !(opt != null && opt.signal) && !(opt != null && opt.filter), useNativeSync = !hasNative || platform_default === "win32" ? () => !1 : (opt) => !(opt != null && opt.signal) && !(opt != null && opt.filter);

// ../../node_modules/rimraf/dist/mjs/index.js
var typeOrUndef = (val, t) => typeof val > "u" || typeof val === t, isRimrafOptions = (o) => !!o && typeof o == "object" && typeOrUndef(o.preserveRoot, "boolean") && typeOrUndef(o.tmp, "string") && typeOrUndef(o.maxRetries, "number") && typeOrUndef(o.retryDelay, "number") && typeOrUndef(o.backoff, "number") && typeOrUndef(o.maxBackoff, "number") && (typeOrUndef(o.glob, "boolean") || o.glob && typeof o.glob == "object") && typeOrUndef(o.filter, "function"), assertRimrafOptions = (o) => {
  if (!isRimrafOptions(o))
    throw new Error("invalid rimraf options");
}, wrap = (fn) => async (path6, opt) => {
  let options = optArg(opt);
  return options.glob && (path6 = await glob(path6, options.glob)), Array.isArray(path6) ? !!(await Promise.all(path6.map((p) => fn(path_arg_default(p, options), options)))).reduce((a, b) => a && b, !0) : !!await fn(path_arg_default(path6, options), options);
}, wrapSync = (fn) => (path6, opt) => {
  let options = optArgSync(opt);
  return options.glob && (path6 = globSync(path6, options.glob)), Array.isArray(path6) ? !!path6.map((p) => fn(path_arg_default(p, options), options)).reduce((a, b) => a && b, !0) : !!fn(path_arg_default(path6, options), options);
}, nativeSync = wrapSync(rimrafNativeSync), native = Object.assign(wrap(rimrafNative), { sync: nativeSync }), manualSync = wrapSync(rimrafManualSync), manual = Object.assign(wrap(rimrafManual), { sync: manualSync }), windowsSync = wrapSync(rimrafWindowsSync), windows = Object.assign(wrap(rimrafWindows), { sync: windowsSync }), posixSync = wrapSync(rimrafPosixSync), posix2 = Object.assign(wrap(rimrafPosix), { sync: posixSync }), moveRemoveSync = wrapSync(rimrafMoveRemoveSync), moveRemove = Object.assign(wrap(rimrafMoveRemove), {
  sync: moveRemoveSync
}), rimrafSync = wrapSync((path6, opt) => useNativeSync(opt) ? rimrafNativeSync(path6, opt) : rimrafManualSync(path6, opt));
var rimraf_ = wrap((path6, opt) => useNative(opt) ? rimrafNative(path6, opt) : rimrafManual(path6, opt)), rimraf = Object.assign(rimraf_, {
  rimraf: rimraf_,
  sync: rimrafSync,
  rimrafSync,
  manual,
  manualSync,
  native,
  nativeSync,
  posix: posix2,
  posixSync,
  windows,
  windowsSync,
  moveRemove,
  moveRemoveSync
});
rimraf.rimraf = rimraf;

// src/helpers/cloneStarter.ts
var open = require_opener(), home = (0, import_os2.homedir)(), tamaguiDir = (0, import_path8.join)(home, ".tamagui"), targetGitDir = "", cloneStarter = async (template, resolvedProjectPath, projectName) => {
  targetGitDir = IS_TEST ? (0, import_path8.join)(tamaguiDir, "tamagui-test", template.repo.url.split("/").at(-1)) : (0, import_path8.join)(tamaguiDir, "tamagui", template.repo.url.split("/").at(-1)), console.info(), await setupTamaguiDotDir(template);
  let starterDir = (0, import_path8.join)(targetGitDir, ...template.repo.dir);
  console.info(), console.info(
    `Copying starter from ${starterDir} into ${import_chalk7.default.blueBright(projectName)}...`
  ), console.info(), await (0, import_fs_extra.copy)(starterDir, resolvedProjectPath), await rimraf(`${resolvedProjectPath}/.git`), console.info(import_chalk7.default.green(`${projectName} created!`)), console.info();
};
async function setupTamaguiDotDir(template, isRetry = !1) {
  let repoRoot2 = (0, import_path8.join)(__dirname, "..", "..", "..");
  if (console.info(`Setting up ${import_chalk7.default.blueBright(targetGitDir)}...`), IS_TEST && cd(repoRoot2), process.env.GITHUB_HEAD_REF)
    try {
      await $`git switch -c ${process.env.GITHUB_HEAD_REF}`;
    } catch {
    }
  let branch = template.repo.branch;
  if (IS_TEST && (console.info("Test mode: cleaning old tamagui git dir"), await (0, import_fs_extra.remove)(targetGitDir), !await (0, import_fs_extra.pathExists)((0, import_path8.join)(repoRoot2, ".git"))))
    throw new Error("Not in a git folder");
  await (0, import_fs_extra.ensureDir)(tamaguiDir), cd(tamaguiDir);
  let isInSubDir = template.repo.dir.length > 0;
  if (await (0, import_fs_extra.pathExists)(targetGitDir))
    await (0, import_fs_extra.pathExists)((0, import_path8.join)(targetGitDir, ".git")) || (console.error(`Corrupt Tamagui directory, please delete ${targetGitDir} and re-run`), process.exit(1));
  else {
    console.info("Cloning tamagui base directory"), console.info();
    let sourceGitRepo = template.repo.url, sourceGitRepoSshFallback = template.repo.sshFallback, cmd = `git clone --branch ${branch} ${isInSubDir ? "--depth 1 --sparse --filter=blob:none " : ""}${sourceGitRepo} "${targetGitDir}"`;
    try {
      try {
        console.info(`$ ${cmd}`), console.info(), (0, import_child_process.execSync)(cmd);
      } catch (error) {
        if (cmd.includes("https://")) {
          console.info("https failed - trying with ssh now...");
          let sshCmd = cmd.replace(sourceGitRepo, sourceGitRepoSshFallback);
          console.info(`$ ${sshCmd}`), console.info(), (0, import_child_process.execSync)(sshCmd);
        } else
          throw error;
      }
    } catch (error) {
      throw error instanceof Error && template.value === "takeout-starter" && error != null && error.stderr.includes("Repository not found") && (console.info(
        import_chalk7.default.yellow(
          "You don't have access to this starter. Check \u{1F961} Tamagui Takeout (https://tamagui.dev/takeout) for more info."
        )
      ), open("https://tamagui.dev/takeout"), process.exit(0)), error;
    }
  }
  if (console.info(), console.info("Updating tamagui starters repo"), console.info(), isInSubDir) {
    let cmd = `git sparse-checkout set ${template.repo.dir[0] ?? "."}`;
    (0, import_child_process.execSync)(cmd, { cwd: targetGitDir }), console.info(), console.info(`$ ${cmd}`);
  }
  try {
    let cmd2 = `git pull --rebase --allow-unrelated-histories --depth 1 origin ${branch}`;
    (0, import_child_process.execSync)(cmd2, {
      cwd: targetGitDir
    }), console.info(), console.info(`$ ${cmd2}`);
  } catch (err) {
    console.info(
      `Error updating: ${err.message} ${isRetry ? `failing.
${err.stack}` : "trying from fresh."}`
    ), isRetry && (console.info(
      "Please file an issue: https://github.com/tamagui/tamagui/issues/new?assignees=&labels=&template=bug_report.md&title="
    ), process.exit(1)), await (0, import_fs_extra.remove)(targetGitDir), await setupTamaguiDotDir(template, !0);
  }
}

// src/helpers/getProjectName.ts
var import_path9 = __toESM(require("path")), import_chalk8 = __toESM(require_source()), import_prompts = __toESM(require_prompts3());

// src/helpers/validateNpmPackage.ts
var import_validate_npm_package_name = __toESM(require_validate_npm_package_name());
function validateNpmName(name) {
  let nameValidation = (0, import_validate_npm_package_name.default)(name);
  return nameValidation.validForNewPackages ? { valid: !0 } : {
    valid: !1,
    problems: [...nameValidation.errors || [], ...nameValidation.warnings || []]
  };
}

// src/helpers/getProjectName.ts
var getProjectName = async (projectPath2) => {
  if (typeof projectPath2 == "string" && (projectPath2 = projectPath2.trim()), !projectPath2) {
    let res = await (0, import_prompts.default)({
      type: "text",
      name: "path",
      message: "Project name:",
      initial: "myapp",
      validate: (name) => {
        let validation = validateNpmName(import_path9.default.basename(import_path9.default.resolve(name)));
        return validation.valid ? !0 : "Invalid project name: " + validation.problems[0];
      }
    });
    typeof res.path == "string" && (projectPath2 = res.path.trim());
  }
  return projectPath2 || (console.log(), console.log("Please specify the project directory:"), console.log(`  ${import_chalk8.default.cyan(package_default.name)} ${import_chalk8.default.green("<project-directory>")}`), console.log(), console.log("For example:"), console.log(`  ${import_chalk8.default.cyan(package_default.name)} ${import_chalk8.default.green("my-tamagui-app")}`), console.log(), console.log(`Run ${import_chalk8.default.cyan(`${package_default.name} --help`)} to see all options.`), process.exit(1)), projectPath2;
};

// src/helpers/getShouldUseGit.ts
var import_prompts2 = __toESM(require_prompts3());
var getShouldUseGit = async () => IS_TEST || !!(await (0, import_prompts2.default)({
  type: "confirm",
  name: "gitInit",
  message: "Do you want to use git?",
  initial: !0
})).gitInit;

// src/helpers/getTemplateInfo.ts
var import_prompts4 = __toESM(require_prompts3());

// src/templates.ts
var import_fs14 = require("fs"), import_path11 = require("path"), import_chalk13 = __toESM(require_source());

// src/steps/simple-web.ts
var import_chalk9 = __toESM(require_source()), packageManager = "yarn", useYarn = packageManager === "yarn", runCommand = (scriptName) => `${packageManager} ${useYarn ? "" : "run "}${scriptName}`, main = async ({ isFullClone, projectName }) => {
  isFullClone && console.info(`
  ${import_chalk9.default.green.bold("Done!")} created a new project under ./${projectName}

cd into the project using:
  ${import_chalk9.default.green("cd")} ${projectName}
`), console.info(`
  To start the Next.js development server, run:
    ${import_chalk9.default.green(runCommand("web"))}
`);
}, simple_web_default = main;

// src/steps/expo-router.ts
var import_chalk10 = __toESM(require_source());
var main2 = async ({ isFullClone, projectName }) => {
  isFullClone && console.info(`
  ${import_chalk10.default.green.bold("Done!")} created a new project under ./${projectName}

cd into the project using:
  ${import_chalk10.default.green("cd")} ${projectName}
`);
}, expo_router_default = main2;

// src/steps/starter-free.ts
var import_chalk11 = __toESM(require_source()), packageManager2 = "yarn", useYarn2 = packageManager2 === "yarn", runCommand2 = (scriptName) => `${packageManager2} ${useYarn2 ? "" : "run "}${scriptName}`, main3 = async ({ isFullClone, projectName }) => {
  console.info("Note: you need yarn for this repo."), isFullClone && console.info(`${import_chalk11.default.green.bold(
    "Done!"
  )} created a new project under ./${projectName}

cd into the project using:
  ${import_chalk11.default.green("cd")} ${projectName}
`), console.info(`
  To start the Next.js development server, run:
    ${import_chalk11.default.green(runCommand2("web"))}
    
  To start Expo Go for mobile development, run:
    ${import_chalk11.default.green(runCommand2("native"))}

  You can also create Expo development builds by doing:
  
    ${import_chalk11.default.green("cd apps/expo")} 
    then:
    ${import_chalk11.default.green(runCommand2("ios"))} 
    or...
    ${import_chalk11.default.green(runCommand2("android"))}

  Be sure to replace yourprojectsname in app.json with the uid you'd like for your app.
`);
}, starter_free_default = main3;

// src/steps/takeout.ts
var import_child_process2 = require("child_process"), import_fs13 = require("fs"), import_promises2 = __toESM(require("fs/promises")), import_path10 = __toESM(require("path")), import_chalk12 = __toESM(require_source()), import_prompts3 = __toESM(require_prompts3());
var packageManager3 = "yarn", useYarn3 = packageManager3 === "yarn", runCommand3 = (scriptName) => `${packageManager3} ${useYarn3 ? "" : "run "}${scriptName}`, main4 = async ({ isFullClone, projectName, projectPath: projectPath2 }) => {
  console.info(`
${tamaguiRainbowAsciiArt.split(`
`).map((line) => `                ${line}`).join(`
`)}
${takeoutAsciiArt}

`), console.info();
  let { setupSupabase } = await (0, import_prompts3.default)({
    name: "setupSupabase",
    message: "Set up Supabase?",
    type: "confirm",
    initial: !0
  });
  if (setupSupabase) {
    console.info();
    let { startLocalSupabase } = await (0, import_prompts3.default)({
      name: "startLocalSupabase",
      type: "confirm",
      message: "Start local Supabase instance for you? (Requires Docker)",
      initial: !0
    });
    if (startLocalSupabase && await runRetryableCommand("yarn supa start")) {
      console.info();
      let { setUpSupabaseEnv } = await (0, import_prompts3.default)({
        name: "setUpSupabaseEnv",
        type: "confirm",
        message: "Do you want us to add the local env variables for you? This will create a file called .env.local.",
        initial: !0
      });
      if (setUpSupabaseEnv) {
        let envs = getEnvFromSupabaseStatus((0, import_child_process2.execSync)("yarn supa status").toString()), newEnvContent = Object.entries(envs).map(([key, value]) => `${key}=${value}`).join(`
`);
        (0, import_fs13.existsSync)(import_path10.default.join(projectPath2, ".env.local")) && (0, import_fs13.readFileSync)(import_path10.default.join(projectPath2, ".env.local")).toString() !== newEnvContent && (0, import_fs13.renameSync)(
          import_path10.default.join(projectPath2, ".env.local"),
          import_path10.default.join(projectPath2, `.env.local.old-${Number(/* @__PURE__ */ new Date())}`)
        ), await import_promises2.default.writeFile(import_path10.default.join(projectPath2, "./.env.local"), newEnvContent);
      }
    }
    console.info();
    let { setupRemoteSupabase } = await (0, import_prompts3.default)({
      name: "setupRemoteSupabase",
      type: "confirm",
      message: "Link remote Supabase instance for you? (Create a project on https://app.supabase.com/projects first)",
      initial: !0
    });
    setupRemoteSupabase && (await runRetryableCommand("npx supabase login"), console.info(), await linkSupabase());
  }
  isFullClone && console.info(`
  ${import_chalk12.default.green.bold("Done!")} created a new project under ./${projectName}

cd into the project using:
  ${import_chalk12.default.green("  cd")} ${projectName}
  `), console.info(`
  To start the Next.js development server, run:
    ${import_chalk12.default.green(runCommand3("web"))}

  To start developing with Expo Go, run:
    ${import_chalk12.default.green(runCommand3("native"))}

  To start developing for Expo dev build, run:
    ${import_chalk12.default.green(runCommand3("ios"))}
    ${import_chalk12.default.green(runCommand3("android"))}

  To run Supabase scripts, cd into the supabase package:
    ${import_chalk12.default.green("cd supabase")}

    ${import_chalk12.default.green("yarn reset")} - Resets local database
    ${import_chalk12.default.green("yarn generate")} - Generates new types

    Find info on the rest of the scripts in ${import_chalk12.default.cyan("supabase/README.md")}

    If you've purchased and gained access to font and icon packages, you can run:
    ${import_chalk12.default.green("yarn tamagui add icon")}
    ${import_chalk12.default.green("yarn tamagui add font")}
  `);
}, takeout_default = main4;
async function runRetryableCommand(cmd, retriesCount = 0) {
  try {
    return (0, import_child_process2.execSync)(cmd, { stdio: "inherit" }), !0;
  } catch {
    let { tryAgain } = await (0, import_prompts3.default)({
      name: "tryAgain",
      message: "An error occurred. Do you want to try again?",
      type: "confirm",
      initial: !0
    });
    if (tryAgain)
      await runRetryableCommand(cmd, retriesCount + 1);
    else
      return console.info(
        import_chalk12.default.yellow(
          `\u26A0\uFE0F Skipping this step. You can try running this command later. The failed command was \`${import_chalk12.default.underline(
            cmd
          )}\`.`
        )
      ), !1;
  }
}
async function linkSupabase() {
  let { supabaseRefId } = await (0, import_prompts3.default)({
    name: "supabaseRefId",
    type: "text",
    message: "Enter your supabase project's ID (e.g. abcdefghijklmnopqrst)",
    initial: !0
  }), cmd = `npx supabase link --project-ref ${supabaseRefId.trim()}`;
  try {
    return (0, import_child_process2.execSync)(cmd, {
      stdio: "inherit"
    }), !0;
  } catch {
    let { tryAgain } = await (0, import_prompts3.default)({
      name: "tryAgain",
      message: "An error occurred. Do you want to try again?",
      type: "confirm",
      initial: !0
    });
    if (tryAgain)
      await linkSupabase();
    else
      return console.info(
        import_chalk12.default.yellow(
          `\u26A0\uFE0F Skipping this step. You can try running this command later. The failed command was \`${import_chalk12.default.underline(
            cmd
          )}\`.`
        )
      ), !1;
  }
}
function getEnvFromSupabaseStatus(status) {
  var _a2, _b, _c, _d, _e, _f;
  return {
    NEXT_PUBLIC_SUPABASE_URL: (_a2 = status.match(/API URL: (.*)/)) == null ? void 0 : _a2[1],
    NEXT_PUBLIC_SUPABASE_GRAPHQL_URL: (_b = status.match(/GraphQL URL: (.*)/)) == null ? void 0 : _b[1],
    SUPABASE_DB_URL: (_c = status.match(/DB URL: (.*)/)) == null ? void 0 : _c[1],
    NEXT_PUBLIC_SUPABASE_ANON_KEY: (_d = status.match(/anon key: (.*)/)) == null ? void 0 : _d[1],
    SUPABASE_SERVICE_ROLE: (_e = status.match(/service_role key: (.*)/)) == null ? void 0 : _e[1],
    SUPABASE_JWT_SECRET: (_f = status.match(/JWT secret: (.*)/)) == null ? void 0 : _f[1]
  };
}

// src/templates.ts
var repoRoot = (0, import_path11.join)(__dirname, "..", "..", ".."), starterFreeRoot = (0, import_path11.join)(__dirname, "..", "..", "..", "..", "starter-free"), starterExists = (0, import_fs14.existsSync)(starterFreeRoot), templates = [
  {
    title: "Free - Expo + Next in a production ready monorepo",
    value: "starter-free",
    type: "free",
    hidden: !1,
    packageManager: "yarn",
    repo: {
      url: IS_TEST && starterExists ? `file://${starterFreeRoot}` : "https://github.com/tamagui/starter-free.git",
      sshFallback: "git@github.com:tamagui/starter-free.git",
      dir: [],
      branch: "main"
    },
    extraSteps: starter_free_default
  },
  {
    title: "Learning - Vite + Webpack, Tamagui config from scratch",
    value: "simple-web",
    type: "included-in-monorepo",
    hidden: !1,
    repo: {
      url: IS_TEST ? `file://${repoRoot}` : "https://github.com/tamagui/tamagui.git",
      sshFallback: "git@github.com:tamagui/tamagui.git",
      dir: ["starters", "simple-web"],
      branch: "master"
    },
    extraSteps: simple_web_default
  },
  {
    title: "Expo Router (beta) - The base Expo router starter + Tamagui",
    value: "expo-router",
    type: "included-in-monorepo",
    hidden: !1,
    repo: {
      url: IS_TEST ? `file://${repoRoot}` : "https://github.com/tamagui/tamagui.git",
      sshFallback: "git@github.com:tamagui/tamagui.git",
      dir: ["starters", "expo-router"],
      branch: "master"
    },
    extraSteps: expo_router_default
  },
  {
    title: `${import_chalk13.default.bold.underline(
      `\u{1F961} ${makeRainbowChalk("Takeout")}`
    )} - Paid stack to ship apps w/users fast: https://tamagui.dev/takeout`,
    value: "takeout-starter",
    type: "premium",
    packageManager: "yarn",
    hidden: !1,
    repo: {
      url: "https://github.com/tamagui/takeout",
      sshFallback: "git@github.com:tamagui/takeout.git",
      dir: [],
      branch: "main"
    },
    extraSteps: takeout_default
  }
];

// src/helpers/getTemplateInfo.ts
var getTemplateInfo = async (template) => (isTemplateValid(template) || (template = (await (0, import_prompts4.default)({
  name: "template",
  type: "select",
  message: "Pick a template:",
  choices: templates.filter((t) => !t.hidden)
})).template), typeof template != "string" || !isTemplateValid(template) ? (console.warn(`template ${template} is not valid.`), await getTemplateInfo(template)) : templates.find((t) => t.value === template)), isTemplateValid = (template) => typeof template == "string" && templates.some(({ value }) => value === template);

// src/helpers/installDependencies.ts
var PackageManager = __toESM(require_build());
async function installDependencies(projectRoot, packageManager4) {
  let options = { cwd: projectRoot };
  packageManager4 === "yarn" ? await new PackageManager.YarnPackageManager(options).installAsync() : await new PackageManager.NpmPackageManager(options).installAsync();
}

// src/index.ts
var projectPath = "";
IS_TEST && console.info("\u{1F9D0} Running create-tamagui in test mode \u{1F9D0}");
var program = new import_commander.default.Command(package_default.name).version(package_default.version).arguments("<project-directory>").action((name) => {
  projectPath = name;
}).option(
  "--skip-cloning",
  "Skips the cloning and basic setup and goes directly to the setup specific to the starter. Use if you already have the starter wanna run the setup or see the instructions again."
).option(
  "--template <template>, -t <template>",
  "Choose between starter-free, a more full featured template with Expo and Next.js, a simple client-only web starter that includes a nice simple example configuration to understand the basics more easily, or the premium Takeout \u{1F961} starter.",
  ""
).allowUnknownOption().usage(
  `${import_chalk14.default.green("<project-directory>")} [options]

Example usage:

${import_chalk14.default.blueBright(`npx ${package_default.name} next-expo`)}`
).parse(process.argv);
process.argv.includes("--version") && (console.info(package_default.version), process.exit(0));
var skipCloning = !!program.skipCloning;
async function run() {
  skipCloning || (console.info(), console.info(tamaguiRainbowAsciiArt), console.info(import_chalk14.default.bold("Creating tamagui app...")), parseFloat(
    (0, import_child_process3.execSync)("git --version").toString().replace("git version ", "").trim()
  ) < 2.27 && (console.error(`

 \u26A0\uFE0F Tamagui can't install: Git version must be >= 2.27

`), process.exit(1))), projectPath = skipCloning ? (0, import_process.cwd)() : await getProjectName(projectPath);
  let template = await getTemplateInfo(program.template);
  if (template.type === "premium" && ((await (0, import_prompts5.default)({
    type: "confirm",
    name: "purchased",
    message: "Have you purchased Takeout on https://tamagui.dev/takeout"
  })).purchased || ((0, import_opener.default)("https://tamagui.dev/takeout"), console.info(
    `
Opening Takeout website - once you purchase you can restart the create process. Thank you!
`
  ), process.exit(0))), skipCloning)
    await template.extraSteps({
      isFullClone: !1,
      projectName: import_path12.default.basename((0, import_process.cwd)()),
      projectPath: (0, import_process.cwd)()
    });
  else {
    console.info();
    let resolvedProjectPath = import_path12.default.resolve(process.cwd(), projectPath), projectName = import_path12.default.basename(resolvedProjectPath), { valid, problems } = validateNpmName(projectName);
    valid || (console.error(
      `Could not create a project called ${import_chalk14.default.red(
        `"${projectName}"`
      )} because of npm naming restrictions:`
    ), problems.forEach((p) => console.error(`    ${import_chalk14.default.red.bold("*")} ${p}`)), process.exit(1)), import_fs15.default.existsSync(resolvedProjectPath) && (console.info(), console.info(
      import_chalk14.default.red("\u{1F6A8} [tamagui] error"),
      `You tried to make a project called ${import_chalk14.default.underline(
        import_chalk14.default.blueBright(projectName)
      )}, but a folder with that name already exists: ${import_chalk14.default.blueBright(
        resolvedProjectPath
      )}

${import_chalk14.default.bold(import_chalk14.default.red("Please pick a different project name \u{1F978}"))}`
    ), console.info(), console.info(), process.exit(1)), console.info(), console.info(`Creating a new tamagui app ${import_chalk14.default.blueBright(resolvedProjectPath)}...`), import_fs15.default.mkdirSync(resolvedProjectPath), console.info(import_chalk14.default.green(`${projectName} folder created.`));
    let shouldGitInit = await getShouldUseGit();
    try {
      await cloneStarter(template, resolvedProjectPath, projectName), cd(resolvedProjectPath), console.info(), shouldGitInit && await $`git init`;
    } catch (e) {
      console.error(`[tamagui] Failed to copy example into ${resolvedProjectPath}

`, e), process.exit(1);
    }
    updatePackageJsonName(projectName, resolvedProjectPath), console.info("Installing packages. This might take a couple of minutes."), console.info();
    let packageManager4 = ("packageManager" in template ? template.packageManager : void 0) || await detect();
    try {
      console.info("installing with " + packageManager4), await installDependencies(resolvedProjectPath, packageManager4);
    } catch (e) {
      console.error("[tamagui] error installing with " + packageManager4 + `
${e}`), process.exit(1);
    }
    if (shouldGitInit)
      try {
        (0, import_child_process3.execSync)("git checkout -b main", { stdio: "ignore" }), (0, import_child_process3.execSync)("git add -A", { stdio: "ignore" }), (0, import_child_process3.execSync)('git commit -m "Initial commit from create-tamagui"', {
          stdio: "ignore"
        });
      } catch (e) {
        console.error(`[tamagui] Failed to create initial commit.

`, e.message);
      }
    await template.extraSteps({
      isFullClone: !0,
      projectName,
      projectPath: resolvedProjectPath
    });
  }
  console.info(), console.info(import_chalk14.default.gray(tamaguiDuckAsciiArt));
}
function updatePackageJsonName(projectName, dir) {
  let packageJsonPath = import_path12.default.join(dir, "package.json");
  if ((0, import_fs_extra2.existsSync)(packageJsonPath)) {
    let contentWithUpdatedName = (0, import_fs_extra2.readFileSync)(packageJsonPath).toString().replace(
      /("name": ")(.*)(",)/,
      `$1${projectName}$3`
    );
    (0, import_fs_extra2.writeFileSync)(packageJsonPath, contentWithUpdatedName);
  }
}
run();
/*! Bundled license information:

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel/index.js:
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

imurmurhash/imurmurhash.js:
  (**
   * @preserve
   * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
   *
   * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
   * @see http://github.com/homebrewing/brauhaus-diff
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *)
*/
//# sourceMappingURL=index.js.map
